<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Lieven Clement" />


<title>3. Prediction with High Dimensional Predictors</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #204a87; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #8f5902; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #204a87; font-weight: bold; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */

.sourceCode .row {
  width: 100%;
}
.sourceCode {
  overflow-x: auto;
}
.code-folding-btn {
  margin-right: -30px;
}
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>


<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">HDDA</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="fa fa-chalkboard-teacher"></span>
     
    Lectures
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="intro.html">1. Introduction</a>
    </li>
    <li>
      <a href="svd.html">2. Singular Value Decomposition</a>
    </li>
    <li>
      <a href="prediction.html">3. Prediction with High Dimensional Predictors</a>
    </li>
    <li>
      <a href="sparseSvd.html">4. Sparse Singular Value Decomposition</a>
    </li>
    <li>
      <a href="lda.html">5. Linear Discriminant Analysis</a>
    </li>
    <li>
      <a href="hclust.html">6.1. Introduction to Clustering</a>
    </li>
    <li>
      <a href="https://sites.stat.washington.edu/people/raftery/Research/PDF/fraley1998.pdf">6.2. Paper Model-based Clustering</a>
    </li>
    <li>
      <a href="em.html">6.3. EM algorithm</a>
    </li>
    <li>
      <a href="lsi.html">7. Large Scale Inference</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    <span class="fa fa-laptop"></span>
     
    Labs
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Lab1-Intro-SVD.html">Lab 1: Intro &amp; SVD</a>
    </li>
    <li>
      <a href="Lab2-PCA.html">Lab 2: SVD - PCA</a>
    </li>
    <li>
      <a href="Lab3-Penalized-Regression.html">Lab 3: Prediction</a>
    </li>
    <li>
      <a href="Lab4-Sparse-PCA-LDA.html">Lab 4: Sparse PCA &amp; LDA</a>
    </li>
    <li>
      <a href="Lab5-Clustering.html">Lab 5: Clustering</a>
    </li>
    <li>
      <a href="Lab6-Large-Scale-Inference.html">Lab 6: LSI</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="https://github.com/statOmics/HDDA">
    <span class="fab fa-github"></span>
     
  </a>
</li>
<li>
  <a href="http://statomics.github.io/">statOmics</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">3. Prediction with High Dimensional Predictors</h1>
<h4 class="author">Lieven Clement</h4>
<h4 class="date">statOmics, Ghent University (<a href="https://statomics.github.io" class="uri">https://statomics.github.io</a>)</h4>

</div>


<div id="introduction" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<div id="prediction-with-high-dimensional-predictors" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Prediction with High Dimensional Predictors</h2>
<p>General setting:</p>
<ul>
<li><p>Aim: build a <strong>prediction model</strong> that gives a prediction of an outcome for a given set of predictors.</p></li>
<li><p>We use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> to refer to the predictors and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math> to refer to the outcome.</p></li>
<li><p>A <strong>training data set</strong> is available, say <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X},\mathbf{Y})</annotation></semantics></math>. It contains <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> observations on outcomes and on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> predictors.</p></li>
<li><p>Using the training data, a prediction model is build, say <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{X})</annotation></semantics></math>. This typically involves <strong>model building (feature selection)</strong> and parameter estimation.</p></li>
<li><p>During the model building, potential <strong>models need to be evaluated</strong> in terms of their prediction quality.</p></li>
</ul>
</div>
<div id="example-toxicogenomics-in-early-drug-development" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Example: Toxicogenomics in early drug development</h2>
<div id="background" class="section level3" number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> Background</h3>
<ul>
<li><p>Effect of compound on gene expression.</p></li>
<li><p>Insight in action and toxicity of drug in early phase</p></li>
<li><p>Determine activity with bio-assay: e.g. binding affinity of compound to cell wall receptor (target, IC50).</p></li>
<li><p>Early phase: 20 to 50 compounds</p></li>
<li><p>Based on in vitro results one aims to get insight in how to build better compound (higher on-target activity less toxicity.</p></li>
<li><p>Small variations in molecular structure lead to variations in BA and gene expression.</p></li>
<li><p>Aim: Build model to predict bio-activity based on gene expression in liver cell line.</p></li>
</ul>
</div>
<div id="data" class="section level3" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> Data</h3>
<ul>
<li><p>30 chemical compounds have been screened for toxicity</p></li>
<li><p>Bioassay data on toxicity screening</p></li>
<li><p>Gene expressions in a liver cell line are profiled for each compound (4000 genes)</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>toxData <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="st">&quot;https://raw.githubusercontent.com/statOmics/HDA2020/data/toxDataCentered.csv&quot;</span>,</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="at">col_types =</span> <span class="fu">cols</span>()</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>svdX <span class="ot">&lt;-</span> <span class="fu">svd</span>(toxData[,<span class="sc">-</span><span class="dv">1</span>])</span></code></pre></div>
<p>Data is already centered:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>toxData <span class="sc">%&gt;%</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  colMeans <span class="sc">%&gt;%</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  range</span></code></pre></div>
<pre><code>#&gt; [1] -2.405483e-17  5.921189e-17</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a> toxData <span class="sc">%&gt;%</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  names <span class="sc">%&gt;%</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  head</span></code></pre></div>
<pre><code>#&gt; [1] &quot;BA&quot; &quot;X1&quot; &quot;X2&quot; &quot;X3&quot; &quot;X4&quot; &quot;X5&quot;</code></pre>
<ul>
<li>First column contains data on Bioassay.</li>
<li>The higher the score on Bioassay the more toxic the compound</li>
<li>Other columns contain data on gene expression X1, … , X4000</li>
</ul>
</div>
<div id="data-exploration" class="section level3" number="1.2.3">
<h3><span class="header-section-number">1.2.3</span> Data exploration</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>toxData <span class="sc">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x=</span><span class="st">&quot;&quot;</span>,<span class="at">y=</span>BA)) <span class="sc">+</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>(<span class="at">outlier.shape=</span><span class="cn">NA</span>) <span class="sc">+</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">position=</span><span class="st">&quot;jitter&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>svdX <span class="ot">&lt;-</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  svd</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>Vk <span class="ot">&lt;-</span> svdX<span class="sc">$</span>v[,<span class="dv">1</span><span class="sc">:</span>k]</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>Uk <span class="ot">&lt;-</span> svdX<span class="sc">$</span>u[,<span class="dv">1</span><span class="sc">:</span>k]</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>Dk <span class="ot">&lt;-</span> <span class="fu">diag</span>(svdX<span class="sc">$</span>d[<span class="dv">1</span><span class="sc">:</span>k])</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>Zk <span class="ot">&lt;-</span> Uk<span class="sc">%*%</span>Dk</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="fu">colnames</span>(Zk) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;Z&quot;</span>,<span class="dv">1</span><span class="sc">:</span>k)</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="fu">colnames</span>(Vk) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;V&quot;</span>,<span class="dv">1</span><span class="sc">:</span>k)</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>Zk <span class="sc">%&gt;%</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>  as.data.frame <span class="sc">%&gt;%</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">BA =</span> toxData <span class="sc">%&gt;%</span> <span class="fu">pull</span>(BA)) <span class="sc">%&gt;%</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x=</span> Z1, <span class="at">y =</span> Z2, <span class="at">color =</span> BA)) <span class="sc">+</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>) <span class="sc">+</span></span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>  <span class="fu">scale_colour_gradient2</span>(<span class="at">low =</span> <span class="st">&quot;blue&quot;</span>,<span class="at">mid=</span><span class="st">&quot;white&quot;</span>,<span class="at">high=</span><span class="st">&quot;red&quot;</span>) <span class="sc">+</span></span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>, <span class="at">pch =</span> <span class="dv">21</span>, <span class="at">color =</span> <span class="st">&quot;black&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<ul>
<li>Scores on the first two principal components (or MDS plot).</li>
<li>Each point corresponds to a compound.</li>
<li>Color code refers to the toxicity score (higher score more toxic).</li>
<li>Clear separation between compounds according to toxicity.</li>
</ul>
<hr />
<ul>
<li>Next logic step in a PCA is to interpret the principal components.</li>
<li>We thus have to assess the loadings.</li>
<li>We can add a vector for each gene to get a biplot, but this would require plotting 4000 vectors, which would render the plot unreadable.</li>
</ul>
<p>Alternative graph to look at the many loadings of the first two PCs.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">grid.arrange</span>(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  Vk <span class="sc">%&gt;%</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    as.data.frame <span class="sc">%&gt;%</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">geneID =</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(Vk)) <span class="sc">%&gt;%</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> geneID, <span class="at">y =</span> V1)) <span class="sc">+</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">pch=</span><span class="dv">21</span>) <span class="sc">+</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>)<span class="sc">*</span><span class="fu">sd</span>(Vk[,<span class="dv">1</span>]), <span class="at">col =</span> <span class="st">&quot;red&quot;</span>) ,</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>  Vk <span class="sc">%&gt;%</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>    as.data.frame <span class="sc">%&gt;%</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">geneID =</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(Vk)) <span class="sc">%&gt;%</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> geneID, <span class="at">y =</span> V2)) <span class="sc">+</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">pch=</span><span class="dv">21</span>) <span class="sc">+</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>    <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>)<span class="sc">*</span><span class="fu">sd</span>(Vk[,<span class="dv">2</span>]), <span class="at">col =</span> <span class="st">&quot;red&quot;</span>),</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>  <span class="at">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<ul>
<li><p>It is almost impossible to interpret the PCs because there are 4000 genes contributing to each PC.</p></li>
<li><p>In an attempt to find the most important genes (in the sense that they drive the interpretation of the PCs), the plots show horizontal reference lines: the average of the loadings, and the average ± twice the standard deviation of the loadings. In between the lines we expects about 95% of the loadings (if they were normally distributed).</p></li>
<li><p>The points outside the band come from the genes that have rather large loadings (in absolute value) and hence are important for the interpretation of the PCs.</p></li>
<li><p>Note, that particularly for the first PC, only a few genes show a markedly large loadings that are negative. This means that an upregulation of these genes will lead to low scores on PC1.</p></li>
<li><p>These genes will very likely play an important role in the toxicity mechanism.</p></li>
<li><p>Indeed, low scores on PC1 are in the direction of more toxicity.</p></li>
<li><p>In the next chapter we will introduce a method to obtain sparse PCs.</p></li>
</ul>
</div>
<div id="prediction-model" class="section level3" number="1.2.4">
<h3><span class="header-section-number">1.2.4</span> Prediction model</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>m1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(BA <span class="sc">~</span> <span class="sc">-</span><span class="dv">1</span> <span class="sc">+</span> ., toxData)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>m1 <span class="sc">%&gt;%</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  coef <span class="sc">%&gt;%</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="fu">head</span>(<span class="dv">40</span>)</span></code></pre></div>
<pre><code>#&gt;          X1          X2          X3          X4          X5          X6 
#&gt;  -7.4569940   0.3571348  11.2492315  10.8354021 -13.7433891   5.6833874 
#&gt;          X7          X8          X9         X10         X11         X12 
#&gt;  65.5387777   4.3404555   7.9103924  37.0296057 -54.8368698 -55.5547845 
#&gt;         X13         X14         X15         X16         X17         X18 
#&gt;   5.7924667  23.1428002  -6.9610365 -28.5250571 -22.5509025 -97.9623731 
#&gt;         X19         X20         X21         X22         X23         X24 
#&gt; -30.4171782 -32.6991673 -14.2808834 -16.1431266 -22.7498681  73.1635178 
#&gt;         X25         X26         X27         X28         X29         X30 
#&gt;  -5.7065827  37.4745379 -20.1999102  14.9906821  99.6080955          NA 
#&gt;         X31         X32         X33         X34         X35         X36 
#&gt;          NA          NA          NA          NA          NA          NA 
#&gt;         X37         X38         X39         X40 
#&gt;          NA          NA          NA          NA</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>m1 <span class="sc">%&gt;%</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  coef <span class="sc">%&gt;%</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  is.na <span class="sc">%&gt;%</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  sum</span></code></pre></div>
<pre><code>#&gt; [1] 3971</code></pre>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">summary</span>(m1)<span class="sc">$</span>r.squared</span></code></pre></div>
<pre><code>#&gt; [1] 1</code></pre>
<p>Problem??</p>
</div>
</div>
<div id="brain-example" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Brain example</h2>
<ul>
<li>Courtesy to Solomon Kurz. Statistical rethinking with brms, ggplot2, and the tidyverse version 1.2.0.</li>
</ul>
<p><a href="https://bookdown.org/content/3890/" class="uri">https://bookdown.org/content/3890/</a>
<a href="https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse" class="uri">https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse</a></p>
<ul>
<li>Data with brain size and body size for seven species</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>brain <span class="ot">&lt;-</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">tibble</span>(<span class="at">species =</span> <span class="fu">c</span>(<span class="st">&quot;afarensis&quot;</span>, <span class="st">&quot;africanus&quot;</span>, <span class="st">&quot;habilis&quot;</span>, <span class="st">&quot;boisei&quot;</span>, <span class="st">&quot;rudolfensis&quot;</span>, <span class="st">&quot;ergaster&quot;</span>, <span class="st">&quot;sapiens&quot;</span>),</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>       <span class="at">brain   =</span> <span class="fu">c</span>(<span class="dv">438</span>, <span class="dv">452</span>, <span class="dv">612</span>, <span class="dv">521</span>, <span class="dv">752</span>, <span class="dv">871</span>, <span class="dv">1350</span>),</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>       <span class="at">mass    =</span> <span class="fu">c</span>(<span class="fl">37.0</span>, <span class="fl">35.5</span>, <span class="fl">34.5</span>, <span class="fl">41.5</span>, <span class="fl">55.5</span>, <span class="fl">61.0</span>, <span class="fl">53.5</span>))</span></code></pre></div>
<div id="data-exploration-1" class="section level3" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> Data exploration</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>brain</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["species"],"name":[1],"type":["chr"],"align":["left"]},{"label":["brain"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["mass"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"afarensis","2":"438","3":"37.0"},{"1":"africanus","2":"452","3":"35.5"},{"1":"habilis","2":"612","3":"34.5"},{"1":"boisei","2":"521","3":"41.5"},{"1":"rudolfensis","2":"752","3":"55.5"},{"1":"ergaster","2":"871","3":"61.0"},{"1":"sapiens","2":"1350","3":"53.5"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>p <span class="ot">&lt;-</span> brain <span class="sc">%&gt;%</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span>  mass, <span class="at">y =</span> brain, <span class="at">label =</span> species)) <span class="sc">+</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>  <span class="fu">geom_point</span>()</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>p <span class="sc">+</span> <span class="fu">geom_text</span>(<span class="at">nudge_y =</span> <span class="dv">40</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
</div>
<div id="models" class="section level3" number="1.3.2">
<h3><span class="header-section-number">1.3.2</span> Models</h3>
<p>Six models range in complexity from the simple univariate model</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">brain</mtext><mi>i</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mo>Normal</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo>,</mo><mi>σ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mi>i</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mtext mathvariant="normal">mass</mtext><mi>i</mi></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\text{brain}_i &amp; \sim \operatorname{Normal} (\mu_i, \sigma) \\
\mu_i &amp; = \beta_0 + \beta_1 \text{mass}_i,
\end{align*}</annotation></semantics></math></p>
<p>to the dizzying sixth-degree polynomial model</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">brain</mtext><mi>i</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mo>Normal</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo>,</mo><mi>σ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>μ</mi><mi>i</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mtext mathvariant="normal">mass</mtext><mi>i</mi></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msubsup><mtext mathvariant="normal">mass</mtext><mi>i</mi><mn>2</mn></msubsup><mo>+</mo><msub><mi>β</mi><mn>3</mn></msub><msubsup><mtext mathvariant="normal">mass</mtext><mi>i</mi><mn>3</mn></msubsup><mo>+</mo><msub><mi>β</mi><mn>4</mn></msub><msubsup><mtext mathvariant="normal">mass</mtext><mi>i</mi><mn>4</mn></msubsup><mo>+</mo><msub><mi>β</mi><mn>5</mn></msub><msubsup><mtext mathvariant="normal">mass</mtext><mi>i</mi><mn>5</mn></msubsup><mo>+</mo><msub><mi>β</mi><mn>6</mn></msub><msubsup><mtext mathvariant="normal">mass</mtext><mi>i</mi><mn>6</mn></msubsup><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\text{brain}_i &amp; \sim \operatorname{Normal} (\mu_i, \sigma) \\
\mu_i &amp; = \beta_0 + \beta_1 \text{mass}_i + \beta_2 \text{mass}_i^2 + \beta_3 \text{mass}_i^3 + \beta_4 \text{mass}_i^4 + \beta_5 \text{mass}_i^5 + \beta_6 \text{mass}_i^6.
\end{align*}</annotation></semantics></math></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>formulas <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="cf">function</span>(i)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  <span class="fu">return</span>(</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>     <span class="fu">paste0</span>(<span class="st">&quot;I(mass^&quot;</span>,<span class="dv">1</span><span class="sc">:</span>i,<span class="st">&quot;)&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">paste</span>(<span class="at">collapse=</span><span class="st">&quot; + &quot;</span>)</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>    )</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>)</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>formulas <span class="ot">&lt;-</span> <span class="fu">sapply</span>(</span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a>  <span class="fu">paste0</span>(<span class="st">&quot;brain ~ &quot;</span>, formulas),</span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>  as.formula)</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a>models <span class="ot">&lt;-</span> <span class="fu">lapply</span>(formulas, lm , <span class="at">data =</span> brain)</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">data.frame</span>(</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  <span class="at">formula=</span>formulas <span class="sc">%&gt;%</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>    as.character,</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>  <span class="at">r2 =</span> <span class="fu">sapply</span>(</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>    models,</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>    <span class="cf">function</span>(mod) <span class="fu">summary</span>(mod)<span class="sc">$</span>r.squared)</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>  )  <span class="sc">%&gt;%</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>  <span class="fu">ggplot</span>(</span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">x =</span> r2,</span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>      <span class="at">y =</span> formula,</span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a>      <span class="at">label =</span> r2 <span class="sc">%&gt;%</span></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>        <span class="fu">round</span>(<span class="dv">2</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a>        as.character)</span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a>  <span class="fu">geom_text</span>()</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>We plot the fit for each model individually and them arrange them together in one plot.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>plots <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>, <span class="cf">function</span>(i)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>{</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>  p <span class="sc">+</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="at">formula =</span> y <span class="sc">~</span> <span class="fu">poly</span>(x,i)) <span class="sc">+</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>  <span class="fu">ggtitle</span>(</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>    <span class="fu">paste0</span>(</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>      <span class="st">&quot;r2 = &quot;</span>,</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>      <span class="fu">round</span>(<span class="fu">summary</span>(models[[i]])<span class="sc">$</span>r.squared<span class="sc">*</span><span class="dv">100</span>,<span class="dv">1</span>),</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>      <span class="st">&quot;%&quot;</span>)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>    )</span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a>})</span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a><span class="fu">do.call</span>(<span class="st">&quot;grid.arrange&quot;</span>,<span class="fu">c</span>(plots, <span class="at">ncol =</span> <span class="dv">3</span>))</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<ul>
<li><p>We clearly see that increasing the model complexity always produces a fit with a smaller SSE.</p></li>
<li><p>The problem of overfitting is very obvious. The more complex polynomial models will not generalise well for prediction!</p></li>
<li><p>We even have a model that fits the data perfectly, but that will make very absurd preditions!</p></li>
<li><p>Too few parameters hurts, too. Fit the underfit intercept-only model.</p></li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>m0 <span class="ot">&lt;-</span> <span class="fu">lm</span>(brain <span class="sc">~</span> <span class="dv">1</span>, brain)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="fu">summary</span>(m0)</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Call:
#&gt; lm(formula = brain ~ 1, data = brain)
#&gt; 
#&gt; Residuals:
#&gt;     Min      1Q  Median      3Q     Max 
#&gt; -275.71 -227.21 -101.71   97.79  636.29 
#&gt; 
#&gt; Coefficients:
#&gt;             Estimate Std. Error t value Pr(&gt;|t|)   
#&gt; (Intercept)    713.7      121.8    5.86  0.00109 **
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 322.2 on 6 degrees of freedom</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>p <span class="sc">+</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>  <span class="fu">stat_smooth</span>(<span class="at">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="at">formula =</span> y <span class="sc">~</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>  <span class="fu">ggtitle</span>(</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>    <span class="fu">paste0</span>(</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>      <span class="st">&quot;r2 = &quot;</span>,</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>      <span class="fu">round</span>(<span class="fu">summary</span>(m0)<span class="sc">$</span>r.squared<span class="sc">*</span><span class="dv">100</span>,<span class="dv">1</span>),</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>      <span class="st">&quot;%&quot;</span>)</span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>    )</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>The underfit model did not learn anything about the relation between mass and brain. It would also do a very poor job for predicting new data.</p>
</div>
</div>
<div id="overview" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Overview</h2>
<p>We will make a distinction between continuous and discrete outcomes. In this course we focus on</p>
<ul>
<li><p>Linear regression models for continous outcomes</p>
<ul>
<li>Penalised regression: Lasso and ridge</li>
<li>Principal component regression (PCR)</li>
</ul></li>
<li><p>Logistic regression models for binary outcomes</p>
<ul>
<li>Penalised regression: Lasso and ridge</li>
</ul></li>
</ul>
<p>For all types of model, we will discuss feature selection methods.</p>
</div>
</div>
<div id="linear-regression-for-high-dimensional-data" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Linear Regression for High Dimensional Data</h1>
<p>Consider linear regression model (for double centered data)
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>=</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>X</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msub><mi>X</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo>+</mo><mi>⋯</mi><mo>+</mo><msub><mi>β</mi><mi>p</mi></msub><msub><mi>X</mi><mrow><mi>i</mi><mi>p</mi></mrow></msub><mo>+</mo><msub><mi>ϵ</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
  Y_i = \beta_1X_{i1} + \beta_2 X_{i2} + \cdots + \beta_pX_{ip} + \epsilon_i ,
</annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mi>ϵ</mi><mo>∣</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{E}\left[\epsilon \mid \mathbf{X}\right]=0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mi>ϵ</mi><mo>∣</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\text{var}\left[\epsilon \mid \mathbf{X}\right]=\sigma^2</annotation></semantics></math>.</p>
<p>In matrix notation the model becomes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐘</mi><mo>=</mo><mi>𝐗</mi><mi>𝛃</mi><mo>+</mo><mi>𝛜</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \mathbf{Y} = \mathbf{X}\mathbf\beta + \mathbf\epsilon.
</annotation></semantics></math>
The least squares estimator of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\mathbf\beta</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐘</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \hat{\mathbf\beta} = (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{Y} ,
</annotation></semantics></math>
and the variance of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\mathbf\beta}</annotation></semantics></math> equals
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>σ</mi><mn>2</mn></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X}^T\mathbf{X})^{-1}\sigma^2.
</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math> the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p \times p</annotation></semantics></math> matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(\mathbf{X}^T\mathbf{X})^{-1}</annotation></semantics></math> is crucial</p>
<p>Note, that</p>
<ul>
<li><p>with double centered data it is meant that both the responses are centered (mean of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐘</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math> is zero) and that all predictors are centered (columns of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> have zero mean). With double centered data the intercept in a linear regression model is always exactly equal to zero and hence the intercept must not be included in the model.</p></li>
<li><p>we do not assume that the residuals are normally distributed. For prediction purposes this is often not required (normality is particularly important for statistical inference in small samples).</p></li>
</ul>
<div id="linear-regression-for-multivariate-data-vs-high-dimensional-data" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Linear Regression for multivariate data vs High Dimensional Data</h2>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{X^TX}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(\mathbf{X^TX})^{-1}</annotation></semantics></math> are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p \times p</annotation></semantics></math> matrices</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{X^TX}</annotation></semantics></math> can only be inverted if it has rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math></p></li>
<li><p>Rank of a matrix of form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{X^TX}</annotation></semantics></math>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n\times p</annotation></semantics></math> matrix, can never be larger than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\min(n,p)</annotation></semantics></math>.</p></li>
<li><p>in most regression problems <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n&gt;p</annotation></semantics></math> and rank of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X^TX})</annotation></semantics></math> equals <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math></p></li>
<li><p>in high dimensional regression problems <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mo>&gt;</mo><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p &gt;&gt;&gt; n</annotation></semantics></math> and rank of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X^TX})</annotation></semantics></math> equals <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n&lt;p</annotation></semantics></math></p></li>
<li><p>in the toxicogenomics example <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>30</mn><mo>&lt;</mo><mi>p</mi><mo>=</mo><mn>4000</mn></mrow><annotation encoding="application/x-tex">n=30&lt;p=4000</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">rank</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mi>n</mi><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\text{rank}(\mathbf{X^TX})\leq n=30</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(\mathbf{X^TX})^{-1}</annotation></semantics></math> does not exist, and neither does <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\beta}}</annotation></semantics></math>.</p></li>
</ul>
</div>
<div id="can-svd-help" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Can SVD help?</h2>
<ul>
<li><p>Since the columns of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> are centered, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>∝</mo><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{X^TX} \propto \text{var}\left[\mathbf{X}\right]</annotation></semantics></math>.</p></li>
<li><p>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">rank</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\text{rank}(\mathbf{X^TX})=n=30</annotation></semantics></math>, the PCA will give 30 components, each being a linear combination of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>4000</mn></mrow><annotation encoding="application/x-tex">p=4000</annotation></semantics></math> variables. These 30 PCs contain all information present in the original <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> data.</p></li>
<li><p>if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">rank</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">\text{rank}(\mathbf{X})=n=30</annotation></semantics></math>, the SVD of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐗</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>δ</mi><mi>i</mi></msub><msub><mi>𝐮</mi><mi>i</mi></msub><msubsup><mi>𝐯</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mi>𝐔</mi><mi>𝚫</mi><msup><mi>𝐕</mi><mi>T</mi></msup><mo>=</mo><msup><mrow><mi>𝐙</mi><mi>𝐕</mi></mrow><mi>T</mi></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
   \mathbf{X} = \sum_{i=1}^n \delta_i \mathbf{u}_i \mathbf{v}_i^T = \mathbf{U} \boldsymbol{\Delta} \mathbf{V}^T = \mathbf{ZV}^T,
  </annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐙</mi><annotation encoding="application/x-tex">\mathbf{Z}</annotation></semantics></math> the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math> matrix with the scores on the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> PCs.</p></li>
<li><p>Still problematic because if we use all PCs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n=p</annotation></semantics></math>.</p></li>
</ul>
</div>
</div>
<div id="principal-component-regression" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Principal Component Regression</h1>
<p>A principal component regression (PCR) consists of</p>
<ol style="list-style-type: decimal">
<li><p>transforming <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>4000</mn></mrow><annotation encoding="application/x-tex">p=4000</annotation></semantics></math> dimensional <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-variable to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">n=30</annotation></semantics></math> dimensional <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>-variable (PC scores). The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> PCs are mutually uncorrelated.</p></li>
<li><p>using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> PC-variables as regressors in a linear regression model</p></li>
<li><p>performing feature selection to select the most important regressors (PC).</p></li>
</ol>
<p>Feature selection is key, because we don’t want to have as many regressors as there are observations in the data. This would result in zero residual degrees of freedom. (see later)</p>
<hr />
<p>To keep the exposition general so that we allow for a feature selection to have taken place, I use the notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐔</mi><mi>S</mi></msub><annotation encoding="application/x-tex">\mathbf{U}_S</annotation></semantics></math> to denote a matrix with left-singular column vectors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐮</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{u}_i</annotation></semantics></math>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>𝒮</mi></mrow><annotation encoding="application/x-tex">i \in {\mathcal{S}}</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒮</mi><annotation encoding="application/x-tex">{\mathcal{S}}</annotation></semantics></math> an index set referring to the PCs to be included in the regression model).</p>
<p>For example, suppose that a feature selection method has resulted in the selection of PCs 1, 3 and 12 for inclusion in the prediction model, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒮</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>12</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">{\mathcal{S}}=\{1,3,12\}</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐔</mi><mi>S</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>𝐮</mi><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>𝐮</mi><mn>3</mn></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>𝐮</mi><mn>12</mn></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
 \mathbf{U}_S = \begin{pmatrix}
  \mathbf{u}_1 &amp; \mathbf{u}_3 &amp; \mathbf{u}_{12}
 \end{pmatrix}.
</annotation></semantics></math></p>
<hr />
<div id="example-model-based-on-first-4-pcs" class="section level3" number="3.0.1">
<h3><span class="header-section-number">3.0.1</span> Example model based on first 4 PCs</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>Uk <span class="ot">&lt;-</span> svdX<span class="sc">$</span>u[,<span class="dv">1</span><span class="sc">:</span>k]</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>Dk <span class="ot">&lt;-</span> <span class="fu">diag</span>(svdX<span class="sc">$</span>d[<span class="dv">1</span><span class="sc">:</span>k])</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>Zk <span class="ot">&lt;-</span> Uk<span class="sc">%*%</span>Dk</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>Y <span class="ot">&lt;-</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>  <span class="fu">pull</span>(BA)</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>m4 <span class="ot">&lt;-</span> <span class="fu">lm</span>(Y<span class="sc">~</span>Zk[,<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>])</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a><span class="fu">summary</span>(m4)</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Call:
#&gt; lm(formula = Y ~ Zk[, 1:4])
#&gt; 
#&gt; Residuals:
#&gt;     Min      1Q  Median      3Q     Max 
#&gt; -2.1438 -0.7033 -0.1222  0.7255  2.2997 
#&gt; 
#&gt; Coefficients:
#&gt;               Estimate Std. Error t value Pr(&gt;|t|)    
#&gt; (Intercept)  7.961e-16  2.081e-01   0.000   1.0000    
#&gt; Zk[, 1:4]1  -5.275e-01  7.725e-02  -6.828 3.72e-07 ***
#&gt; Zk[, 1:4]2  -1.231e-02  8.262e-02  -0.149   0.8828    
#&gt; Zk[, 1:4]3  -1.759e-01  8.384e-02  -2.098   0.0461 *  
#&gt; Zk[, 1:4]4  -3.491e-02  8.396e-02  -0.416   0.6811    
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 1.14 on 25 degrees of freedom
#&gt; Multiple R-squared:  0.672,  Adjusted R-squared:  0.6195 
#&gt; F-statistic:  12.8 on 4 and 25 DF,  p-value: 8.352e-06</code></pre>
<p>Note:</p>
<ul>
<li>the intercept is estimated as zero. (Why?) The model could have been fitted as</li>
</ul>
<pre><code>m4 &lt;- lm(Y~-1+Zk[,1:4])</code></pre>
<ul>
<li><p>the PC-predictors are uncorrelated (by construction)</p></li>
<li><p>first PC-predictors are not necessarily the most important predictors</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-values are not very meaningful when prediction is the objective</p></li>
</ul>
<p>Methods for feature selection will be discussed later.</p>
</div>
</div>
<div id="ridge-regression" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Ridge Regression</h1>
<div id="penalty" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Penalty</h2>
<p>The ridge parameter estimator is defined as the parameter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\mathbf\beta</annotation></semantics></math> that minimises the <strong>penalised least squares criterion</strong></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">SSE</mtext><mtext mathvariant="normal">pen</mtext></msub><mo>=</mo><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mi>λ</mi><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">
 \text{SSE}_\text{pen}=\Vert\mathbf{Y} - \mathbf{X\beta}\Vert_2^2 + \lambda \Vert \boldsymbol{\beta} \Vert_2^2
</annotation></semantics></math></p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msubsup><mi>β</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\Vert \boldsymbol{\beta} \Vert_2^2=\sum_{j=1}^p \beta_j^2</annotation></semantics></math> is the <strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>2</mn></msub><annotation encoding="application/x-tex">L_2</annotation></semantics></math> penalty term</strong></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda&gt;0</annotation></semantics></math> is the penalty parameter (to be chosen by the user).</p></li>
</ul>
<p>Note, that that is equivalent to minimizing
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> subject to </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mo>≤</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">
\Vert\mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \boldsymbol{\beta}\Vert^2_2\leq s
</annotation></semantics></math></p>
<p>Note, that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> has a one-to-one correspondence with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></p>
</div>
<div id="graphical-interpretation" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Graphical interpretation</h2>
<p><img src="prediction_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
<div id="solution" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Solution</h2>
<p>The solution is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐘</mi></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \hat{\boldsymbol{\beta}} = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X^T Y}.
</annotation></semantics></math>
It can be shown that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X^TX}+\lambda \mathbf{I})</annotation></semantics></math> is always of rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda&gt;0</annotation></semantics></math>.</p>
<p>Hence, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X^TX}+\lambda \mathbf{I})</annotation></semantics></math> is invertible and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\beta}}</annotation></semantics></math> exists even if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mo>&gt;</mo><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p&gt;&gt;&gt;n</annotation></semantics></math>.</p>
<p>We also find
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>σ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X}^T\mathbf{X} (\mathbf{X^TX}+\lambda \mathbf{I})^{-1}\sigma^2
</annotation></semantics></math></p>
<p>However, it can be shown that improved intervals that also account for the bias can be constructed by using:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>σ</mi><mn>2</mn></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1}  \sigma^2.
</annotation></semantics></math></p>
<div id="proof" class="section level3" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> Proof</h3>
<p>The criterion to be minimised is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">SSE</mtext><mtext mathvariant="normal">pen</mtext></msub><mo>=</mo><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mi>λ</mi><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \text{SSE}_\text{pen}=\Vert\mathbf{Y} - \mathbf{X\beta}\Vert_2^2 + \lambda \Vert \boldsymbol{\beta} \Vert_2^2.
 </annotation></semantics></math>
First we re-express SSE in matrix notation:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">SSE</mtext><mtext mathvariant="normal">pen</mtext></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>T</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>λ</mi><msup><mi>𝛃</mi><mi>T</mi></msup><mi>𝛃</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \text{SSE}_\text{pen} = (\mathbf{Y}-\mathbf{X\beta})^T(\mathbf{Y}-\mathbf{X\beta}) + \lambda \boldsymbol{\beta}^T\boldsymbol{\beta}.
 </annotation></semantics></math>
The partial derivative w.r.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math> is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>∂</mi><mrow><mi>∂</mi><mi>𝛃</mi></mrow></mfrac><msub><mtext mathvariant="normal">SSE</mtext><mtext mathvariant="normal">pen</mtext></msub><mo>=</mo><mi>−</mi><mn>2</mn><msup><mi>𝐗</mi><mi>T</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>λ</mi><mi>𝛃</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \frac{\partial}{\partial \boldsymbol{\beta}}\text{SSE}_\text{pen} = -2\mathbf{X}^T(\mathbf{Y}-\mathbf{X\beta})+2\lambda\boldsymbol{\beta}.
 </annotation></semantics></math>
Solving <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>∂</mi><mrow><mi>∂</mi><mi>𝛃</mi></mrow></mfrac><msub><mtext mathvariant="normal">SSE</mtext><mtext mathvariant="normal">pen</mtext></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial \boldsymbol{\beta}}\text{SSE}_\text{pen}=0</annotation></semantics></math> gives
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐘</mi></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \hat{\boldsymbol{\beta}} = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X^T Y}.
 </annotation></semantics></math>
(assumption: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X^TX}+\lambda \mathbf{I})</annotation></semantics></math> is of rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>. This is always true if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda&gt;0</annotation></semantics></math>)</p>
</div>
</div>
<div id="link-with-svd" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> Link with SVD</h2>
<div id="svd-and-inverse" class="section level3" number="4.4.1">
<h3><span class="header-section-number">4.4.1</span> SVD and inverse</h3>
<p>Write the SVD of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p&gt;n</annotation></semantics></math>) as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐗</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>δ</mi><mi>i</mi></msub><msub><mi>𝐮</mi><mi>i</mi></msub><msubsup><mi>𝐯</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><msub><mi>δ</mi><mi>i</mi></msub><msub><mi>𝐮</mi><mi>i</mi></msub><msubsup><mi>𝐯</mi><mi>i</mi><mi>T</mi></msubsup><mo>=</mo><mi>𝐔</mi><mi>𝚫</mi><msup><mi>𝐕</mi><mi>T</mi></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
   \mathbf{X} = \sum_{i=1}^n \delta_i \mathbf{u}_i \mathbf{v}_i^T = \sum_{i=1}^p \delta_i \mathbf{u}_i \mathbf{v}_i^T  = \mathbf{U}\boldsymbol{\Delta} \mathbf{V}^T ,
</annotation></semantics></math>
with</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>δ</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mi>⋯</mi><mo>=</mo><msub><mi>δ</mi><mi>p</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta_{n+1}=\delta_{n+2}= \cdots = \delta_p=0</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚫</mi><annotation encoding="application/x-tex">\boldsymbol{\Delta}</annotation></semantics></math> a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p\times p</annotation></semantics></math> diagonal matrix of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>δ</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\delta_1,\ldots, \delta_p</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math> an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n\times p</annotation></semantics></math> matrix and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math> a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p \times p</annotation></semantics></math> matrix. Note that only the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> columns of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math> are informative.</p></li>
</ul>
<p>With the SVD of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math> we write
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo>=</mo><mi>𝐕</mi><msup><mi>𝚫</mi><mn>2</mn></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \mathbf{X}^T\mathbf{X} = \mathbf{V}\boldsymbol{\Delta
     }^2\mathbf{V}^T.
 </annotation></semantics></math>
The inverse of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}^T\mathbf{X}</annotation></semantics></math> is then given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo>=</mo><mi>𝐕</mi><msup><mi>𝚫</mi><mrow><mi>−</mi><mn>2</mn></mrow></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
   (\mathbf{X}^T\mathbf{X})^{-1} = \mathbf{V}\boldsymbol{\Delta}^{-2}\mathbf{V}^T.
 </annotation></semantics></math>
Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚫</mi><annotation encoding="application/x-tex">\boldsymbol{\Delta}</annotation></semantics></math> has <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>δ</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mi>⋯</mi><mo>=</mo><msub><mi>δ</mi><mi>p</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta_{n+1}=\delta_{n+2}= \cdots = \delta_p=0</annotation></semantics></math>, it is not invertible.</p>
</div>
<div id="svd-of-penalised-matrix-mathbfxtxlambda-mathbfi" class="section level3" number="4.4.2">
<h3><span class="header-section-number">4.4.2</span> SVD of penalised matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi></mrow><annotation encoding="application/x-tex">\mathbf{X^TX}+\lambda \mathbf{I}</annotation></semantics></math></h3>
<p>It can be shown that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo>=</mo><mi>𝐕</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>𝐕</mi><mi>T</mi></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
  \mathbf{X^TX}+\lambda \mathbf{I} = \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I}) \mathbf{V}^T ,
</annotation></semantics></math>
i.e. adding a constant to the diagonal elements does not affect the eigenvectors, and all eigenvalues are increased by this constant.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math> zero eigenvalues become <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</p>
<p>Hence,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo>=</mo><mi>𝐕</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
  (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} = \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I})^{-1} \mathbf{V}^T ,
</annotation></semantics></math>
which can be computed even when some eigenvalues in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝚫</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\boldsymbol{\Delta}^2</annotation></semantics></math> are zero.</p>
<p>Note, that for high dimensional data (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mo>&gt;</mo><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p&gt;&gt;&gt;n</annotation></semantics></math>) many eigenvalues are zero because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><annotation encoding="application/x-tex">\mathbf{X^TX}</annotation></semantics></math> is a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p \times p</annotation></semantics></math> matrix and has rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.</p>
<p>The identity <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo>=</mo><mi>𝐕</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>𝐕</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf{X^TX}+\lambda \mathbf{I} = \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I}) \mathbf{V}^T</annotation></semantics></math> is easily checked:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>𝐕</mi><mi>T</mi></msup><mo>=</mo><mi>𝐕</mi><msup><mi>𝚫</mi><mn>2</mn></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mo>+</mo><mi>λ</mi><msup><mrow><mi>𝐕</mi><mi>𝐕</mi></mrow><mi>T</mi></msup><mo>=</mo><mi>𝐕</mi><msup><mi>𝚫</mi><mn>2</mn></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo>=</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I}) \mathbf{V}^T = \mathbf{V}\boldsymbol{\Delta}^2\mathbf{V}^T + \lambda \mathbf{VV}^T  = \mathbf{V}\boldsymbol{\Delta}^2\mathbf{V}^T + \lambda \mathbf{I} = \mathbf{X^TX}+\lambda \mathbf{I}.
</annotation></semantics></math></p>
</div>
</div>
<div id="properties" class="section level2" number="4.5">
<h2><span class="header-section-number">4.5</span> Properties</h2>
<ul>
<li><p>The Ridge estimator is biased! The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math> are shrunken to zero!
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐗</mi><mi>T</mi></msup><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mi>𝛃</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray}
 \text{E}[\hat{\boldsymbol{\beta}}] &amp;=&amp; (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \mathbf{X}^T \text{E}[\mathbf{Y}]\\
&amp;=&amp; (\mathbf{X}^T\mathbf{X}+\lambda \mathbf{I})^{-1} \mathbf{X}^T \mathbf{X}\boldsymbol{\beta}\\
\end{eqnarray}</annotation></semantics></math></p></li>
<li><p>Note, that the shrinkage is larger in the direction of the smaller eigenvalues.</p></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>𝐕</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mi>𝐕</mi><msup><mi>𝚫</mi><mn>2</mn></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mi>𝛃</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>𝐕</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝚫</mi><mn>2</mn></msup><msup><mi>𝐕</mi><mi>T</mi></msup><mi>𝛃</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mi>𝐕</mi><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mfrac><msubsup><mi>δ</mi><mn>1</mn><mn>2</mn></msubsup><mrow><msubsup><mi>δ</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><mi>λ</mi></mrow></mfrac></mtd><mtd columnalign="center" style="text-align: center"><mi>…</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>…</mi></mtd><mtd columnalign="center" style="text-align: center"><mfrac><msubsup><mi>δ</mi><mi>r</mi><mn>2</mn></msubsup><mrow><msubsup><mi>δ</mi><mi>r</mi><mn>2</mn></msubsup><mo>+</mo><mi>λ</mi></mrow></mfrac></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><msup><mi>𝐕</mi><mi>T</mi></msup><mi>𝛃</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray}
\text{E}[\hat{\boldsymbol{\beta}}]&amp;=&amp;\mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I})^{-1} \mathbf{V}^T \mathbf{V} \boldsymbol{\Delta}^2 \mathbf{V}^T\boldsymbol{\beta}\\
&amp;=&amp;\mathbf{V} (\boldsymbol{\Delta}^2+\lambda \mathbf{I})^{-1} \boldsymbol{\Delta}^2 \mathbf{V}^T\boldsymbol{\beta}\\
&amp;=&amp; \mathbf{V}
\left[\begin{array}{ccc}
\frac{\delta_1^2}{\delta_1^2+\lambda}&amp;\ldots&amp;0 \\
&amp;\vdots&amp;\\
0&amp;\ldots&amp;\frac{\delta_r^2}{\delta_r^2+\lambda}
\end{array}\right]
\mathbf{V}^T\boldsymbol{\beta}
\end{eqnarray}</annotation></semantics></math></p>
<ul>
<li><p>the variance of the prediction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>𝐱</mi><mi>T</mi></msup><mover><mi>β</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">\hat{{Y}}(\mathbf{x})=\mathbf{x}^T\hat\beta</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mi>𝐱</mi><mi>T</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><mi>𝐱</mi></mrow><annotation encoding="application/x-tex">
 \text{var}\left[\hat{{Y}}(\mathbf{x})\mid \mathbf{x}\right] = \mathbf{x}^T(\mathbf{X^TX}+\lambda \mathbf{I})^{-1}\mathbf{x}
  </annotation></semantics></math>
is smaller than with the least-squares estimator.</p></li>
<li><p>through the bias-variance trade-off it is hoped that better predictions in terms of expected conditional test error can be obtained, for an appropriate choice of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</p></li>
</ul>
<p>Recall the expression of the expected conditional test error
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>E</mi><mi>r</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><msup><mtext mathvariant="normal">bias</mtext><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray}
  Err(\mathbf{x}) &amp;=&amp; \text{E}\left[(\hat{Y} - Y^*)^2\mid \mathbf{x}\right]\\
  &amp;=&amp;
  \text{var}\left[\hat{Y}\mid \mathbf{x}\right] + \text{bias}^2(\mathbf{x})+
  \text{var}\left[Y^*\mid \mathbf{x}\right]
\end{eqnarray}</annotation></semantics></math>
where</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>=</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>𝐱</mi><mi>T</mi></msup><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">\hat{Y}=\hat{Y}(\mathbf{x})=\mathbf{x}^T\hat{\boldsymbol{\beta}}</annotation></semantics></math> is the prediction at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> is an outcome at predictor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">E</mtext><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mu(\mathbf{x}) = \text{E}\left[\hat{Y}\mid \mathbf{x}\right] \text{ and } \mu^*(x)=\text{E}\left[Y^*\mid \mathbf{x}\right]</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">bias</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{bias}(\mathbf{x})=\mu(\mathbf{x})-\mu^*(\mathbf{x})</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{var}\left[Y^*\mid \mathbf{x}\right]</annotation></semantics></math> the irreducible error that does not depend on the model. It simply originates from observations that randomly fluctuate around the true mean <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu^*(x)</annotation></semantics></math>.</li>
</ul>
</div>
<div id="toxicogenomics-example" class="section level2" number="4.6">
<h2><span class="header-section-number">4.6</span> Toxicogenomics example</h2>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>mRidge <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>  <span class="at">x =</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>    as.matrix,</span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>  <span class="at">y =</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>    <span class="fu">pull</span>(BA),</span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">0</span>) <span class="co"># ridge: alpha = 0</span></span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a><span class="fu">plot</span>(mRidge, <span class="at">xvar=</span><span class="st">&quot;lambda&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>The R function uses to refer to the penalty parameter. In this course we use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>, because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> is often used as eigenvalues.</p>
<p>The graph shows that with increasing penalty parameter, the parameter estimates are shrunken towards zero. The estimates will only reach zero for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>→</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">\lambda \rightarrow \infty</annotation></semantics></math>. The stronger the shrinkage, the larger the bias (towards zero) and the smaller the variance of the parameter estimators (and hence also smaller variance of the predictions).</p>
<p>Another (informal) viewpoint is the following. By shrinking the estimates towards zero, the estimates loose some of their ``degrees of freedom’’ so that the parameters become estimable with only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n&lt;p</annotation></semantics></math> data points. Even with a very small <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda&gt;0</annotation></semantics></math>, the parameters regain their estimability. However, note that the variance of the estimator is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">var</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><msup><mi>𝐗</mi><mi>𝐓</mi></msup><mi>𝐗</mi></mrow><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mi>𝐕</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝚫</mi><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐕</mi><mi>T</mi></msup><msup><mi>σ</mi><mn>2</mn></msup><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \text{var}\left[\hat{\mathbf\beta}\right] = (\mathbf{X^TX}+\lambda \mathbf{I})^{-1} \sigma^2 = \mathbf{V}(\boldsymbol{\Delta}^2+\lambda\mathbf{I})^{-1}\mathbf{V}^T\sigma^2.
</annotation></semantics></math>
Hence, a small <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> will result in large variances of the parameter estimators. The larger <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>, the smaller the variances become. In the limit, as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>→</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">\lambda\rightarrow\infty</annotation></semantics></math>, the estimates are converged to zero and show no variability any longer.</p>
</div>
</div>
<div id="lasso-regression" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Lasso Regression</h1>
<ul>
<li><p>The Lasso is another example of penalised regression.</p></li>
<li><p>The lasso estimator of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math> is the solution to minimising the penalised SSE
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">SSE</mtext><mtext mathvariant="normal">pen</mtext></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><msubsup><mi>𝐱</mi><mi>i</mi><mi>T</mi></msubsup><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>λ</mi><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><mo stretchy="false" form="postfix">|</mo><msub><mi>β</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">|</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
 \text{SSE}_\text{pen} = \sum_{i=1}^n (Y_i - \mathbf{x}_i^T\boldsymbol{\beta})^2 + \lambda \sum_{j=1}^p \vert \beta_j\vert.
</annotation></semantics></math></p></li>
</ul>
<p>or, equivalently, minimising</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SSE</mtext><mo>=</mo><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> subject to </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>1</mn></msub><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">
\text{SSE}  = \Vert \mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \mathbf\beta\Vert_1 \leq c
</annotation></semantics></math>
with</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>1</mn></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><mo stretchy="false" form="postfix">|</mo><msub><mi>β</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">\Vert \mathbf\beta\Vert_1 = \sum\limits_{j=1}^p \vert \beta_j \vert</annotation></semantics></math></p></li>
<li><p>Despite strong similarity between ridge and lasso regression (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>2</mn></msub><annotation encoding="application/x-tex">L_2</annotation></semantics></math> versus <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math> norm in penalty term), there is no analytical solution of the lasso parameter estimator of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\mathbf\beta</annotation></semantics></math>.</p></li>
<li><p>Fortunately, computational efficient algorithms have been implemented in statistical software</p></li>
<li><p>The Lasso estimator of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝛃</mi><annotation encoding="application/x-tex">\boldsymbol{\beta}</annotation></semantics></math> is biased and generally has a smaller variance then the least-squares estimator.</p></li>
<li><p>Hence, the bias-variance trade-off may here also help in finding better predictions with biased estimators.</p></li>
<li><p>In contrast to ridge regression, however, the lasso estimator can give at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\min(p,n)</annotation></semantics></math> non-zero <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>-estimates.</p></li>
<li><p>Hence, at first sight the lasso is not directly appropriate for high-dimensional settings.</p></li>
<li><p>An important advantage of the lasso is that choosing an appropriate value for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> is a kind a model building or feature selection procedure (see further).</p></li>
</ul>
<div id="graphical-interpretation-of-lasso-vs-ridge" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Graphical interpretation of Lasso vs ridge</h2>
<p>Note that the lasso is a constrained regression problem with</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> subject to </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>1</mn></msub><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">
\Vert \mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \mathbf\beta\Vert_1 \leq c
</annotation></semantics></math>
and ridge
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> subject to </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">
\Vert \mathbf{Y} - \mathbf{X\beta}\Vert_2^2 \text{ subject to } \Vert \mathbf\beta\Vert^2_2 \leq c
</annotation></semantics></math></p>
<p><img src="prediction_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>Note, that</p>
<ul>
<li>parameters for the lasso can never switch sign, they are set at zero! Selection!</li>
<li>ridge regression can lead to parameters that switch sign.</li>
</ul>
</div>
<div id="toxicogenomics-example-1" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Toxicogenomics example</h2>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>mLasso <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>  <span class="at">x =</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>    as.matrix,</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>  <span class="at">y =</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>    <span class="fu">pull</span>(BA),</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a><span class="at">alpha =</span> <span class="dv">1</span>)</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a><span class="fu">plot</span>(mLasso, <span class="at">xvar =</span> <span class="st">&quot;lambda&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<ul>
<li><p>The graph with the paths of the parameter estimates nicely illustrates the typical behaviour of the lasso estimates as a function of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>: when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> increases the estimates are shrunken towards zero.</p></li>
<li><p>When an estimate hits zero, it remains exactly equal to zero when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math> further increases. A parameter estimate equal to zero, say <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\hat\beta_j=0</annotation></semantics></math>, implies that the corresponding predictor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>j</mi></msub><annotation encoding="application/x-tex">x_j</annotation></semantics></math> is no longer included in the model (i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>j</mi></msub><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\beta_jx_j=0</annotation></semantics></math>).</p></li>
<li><p>The model fit is known as a sparse model fit (many zeroes). Hence, choosing a appropriate value for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math> is like choosing the important predictors in the model (feature selection).</p></li>
</ul>
</div>
</div>
<div id="splines-and-the-connection-to-ridge-regression." class="section level1" number="6">
<h1><span class="header-section-number">6</span> Splines and the connection to ridge regression.</h1>
<div id="lidar-dataset" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> Lidar dataset</h2>
<ul>
<li><p>LIDAR (light detection and ranging) uses the reflection of laser-emitted light to detect chemical compounds in the atmosphere.</p></li>
<li><p>The LIDAR technique has proven to be an efficient tool for monitoring the distribution of several atmospheric pollutants of importance; see Sigrist (1994).</p></li>
<li><p>The range is the distance traveled before the light is reflected back to its source.</p></li>
<li><p>The logratio is the logarithm of the ratio of received light from two laser sources.</p>
<ul>
<li><p>One source had a frequency equal to the resonance frequency of the compound of interest, which was mercury in this study.</p></li>
<li><p>The other source had a frequency off this resonance frequency.</p></li>
<li><p>The concentration of mercury can be derived from a regression model of the logratio in function of the range for each range x.</p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;SemiPar&quot;</span>)</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="fu">data</span>(lidar)</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>pLidar <span class="ot">&lt;-</span> lidar <span class="sc">%&gt;%</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> range, <span class="at">y =</span> logratio)) <span class="sc">+</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;range (m)&quot;</span>)</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>pLidar <span class="sc">+</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>  <span class="fu">geom_smooth</span>()</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<ul>
<li>The data is non-linear</li>
<li>Linear regression will not work!</li>
<li>The data shows a smooth relation between the logratio and the range</li>
</ul>
</div>
<div id="basis-expansion" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Basis expansion</h2>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ϵ</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">y_i=f(x_i)+\epsilon_i,</annotation></semantics></math>
with
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>θ</mi><mi>k</mi></msub><msub><mi>b</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x)=\sum\limits_{k=1}^K \theta_k b_k(x)</annotation></semantics></math></p>
<ul>
<li><p>Select set of basis functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b_k(x)</annotation></semantics></math></p></li>
<li><p>Select number of basis functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math></p></li>
<li><p>Examples</p>
<ul>
<li>Polynomial model: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mi>k</mi></msup><annotation encoding="application/x-tex">x^k</annotation></semantics></math></li>
<li>Orthogonal series: Fourier, Legendre polynomials, Wavelets</li>
<li>Polynomial splines: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>m</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">1, x, (x-t_m)_+</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>K</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m=1, \ldots, K-2</annotation></semantics></math> knots <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>m</mi></msub><annotation encoding="application/x-tex">t_m</annotation></semantics></math></li>
<li>…</li>
</ul></li>
</ul>
<div id="trunctated-line-basis" class="section level3" number="6.2.1">
<h3><span class="header-section-number">6.2.1</span> Trunctated line basis</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ϵ</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">y_i=f(x_i)+\epsilon_i,</annotation></semantics></math></p>
<ul>
<li>One of the most simple basis expansions</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>K</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>θ</mi><mi>m</mi></msub><msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>t</mi><mi>m</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">f(x_i)=\beta_0+\beta_1x_i+\sum\limits_{m=1}^{K-2}\theta_m(x_i-t_m)_+</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>.</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo></msub><annotation encoding="application/x-tex">(.)_+</annotation></semantics></math> the operator that takes the positive part.</li>
<li>Note, that better basis expansions exist, which are orthogonal, computational more stable and/or continuous derivative beyond first order</li>
<li>We will use this basis for didactical purposes</li>
<li>We can use OLS to fit y w.r.t. the basis.</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>knots <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">400</span>,<span class="dv">700</span>,<span class="fl">12.5</span>)</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>basis <span class="ot">&lt;-</span> <span class="fu">sapply</span>(knots,</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>  <span class="cf">function</span>(k,y) (y<span class="sc">-</span>k)<span class="sc">*</span>(y<span class="sc">&gt;</span>k),</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>  <span class="at">y=</span> lidar <span class="sc">%&gt;%</span> <span class="fu">pull</span>(range)</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>  )</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>basisExp <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="dv">1</span>, <span class="at">range =</span> lidar <span class="sc">%&gt;%</span> <span class="fu">pull</span>(range), basis)</span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a>splineFitLs <span class="ot">&lt;-</span> <span class="fu">lm</span>(logratio <span class="sc">~</span> <span class="sc">-</span><span class="dv">1</span> <span class="sc">+</span> basisExp, lidar)</span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a>pBasis <span class="ot">&lt;-</span> basisExp[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a>  data.frame <span class="sc">%&gt;%</span></span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a>  <span class="fu">gather</span>(<span class="st">&quot;basis&quot;</span>,<span class="st">&quot;values&quot;</span>,<span class="sc">-</span><span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> range, <span class="at">y =</span> values, <span class="at">color =</span> basis)) <span class="sc">+</span></span>
<span id="cb30-16"><a href="#cb30-16" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb30-17"><a href="#cb30-17" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">&quot;none&quot;</span>) <span class="sc">+</span></span>
<span id="cb30-18"><a href="#cb30-18" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;basis&quot;</span>)</span>
<span id="cb30-19"><a href="#cb30-19" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" tabindex="-1"></a><span class="fu">grid.arrange</span>(</span>
<span id="cb30-21"><a href="#cb30-21" tabindex="-1"></a>  pLidar <span class="sc">+</span></span>
<span id="cb30-22"><a href="#cb30-22" tabindex="-1"></a>    <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> lidar<span class="sc">$</span>range, <span class="at">y =</span> splineFitLs<span class="sc">$</span>fitted), <span class="at">lwd =</span> <span class="dv">2</span>),</span>
<span id="cb30-23"><a href="#cb30-23" tabindex="-1"></a>  pBasis,</span>
<span id="cb30-24"><a href="#cb30-24" tabindex="-1"></a>  <span class="at">ncol=</span><span class="dv">1</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<ul>
<li>Note, that the model is overfitting!</li>
<li>The fit is very wiggly and is tuned too much to the data.</li>
<li>The fit has a large variance and low bias.</li>
<li>It will therefore not generalise well to predict the logratio of future observations.</li>
</ul>
<div id="solution-for-overfitting" class="section level4" number="6.2.1.1">
<h4><span class="header-section-number">6.2.1.1</span> Solution for overfitting?</h4>
<ul>
<li><p>We could perform model selection on the basis to select the important basis functions to model the signal. But, this will have the undesired property that the fit will no longer be smooth.</p></li>
<li><p>We can also adopt a ridge penalty!</p></li>
<li><p>However, we do not want to penalise the intercept and the linear term.</p></li>
<li><p>Ridge criterion</p></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mrow><mi>𝐗</mi><mi>𝛃</mi></mrow><msup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn></msup><mo>+</mo><mi>λ</mi><msup><mi>𝛃</mi><mi>T</mi></msup><mi>𝐃</mi><mi>𝛃</mi></mrow><annotation encoding="application/x-tex">\Vert\mathbf{Y}-\mathbf{X\beta}\Vert^2+\lambda\boldsymbol{\beta}^T\mathbf{D}\boldsymbol{\beta}
</annotation></semantics></math></p>
<p>With <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math> with dimensions (K,K): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mn>𝟎</mn><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mn>𝟎</mn><mrow><mn>2</mn><mo>×</mo><mi>K</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mn>𝟎</mn><mrow><mi>K</mi><mo>−</mo><mn>2</mn><mo>×</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>𝐈</mi><mrow><mi>K</mi><mo>−</mo><mn>2</mn><mo>×</mo><mi>K</mi><mo>−</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{D}=\left[\begin{array}{cc}\mathbf{0}_{2\times2}&amp; \mathbf{0}_{2\times K-2}\\
\mathbf{0}_{K-2\times2}&amp;\mathbf{I}_{K-2\times K-2}\end{array}\right]</annotation></semantics></math></p>
<ul>
<li>Here we will set the penalty at 900.</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>D <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">ncol</span>(basisExp))</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>D[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>lambda <span class="ot">&lt;-</span> <span class="dv">900</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>betaRidge <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(basisExp)<span class="sc">%*%</span>basisExp<span class="sc">+</span>(lambda<span class="sc">*</span>D))<span class="sc">%*%</span><span class="fu">t</span>(basisExp)<span class="sc">%*%</span>lidar<span class="sc">$</span>logratio</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="fu">grid.arrange</span>(</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>  pLidar <span class="sc">+</span></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>    <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> lidar<span class="sc">$</span>range, <span class="at">y =</span> <span class="fu">c</span>(basisExp <span class="sc">%*%</span> betaRidge)), <span class="at">lwd =</span> <span class="dv">2</span>),</span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>  pBasis,</span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a>  <span class="at">ncol=</span><span class="dv">1</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>How do we choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>?</p>
<hr />
</div>
</div>
</div>
</div>
<div id="evaluation-of-prediction-models" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Evaluation of Prediction Models</h1>
<p>Predictions are calculated with the fitted model
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>𝐱</mi><mi>T</mi></msup><mover><mi>β</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">
   \hat{Y}(\mathbf{x}) = \hat{m}(\mathbf{x})=\mathbf{x}^T\hat{\beta}
 </annotation></semantics></math>
when focussing on prediction, we want the prediction error to be as small as possible.</p>
<p>The <strong>prediction error</strong> for a prediction at covariate pattern <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
     \hat{Y}(\mathbf{x}) - Y^*,
  </annotation></semantics></math>
where</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>𝐱</mi><mi>T</mi></msup><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">\hat{Y}(\mathbf{x})=\mathbf{x}^T\hat{\boldsymbol{\beta}}</annotation></semantics></math> is the prediction at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> is an outcome at covariate pattern <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></p></li>
</ul>
<p>Prediction is typically used to predict an outcome before it is observed.</p>
<ul>
<li>Hence, the outcome <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> is not observed yet, and</li>
<li>the prediction error cannot be computed.</li>
</ul>
<hr />
<ul>
<li><p>Recall that the prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{Y}(\mathbf{x})</annotation></semantics></math> is estimated by using data in the training data set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo>,</mo><mi>𝐘</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X},\mathbf{Y})</annotation></semantics></math>, and</p></li>
<li><p>that the outcome <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> is an outcome at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> which is assumed to be independent of the training data.</p></li>
<li><p>Goal is to use prediction model for predicting a future observation (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math>), i.e. an observation that still has to be realised/observed (otherwise prediction seems rather useless).</p></li>
<li><p>Hence, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> can never be part of the training data set.</p></li>
</ul>
<hr />
<p>Here we provide definitions and we show how the prediction performance of a prediction model can be evaluated from data.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒯</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐘</mi><mo>,</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">{\mathcal{T}}=(\mathbf{Y},\mathbf{X})</annotation></semantics></math> denote the training data, from which the prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>⋅</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{Y}(\cdot)</annotation></semantics></math> is build. This building process typically involves feature selection and parameter estimation.</p>
<p>We will use a more general notation for the prediction model: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{x})=\hat{Y}(\mathbf{x})</annotation></semantics></math>.</p>
<hr />
<div id="test-or-generalisation-error" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> Test or Generalisation Error</h2>
<p>The test or generalisation error for prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>⋅</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\cdot)</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>X</mi><mo>*</mo></msup></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>∣</mo><mi>𝒯</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
    \text{Err}_{\mathcal{T}} = \text{E}_{Y^*,X^*}\left[(\hat{m}(\mathbf{X}^*) - Y^*)^2\mid {\mathcal{T}}\right]
  </annotation></semantics></math>
where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>X</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y^*,X^*)</annotation></semantics></math> is independent of the training data.</p>
<hr />
<ul>
<li>Note that the test error is conditional on the training data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">{\mathcal{T}}</annotation></semantics></math>.</li>
<li>Hence, the test error evaluates the performance of the single model build from the observed training data.</li>
<li>This is the ultimate target of the model assessment, because it is exactly this prediction model that will be used in practice and applied to future predictors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐗</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\mathbf{X}^*</annotation></semantics></math> to predict <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math>.</li>
<li>The test error is defined as an average over all such future observations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y^*,\mathbf{X}^*)</annotation></semantics></math>.</li>
</ul>
<hr />
</div>
<div id="conditional-test-error" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> Conditional test error</h2>
<p>Sometimes the conditional test error is used:</p>
<p>The conditional test error in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> for prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{x})</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><msup><mi>Y</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>∣</mo><mi>𝒯</mi><mo>,</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
   \text{Err}_{\mathcal{T}}(\mathbf{x}) = \text{E}_{Y^*}\left[(\hat{m}(\mathbf{x}) - Y^*)^2\mid {\mathcal{T}}, \mathbf{x}\right]
 </annotation></semantics></math>
where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> is an outcome at predictor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>, independent of the training data.</p>
<p>Hence,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><msup><mi>X</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \text{Err}_{\mathcal{T}} = \text{E}_{X^*}\left[\text{Err}_{\mathcal{T}}(\mathbf{X}^*)\right].
 </annotation></semantics></math></p>
<p>A closely related error is the <strong>insample error</strong>.</p>
<hr />
</div>
<div id="insample-error" class="section level2" number="7.3">
<h2><span class="header-section-number">7.3</span> Insample Error</h2>
<p>The insample error for prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{x})</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">Err</mtext><mrow><mtext mathvariant="normal">in</mtext><mi>𝒯</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
   \text{Err}_{\text{in} \mathcal{T}} = \frac{1}{n}\sum_{i=1}^n \text{Err}_{\mathcal{T}}(\mathbf{x}_i),
 </annotation></semantics></math></p>
<p>i.e. the insample error is the sample average of the conditional test errors evaluated in the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> training dataset predictors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐱</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math>.</p>
<p>Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><annotation encoding="application/x-tex">\text{Err}_{\mathcal{T}}</annotation></semantics></math> is an average over all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>, even over those predictors not observed in the training dataset, it is sometimes referred to as the <strong>outsample error</strong>.</p>
<hr />
</div>
<div id="estimation-of-the-insample-error" class="section level2" number="7.4">
<h2><span class="header-section-number">7.4</span> Estimation of the insample error</h2>
<p>We start with introducing the training error rate, which is closely related to the MSE in linear models.</p>
<div id="training-error" class="section level3" number="7.4.1">
<h3><span class="header-section-number">7.4.1</span> Training error</h3>
<p>The training error is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
   \overline{\text{err}} = \frac{1}{n}\sum_{i=1}^n (Y_i - \hat{m}(\mathbf{x}_i))^2 ,
 </annotation></semantics></math>
where the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y_i,\mathbf{x}_i)</annotation></semantics></math> from the training dataset which is also used for the calculation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>m</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{m}</annotation></semantics></math>.</p>
<ul>
<li><p>The training error is an overly optimistic estimate of the test error <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><annotation encoding="application/x-tex">\text{Err}_{\mathcal{T}}</annotation></semantics></math>.</p></li>
<li><p>The training error will never increases when the model becomes more complex. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math> cannot be used directly as a model selection criterion.</p></li>
</ul>
<p>Indeed, model parameters are often estimated by minimising the training error (cfr. SSE).</p>
<ul>
<li>Hence the fitted model adapts to the training data, and</li>
<li>training error will be an overly optimistic estimate of the test error <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><annotation encoding="application/x-tex">\text{Err}_{\mathcal{T}}</annotation></semantics></math>.</li>
</ul>
<hr />
<p>It can be shown that the training error is related to the insample test error via</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">E</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="normal">Err</mtext><mrow><mtext mathvariant="normal">in</mtext><mi>𝒯</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mfrac><mn>2</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mtext mathvariant="normal">cov</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{E}_\mathbf{Y}
\left[\text{Err}_{\text{in}{\mathcal{T}}}\right] = \text{E}_\mathbf{Y}\left[\overline{\text{err}}\right] + \frac{2}{n}\sum_{i=1}^n \text{cov}_\mathbf{Y}\left[\hat{m}(\mathbf{x}_i),Y_i\right],
</annotation></semantics></math></p>
<p>Note, that for linear models
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝐗</mi><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><mi>𝐗</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><msup><mi>𝐗</mi><mi>T</mi></msup><mi>𝐘</mi><mo>=</mo><mrow><mi>𝐇</mi><mi>𝐘</mi></mrow></mrow><annotation encoding="application/x-tex"> \hat{m}(\mathbf{x}_i) = \mathbf{X}\hat{\boldsymbol{\beta}}= \mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{Y} = \mathbf{HY}
</annotation></semantics></math>
with</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐇</mi><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math> the hat matrix and</li>
<li>all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math> are assumed to be independently distributed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mi>𝛃</mi><mo>,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">N(\mathbf{X}\boldsymbol{\beta},\sigma^2)</annotation></semantics></math></li>
</ul>
<p>Hence, for linear models with independent observations</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">cov</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">cov</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>𝐇</mi><mi>i</mi><mi>T</mi></msubsup><mi>𝐘</mi><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">cov</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>h</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>h</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><msub><mtext mathvariant="normal">cov</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>h</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><msup><mi>σ</mi><mn>2</mn></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray}
\text{cov}_\mathbf{Y}\left[\hat{m}(\mathbf{x}_i),Y_i)\right] &amp;=&amp;
\text{cov}_\mathbf{Y}\left[\mathbf{H}_{i}^T\mathbf{Y},Y_i)\right]\\
&amp;=&amp; \text{cov}_\mathbf{Y}\left[h_{ii} Y_i,Y_i\right]\\
&amp;=&amp; h_{ii} \text{cov}_\mathbf{Y}\left[Y_i,Y_i\right]\\
&amp;=&amp; h_{ii} \sigma^2\\
\end{eqnarray}</annotation></semantics></math></p>
<p>And we can thus estimate the insample error by Mallow’s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>p</mi></msub><annotation encoding="application/x-tex">C_p</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>C</mi><mi>p</mi></msub></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mo>+</mo><mfrac><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow><mi>n</mi></mfrac><mtext mathvariant="normal">tr</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐇</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mo>+</mo><mfrac><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup><mi>p</mi></mrow><mi>n</mi></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray}
C_p &amp;=&amp; \overline{\text{err}} + \frac{2\sigma^2}{n}\text{tr}(\mathbf{H})\\
&amp;=&amp; \overline{\text{err}} + \frac{2\sigma^2p}{n}
\end{eqnarray}</annotation></semantics></math></p>
<p>with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> the number of predictors.</p>
<ul>
<li>Mallow’s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>p</mi></msub><annotation encoding="application/x-tex">C_p</annotation></semantics></math> is often used for model selection.</li>
<li>Note, that we can also consider it as a kind of penalized least squares:</li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><msub><mi>C</mi><mi>p</mi></msub><mo>=</mo><mo stretchy="false" form="postfix">‖</mo><mi>𝐘</mi><mo>−</mo><mi>𝐗</mi><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">
n \times C_p = \Vert \mathbf{Y} - \mathbf{X}\boldsymbol{\beta}\Vert_2^2 + 2\sigma^2 \Vert \boldsymbol{\beta} \Vert_0
</annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>0</mn></msub><annotation encoding="application/x-tex">L_0</annotation></semantics></math> norm <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>0</mn></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></msubsup><msubsup><mi>β</mi><mi>p</mi><mn>0</mn></msubsup><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\Vert \boldsymbol{\beta} \Vert_0 = \sum_{j=1}^p \beta_p^0 = p</annotation></semantics></math>.</p>
<hr />
</div>
</div>
<div id="expected-test-error" class="section level2" number="7.5">
<h2><span class="header-section-number">7.5</span> Expected test error</h2>
<p>The test or generalisation error was defined conditionally on the training data. By averaging over the distribution of training datasets, the expected test error arises.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">E</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">E</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="normal">E</mtext><mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>X</mi><mo>*</mo></msup></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>∣</mo><mi>𝒯</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">E</mtext><mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>X</mi><mo>*</mo></msup><mo>,</mo><mi>𝒯</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
   \text{E}_{\mathcal{T}}\left[\text{Err}_{{\mathcal{T}}}\right]
     &amp;=&amp; \text{E}_{\mathcal{T}}\left[\text{E}_{Y^*,X^*}\left[(\hat{m}(\mathbf{X}^*) - Y^*)^2\mid {\mathcal{T}}\right]\right] \\
     &amp;=&amp; \text{E}_{Y^*,X^*,{\mathcal{T}}}\left[(\hat{m}(\mathbf{X}^*) - Y^*)^2\right].
 \end{eqnarray*}</annotation></semantics></math></p>
<ul>
<li><p>The expected test error may not be of direct interest when the goal is to assess the prediction performance of a single prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>⋅</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\cdot)</annotation></semantics></math>.</p></li>
<li><p>The expected test error averages the test errors of all models that can be build from all training datasets, and hence this may be less relevant when the interest is in evaluating one particular model that resulted from a single observed training dataset.</p></li>
<li><p>Also note that building a prediction model involves both parameter estimation and feature selection.</p></li>
<li><p>Hence the expected test error also evaluates the feature selection procedure (on average).</p></li>
<li><p>If the expected test error is small, it is an indication that the model building process gives good predictions for future observations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y^*,\mathbf{X}^*)</annotation></semantics></math> on average.</p></li>
</ul>
<div id="estimating-the-expected-test-error" class="section level3" number="7.5.1">
<h3><span class="header-section-number">7.5.1</span> Estimating the Expected test error</h3>
<p>The expected test error may be estimated by cross validation (CV).</p>
<div id="leave-one-out-cross-validation-loocv" class="section level4" number="7.5.1.1">
<h4><span class="header-section-number">7.5.1.1</span> Leave one out cross validation (LOOCV)}</h4>
<p>The LOOCV estimator of the expected test error (or expected outsample error) is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">CV</mtext><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><mi>i</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
     \text{CV} = \frac{1}{n} \sum_{i=1}^n \left(Y_i - \hat{m}^{-i}(\mathbf{x}_i)\right)^2 ,
  </annotation></semantics></math>
where</p>
<ul>
<li>the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y_i,\mathbf{x}_i)</annotation></semantics></math> form the training dataset</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><mi>i</mi></mrow></msup><annotation encoding="application/x-tex">\hat{m}^{-i}</annotation></semantics></math> is the fitted model based on all training data, except observation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><mi>i</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}^{-i}(\mathbf{x}_i)</annotation></semantics></math> is the prediction at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐱</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math>, which is the observation left out the training data before building model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</li>
</ul>
<p>Some rationale as to why LOOCV offers a good estimator of the outsample error:</p>
<ul>
<li><p>the prediction error <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>−</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y^*-\hat{m}(\mathbf{x})</annotation></semantics></math> is mimicked by not using one of the training outcomes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math> for the estimation of the model so that this <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math> plays the role of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math>, and, consequently, the fitted model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><mi>i</mi></mrow></msup><annotation encoding="application/x-tex">\hat{m}^{-i}</annotation></semantics></math> is independent of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math></p></li>
<li><p>the sum in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">CV</annotation></semantics></math> is over all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐱</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math> in the training dataset, but each term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐱</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{x}_i</annotation></semantics></math> was left out once for the calculation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><mi>i</mi></mrow></msup><annotation encoding="application/x-tex">\hat{m}^{-i}</annotation></semantics></math>. Hence, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><mi>i</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}^{-i}(\mathbf{x}_i)</annotation></semantics></math> mimics an outsample prediction.</p></li>
<li><p>the sum in CV is over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> different training datasets (each one with a different observation removed), and hence CV is an estimator of the <em>expected</em> test error.</p></li>
<li><p>For linear models the LOOCV can be readily obtained from the fitted model: i.e.</p></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">CV</mtext><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msubsup><mi>e</mi><mi>i</mi><mn>2</mn></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\text{CV} = \frac{1}{n}\sum\limits_{i=1}^n \frac{e_i^2}{(1-h_{ii})^2}</annotation></semantics></math></p>
<p>with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>i</mi></msub><annotation encoding="application/x-tex">e_i</annotation></semantics></math> the residuals from the model that is fitted based on all training data.</p>
<hr />
<p>An alternative to LOOCV is the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-fold cross validation procedure. It also gives an estimate of the expected outsample error.</p>
</div>
<div id="k-fold-cross-validation" class="section level4" number="7.5.1.2">
<h4><span class="header-section-number">7.5.1.2</span> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-fold cross validation</h4>
<ul>
<li><p>Randomly divide the training dataset into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> approximately equal subsets . Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>S</mi><mi>j</mi></msub><annotation encoding="application/x-tex">S_j</annotation></semantics></math> denote the index set of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>th subset (referred to as a <strong>fold</strong>). Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>j</mi></msub><annotation encoding="application/x-tex">n_j</annotation></semantics></math> denote the number of observations in fold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.</p></li>
<li><p>The <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-fold cross validation estimator of the expected outsample error is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CV</mtext><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>k</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mfrac><mn>1</mn><msub><mi>n</mi><mi>j</mi></msub></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>S</mi><mi>j</mi></msub></mrow></munder><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>−</mo><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><msub><mi>S</mi><mi>j</mi></msub></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
   \text{CV}_k = \frac{1}{k}\sum_{j=1}^k \frac{1}{n_j} \sum_{i\in S_j} \left(Y_i - \hat{m}^{-S_j}(\mathbf{x}_i)\right)^2
 </annotation></semantics></math>
where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mi>−</mi><msub><mi>S</mi><mi>j</mi></msub></mrow></msup><annotation encoding="application/x-tex">\hat{m}^{-S_j}</annotation></semantics></math> is the model fitted using all training data, except observations in fold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> (i.e. observations <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><msub><mi>S</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">i \in S_j</annotation></semantics></math>).</p></li>
</ul>
<hr />
<p>The cross validation estimators of the expected outsample error are nearly unbiased. One argument that helps to understand where the bias comes from is the fact that e.g. in de LOOCV estimator the model is fit on only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> observations, whereas we are aiming at estimating the outsample error of a model fit on all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> training observations. Fortunately, the bias is often small and is in practice hardly a concern.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-fold CV is computationally more complex.</p>
<p>Since CV and CV<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi></mi><mi>k</mi></msub><annotation encoding="application/x-tex">_k</annotation></semantics></math> are estimators, they also show sampling variability. Standard errors of the CV or CV<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi></mi><mi>k</mi></msub><annotation encoding="application/x-tex">_k</annotation></semantics></math> can be computed. We don’t show the details, but in the example this is illustrated.</p>
</div>
</div>
<div id="bias-variance-trade-off" class="section level3" number="7.5.2">
<h3><span class="header-section-number">7.5.2</span> Bias Variance trade-off</h3>
<p>For the expected conditional test error in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>, it holds that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">E</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">E</mtext><mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><mi>𝒯</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">var</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msub><mtext mathvariant="normal">var</mtext><msup><mi>Y</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
  \text{E}_{\mathcal{T}}\left[\text{Err}_{\mathcal{T}}(\mathbf{x})\right]
    &amp;=&amp; \text{E}_{Y^*,{\mathcal{T}}}\left[(\hat{m}(\mathbf{x})-Y^*)^2 \mid \mathbf{x}\right] \\
    &amp;=&amp;  \text{var}_{\mathbf{Y}}\left[\hat{Y}(\mathbf{x})\mid \mathbf{x}\right] +(\mu(\mathbf{x})-\mu^*(\mathbf{x}))^2+\text{var}_{Y^*}\left[Y^*\mid \mathbf{x}\right]
\end{eqnarray*}</annotation></semantics></math>
where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><mi>𝐘</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><msup><mi>Y</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mu(\mathbf{x}) = \text{E}_{\mathbf{Y}}\left[\hat{Y}(\mathbf{x})\mid \mathbf{x}\right] \text{ and } \mu^*(\mathbf{x})=\text{E}_{Y^*}\left[Y^*\mid \mathbf{x}\right]</annotation></semantics></math>.</p>
<ul>
<li><p><strong>bias</strong>: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">bias</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{bias}(\mathbf{x})=\mu(\mathbf{x})-\mu^*(\mathbf{x})</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">var</mtext><msup><mi>Y</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\text{var}_{Y^*}\left[Y^*\mid \mathbf{x}\right]</annotation></semantics></math> does not depend on the model, and is referred to as the <strong>irreducible variance</strong>.</p></li>
</ul>
<hr />
<p>The importance of the bias-variance trade-off can be seen from a model selection perspective. When we agree that a good model is a model that has a small expected conditional test error at some point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>, then the bias-variance trade-off shows us that a model may be biased as long as it has a small variance to compensate for the bias. It often happens that a biased model has a substantial smaller variance. When these two are combined, a small expected test error may occur.</p>
<p>Also note that the model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> which forms the basis of the prediction model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{x})</annotation></semantics></math> does NOT need to satisfy <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">m(\mathbf{x})=\mu(\mathbf{x})</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">m(\mathbf{x})=\mu^*(\mathbf{x})</annotation></semantics></math>. The model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> is known by the data-analyst (its the basis of the prediction model), whereas <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu(\mathbf{x})</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>μ</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu^*(\mathbf{x})</annotation></semantics></math> are generally unknown to the data-analyst. We only hope that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> serves well as a prediction model.</p>
<hr />
</div>
<div id="in-practice" class="section level3" number="7.5.3">
<h3><span class="header-section-number">7.5.3</span> In practice</h3>
<p>We use cross validation to estimate the lambda penalty for penalised regression:</p>
<ul>
<li>Ridge Regression</li>
<li>Lasso</li>
<li>Build models, e.g. select the number of PCs for PCA regression</li>
<li>Splines</li>
</ul>
</div>
<div id="toxicogenomics-example-2" class="section level3" number="7.5.4">
<h3><span class="header-section-number">7.5.4</span> Toxicogenomics example</h3>
<div id="lasso" class="section level4" number="7.5.4.1">
<h4><span class="header-section-number">7.5.4.1</span> Lasso</h4>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">15</span>)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>mCvLasso <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(</span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>  <span class="at">x =</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>    as.matrix,</span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>  <span class="at">y =</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>    <span class="fu">pull</span>(BA),</span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>)  <span class="co"># lasso alpha=1</span></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a><span class="fu">plot</span>(mCvLasso)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Default CV procedure in is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">k=10</annotation></semantics></math>-fold CV.</p>
<p>The Graphs shows</p>
<ul>
<li>10-fold CV estimates of the extra-sample error as a function of the lasso penalty parameter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</li>
<li>estimate plus and minus once the estimated standard error of the CV estimate (grey bars)</li>
<li>On top the number of non-zero regression parameter estimates are shown.</li>
</ul>
<p>Two vertical reference lines are added to the graph. They correspond to</p>
<ul>
<li>the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log(\lambda)</annotation></semantics></math> that gives the smallest CV estimate of the extra-sample error, and</li>
<li>the largest <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>λ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log(\lambda)</annotation></semantics></math> that gives a CV estimate of the extra-sample error that is within one standard error from the smallest error estimate.</li>
<li>The latter choice of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> has no firm theoretical basis, except that it somehow accounts for the imprecision of the error estimate. One could loosely say that this <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi><annotation encoding="application/x-tex">\gamma</annotation></semantics></math> corresponds to the smallest model (i.e. least number of predictors) that gives an error that is within margin of error of the error of the best model.</li>
</ul>
<hr />
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>mLassoOpt <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  <span class="at">x =</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>    as.matrix,</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>  <span class="at">y =</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>    <span class="fu">pull</span>(BA),</span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>    <span class="at">lambda =</span> mCvLasso<span class="sc">$</span>lambda.min)</span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">coef</span>(mLassoOpt))</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["i"],"name":[1],"type":["int"],"align":["right"]},{"label":["j"],"name":[2],"type":["int"],"align":["right"]},{"label":["x"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"2.135417e-17"},{"1":"7","2":"1","3":"7.723665e-01"},{"1":"105","2":"1","3":"6.745830e-01"},{"1":"147","2":"1","3":"-7.479963e-01"},{"1":"420","2":"1","3":"1.275535e+00"},{"1":"453","2":"1","3":"4.272541e-02"},{"1":"1720","2":"1","3":"-4.548090e-01"},{"1":"1952","2":"1","3":"3.651340e-01"},{"1":"2032","2":"1","3":"4.115143e-16"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>With the optimal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> (smallest error estimate) the output shows the 9 non-zero estimated regression coefficients (sparse solution).</p>
<hr />
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>mLasso1se <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>  <span class="at">x =</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>    as.matrix,</span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>    <span class="at">y=</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>      <span class="fu">pull</span>(BA),</span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>    <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>    <span class="at">lambda =</span> mCvLasso<span class="sc">$</span>lambda<span class="fl">.1</span>se)</span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" tabindex="-1"></a>mLasso1se <span class="sc">%&gt;%</span></span>
<span id="cb34-10"><a href="#cb34-10" tabindex="-1"></a>  coef <span class="sc">%&gt;%</span></span>
<span id="cb34-11"><a href="#cb34-11" tabindex="-1"></a>  summary</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["i"],"name":[1],"type":["int"],"align":["right"]},{"label":["j"],"name":[2],"type":["int"],"align":["right"]},{"label":["x"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"3.608536e-18"},{"1":"7","2":"1","3":"6.255918e-01"},{"1":"147","2":"1","3":"-1.767770e-02"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>This shows the solution for the largest <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> within one standard error of the optimal model. Now only 3 non-zero estimates result.</p>
<hr />
</div>
<div id="ridge" class="section level4" number="7.5.4.2">
<h4><span class="header-section-number">7.5.4.2</span> Ridge</h4>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>mCvRidge <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>  <span class="at">x =</span> toxData[,<span class="sc">-</span><span class="dv">1</span>] <span class="sc">%&gt;%</span></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>    as.matrix,</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>    <span class="at">y =</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>      <span class="fu">pull</span>(BA),</span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a>      <span class="at">alpha =</span> <span class="dv">0</span>)  <span class="co"># ridge alpha=0</span></span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a><span class="fu">plot</span>(mCvRidge)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<ul>
<li>Ridge does not seem to have optimal solution.</li>
<li>10-fold CV is also larger than for lasso.</li>
</ul>
<hr />
</div>
<div id="pca-regression" class="section level4" number="7.5.4.3">
<h4><span class="header-section-number">7.5.4.3</span> PCA regression</h4>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1264</span>)</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="fu">library</span>(DAAG)</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>tox <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a>  <span class="at">Y =</span> toxData <span class="sc">%&gt;%</span></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>    <span class="fu">pull</span>(BA),</span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>  <span class="at">PC =</span> Zk)</span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>PC.seq <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">25</span></span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a>Err <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="dv">25</span>)</span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a>mCvPca <span class="ot">&lt;-</span> <span class="fu">cv.lm</span>(</span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a>  Y<span class="sc">~</span>PC<span class="fl">.1</span>,</span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a>  <span class="at">data =</span> tox,</span>
<span id="cb36-15"><a href="#cb36-15" tabindex="-1"></a>  <span class="at">m =</span> <span class="dv">5</span>,</span>
<span id="cb36-16"><a href="#cb36-16" tabindex="-1"></a>  <span class="at">printit =</span> <span class="cn">FALSE</span>)</span>
<span id="cb36-17"><a href="#cb36-17" tabindex="-1"></a></span>
<span id="cb36-18"><a href="#cb36-18" tabindex="-1"></a>Err[<span class="dv">1</span>]<span class="ot">&lt;-</span><span class="fu">attr</span>(mCvPca,<span class="st">&quot;ms&quot;</span>)</span>
<span id="cb36-19"><a href="#cb36-19" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span><span class="dv">25</span>) {</span>
<span id="cb36-21"><a href="#cb36-21" tabindex="-1"></a>  mCvPca <span class="ot">&lt;-</span> <span class="fu">cv.lm</span>(</span>
<span id="cb36-22"><a href="#cb36-22" tabindex="-1"></a>    <span class="fu">as.formula</span>(</span>
<span id="cb36-23"><a href="#cb36-23" tabindex="-1"></a>      <span class="fu">paste</span>(<span class="st">&quot;Y ~ PC.1 + &quot;</span>,</span>
<span id="cb36-24"><a href="#cb36-24" tabindex="-1"></a>        <span class="fu">paste</span>(<span class="st">&quot;PC.&quot;</span>, <span class="dv">2</span><span class="sc">:</span>i, <span class="at">collapse =</span> <span class="st">&quot;+&quot;</span>, <span class="at">sep=</span><span class="st">&quot;&quot;</span>),</span>
<span id="cb36-25"><a href="#cb36-25" tabindex="-1"></a>        <span class="at">sep=</span><span class="st">&quot;&quot;</span></span>
<span id="cb36-26"><a href="#cb36-26" tabindex="-1"></a>      )</span>
<span id="cb36-27"><a href="#cb36-27" tabindex="-1"></a>    ),</span>
<span id="cb36-28"><a href="#cb36-28" tabindex="-1"></a>    <span class="at">data =</span> tox,</span>
<span id="cb36-29"><a href="#cb36-29" tabindex="-1"></a>    <span class="at">m =</span> <span class="dv">5</span>,</span>
<span id="cb36-30"><a href="#cb36-30" tabindex="-1"></a>    <span class="at">printit =</span> <span class="cn">FALSE</span>)</span>
<span id="cb36-31"><a href="#cb36-31" tabindex="-1"></a>  Err[i]<span class="ot">&lt;-</span><span class="fu">attr</span>(mCvPca,<span class="st">&quot;ms&quot;</span>)</span>
<span id="cb36-32"><a href="#cb36-32" tabindex="-1"></a>}</span></code></pre></div>
<ul>
<li><p>Here we illustrate principal component regression.</p></li>
<li><p>The most important PCs are selected in a forward model selection procedure.</p></li>
<li><p>Within the model selection procedure the models are evaluated with 5-fold CV estimates of the outsample error.</p></li>
<li><p>It is important to realise that a forward model selection procedure will not necessarily result in the best prediction model, particularly because the order of the PCs is generally not related to the importance of the PCs for predicting the outcome.</p></li>
<li><p>A supervised PC would be better.</p></li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>pPCreg <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(PC.seq, Err) <span class="sc">%&gt;%</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> PC.seq, <span class="at">y =</span> Err)) <span class="sc">+</span></span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>  <span class="fu">geom_hline</span>(</span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>    <span class="at">yintercept =</span> <span class="fu">c</span>(</span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a>      mCvLasso<span class="sc">$</span>cvm[mCvLasso<span class="sc">$</span>lambda<span class="sc">==</span>mCvLasso<span class="sc">$</span>lambda.min],</span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a>      mCvLasso<span class="sc">$</span>cvm[mCvLasso<span class="sc">$</span>lambda<span class="sc">==</span>mCvLasso<span class="sc">$</span>lambda<span class="fl">.1</span>se]),</span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>    <span class="at">col =</span> <span class="st">&quot;red&quot;</span>) <span class="sc">+</span></span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a>  <span class="fu">xlim</span>(<span class="dv">1</span>,<span class="dv">26</span>)</span>
<span id="cb37-11"><a href="#cb37-11" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" tabindex="-1"></a><span class="fu">grid.arrange</span>(</span>
<span id="cb37-13"><a href="#cb37-13" tabindex="-1"></a>  pPCreg,</span>
<span id="cb37-14"><a href="#cb37-14" tabindex="-1"></a>  pPCreg <span class="sc">+</span> <span class="fu">ylim</span>(<span class="dv">0</span>,<span class="dv">5</span>),</span>
<span id="cb37-15"><a href="#cb37-15" tabindex="-1"></a>  <span class="at">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<ul>
<li><p>The graph shows the CV estimate of the outsample error as a function of the number of sparse PCs included in the model.</p></li>
<li><p>A very small error is obtained with the model with only the first PC. The best model with 3 PCs.</p></li>
<li><p>The two vertical reference lines correspond to the error estimates obtained with lasso (optimal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> and largest <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> within one standard error).</p></li>
<li><p>Thus although there was a priori no guarantee that the first PCs are the most predictive, it seems to be the case here (we were lucky!).</p></li>
<li><p>Moreover, the first PC resulted in a small outsample error.</p></li>
<li><p>Note that the graph does not indicate the variability of the error estimates (no error bars).</p></li>
<li><p>Also note that the graph clearly illustrates the effect of overfitting: including too many PCs causes a large outsample error.</p></li>
</ul>
</div>
</div>
<div id="lidar-example-splines" class="section level3" number="7.5.5">
<h3><span class="header-section-number">7.5.5</span> Lidar Example: splines</h3>
<ul>
<li>We use the mgcv package to fit the spline model to the lidar data.</li>
<li>A better basis is used than the truncated spline basis</li>
<li>Thin plate splines are also linear smoothers, i.e.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Y</mi><mo accent="true">̂</mo></mover><mo>=</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mi>𝐒</mi><mi>𝐘</mi></mrow></mrow><annotation encoding="application/x-tex">\hat{Y} = \hat{m}(\mathbf{X}) = \mathbf{SY}</annotation></semantics></math></li>
<li>So their variance can be easily calculated.</li>
<li>The ridge/smoothness penalty is chosen by generalized cross validation.</li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>gamfit <span class="ot">&lt;-</span> <span class="fu">gam</span>(logratio <span class="sc">~</span> <span class="fu">s</span>(range), <span class="at">data =</span> lidar)</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>gamfit<span class="sc">$</span>sp</span></code></pre></div>
<pre><code>#&gt;    s(range) 
#&gt; 0.006114634</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>pLidar <span class="sc">+</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> lidar<span class="sc">$</span>range, <span class="at">y =</span> gamfit<span class="sc">$</span>fitted), <span class="at">lwd =</span> <span class="dv">2</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
</div>
</div>
<div id="more-general-error-definitions" class="section level2" number="7.6">
<h2><span class="header-section-number">7.6</span> More general error definitions</h2>
<p>So far we only looked at continuous outcomes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math> and errors defined in terms of the squared loss <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><annotation encoding="application/x-tex">(\hat{m}(\mathbf{x})-Y^*)^2</annotation></semantics></math>.</p>
<p>More generally, a <strong>loss function</strong> measures an discrepancy between the prediction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{x})</annotation></semantics></math> and an independent outcome <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">Y^*</annotation></semantics></math> that corresponds to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>.</p>
<p>Some examples for continuous <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mtext mathvariant="normal">(squared error)</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mo stretchy="false" form="postfix">|</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="false" form="postfix">|</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mtext mathvariant="normal">(absolute error)</mtext></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><mn>2</mn><msub><mo>∫</mo><mi>𝒴</mi></msub><msub><mi>f</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>log</mo><mfrac><mrow><msub><mi>f</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mi>f</mi><mover><mi>m</mi><mo accent="true">̂</mo></mover></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mi>d</mi><mi>y</mi><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mtext mathvariant="normal">(deviance)</mtext><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
  L(Y^*,\hat{m}(\mathbf{x}))
    &amp;=&amp; (\hat{m}(\mathbf{x})-Y^*)^2 \;\;\text{(squared error)} \\
  L(Y^*,\hat{m}(\mathbf{x}))
    &amp;=&amp; \vert\hat{m}(\mathbf{x})-Y^*\vert \;\;\text{(absolute error)} \\
   L(Y^*,\hat{m}(\mathbf{x}))
    &amp;=&amp; 2 \int_{\mathcal{Y}} f_y(y) \log\frac{f_y(y)}{f_{\hat{m}}(y)} dy \;\;\text{(deviance)}.
\end{eqnarray*}</annotation></semantics></math></p>
<p>In the expression of the deviance</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>y</mi></msub><annotation encoding="application/x-tex">f_y</annotation></semantics></math> denotes the density function of a distribution with mean set to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> (cfr. perfect fit), and</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mover><mi>m</mi><mo accent="true">̂</mo></mover></msub><annotation encoding="application/x-tex">f_{\hat{m}}</annotation></semantics></math> is the density function of the same distribution but with mean set to the predicted outcome <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{m}(\mathbf{x})</annotation></semantics></math>.</li>
</ul>
<hr />
<p>With a given loss function, the errors are defined as follows:
- Test or generalisation or outsample error
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">Err</mtext><mi>𝒯</mi></msub><mo>=</mo><msub><mtext mathvariant="normal">E</mtext><mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><msup><mi>X</mi><mo>*</mo></msup></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>,</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
      \text{Err}_{\mathcal{T}} = \text{E}_{Y^*,X^*}\left[L(Y^*,\hat{m}(\mathbf{X}^*))\right]
    </annotation></semantics></math></p>
<ul>
<li><p>Training error
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>L</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mo>,</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
  \overline{\text{err}} = \frac{1}{n}\sum_{i=1}^n L(Y_i,\hat{m}(\mathbf{x}_i))
</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></p></li>
</ul>
<hr />
<p>When an exponential family distribution is assumed for the outcome distribution, and when the deviance loss is used, the insample error can be estimated by means of the AIC and BIC.</p>
<div id="akaikes-information-criterion-aic" class="section level3" number="7.6.1">
<h3><span class="header-section-number">7.6.1</span> Akaike’s Information Criterion (AIC)</h3>
<p>The AIC for a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">AIC</mtext><mo>=</mo><mi>−</mi><mn>2</mn><mo>ln</mo><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">
\text{AIC} = -2 \ln \hat{L}(m) +2p
</annotation></semantics></math>
where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{L}(m)</annotation></semantics></math> is the maximised likelihood for model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<p>When assuming normally distributed error terms and homoscedasticity, the AIC becomes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">AIC</mtext><mo>=</mo><mi>n</mi><mo>ln</mo><mtext mathvariant="normal">SSE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>p</mi><mo>=</mo><mi>n</mi><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>p</mi></mrow><annotation encoding="application/x-tex">
\text{AIC} = n\ln \text{SSE}(m) +2p = n\ln(n\overline{\text{err}}(m)) + 2p
</annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SSE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{SSE}(m)</annotation></semantics></math> the residual sum of squares of model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<p>In linear models with normal error terms, Mallow’s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>p</mi></msub><annotation encoding="application/x-tex">C_p</annotation></semantics></math> criterion (statistic) is a linearised version of AIC and it is an unbiased estimator of the in-sample error.</p>
<hr />
</div>
<div id="bayesian-information-criterion-bic" class="section level3" number="7.6.2">
<h3><span class="header-section-number">7.6.2</span> Bayesian Information Criterion (BIC)}</h3>
<p>The BIC for a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">BIC</mtext><mo>=</mo><mi>−</mi><mn>2</mn><mo>ln</mo><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>p</mi><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{BIC} = -2 \ln \hat{L}(m) +p\ln(n)
</annotation></semantics></math>
where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>L</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{L}(m)</annotation></semantics></math> is the maximised likelihood for model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<p>When assuming normally distributed error terms and homoscedasticity, the BIC becomes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">BIC</mtext><mo>=</mo><mi>n</mi><mo>ln</mo><mtext mathvariant="normal">SSE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>p</mi><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mover><mtext mathvariant="normal">err</mtext><mo accent="true">¯</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>p</mi><mo>ln</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{BIC} = n\ln \text{SSE}(m) +p\ln(n) = n\ln(n\overline{\text{err}}(m)) + p\ln(n)
</annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SSE</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{SSE}(m)</annotation></semantics></math> the residual sum of squares of model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<p>When large datasets are used, the BIC will favour smaller models than the AIC.</p>
<hr />
</div>
</div>
<div id="training-and-test-sets" class="section level2" number="7.7">
<h2><span class="header-section-number">7.7</span> Training and test sets</h2>
<p>Sometimes, when a large (training) dataset is available, one may decide the split the dataset randomly in a</p>
<ul>
<li><p><strong>training dataset</strong>:
data are used for model fitting and for model building or feature selection (this may require e.g. cross validation)</p></li>
<li><p><strong>test dataset</strong>:
this data are used to evaluate the final model (result of model building). An unbiased estimate of the outsample error (i.e. test or generalisation error) based on this test data is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>m</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>Y</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">
   \frac{1}{m} \sum_{i=1}^m \left(\hat{m}(\mathbf{x}_i)-Y_i\right)^2,
</annotation></semantics></math>
where</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>𝐱</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>…</mi><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>m</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>m</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(Y_1,\mathbf{x}_1), \ldots, (Y_m,\mathbf{x}_m)</annotation></semantics></math> denote the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> observations in the test dataset</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>m</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{m}</annotation></semantics></math> is estimated from using the training data (this may also be the result from model building, using only the training data).</p></li>
</ul></li>
</ul>
<hr />
<p>Note that the training dataset is used for model building or feature selection. This also requires the evaluation of models. For these evaluations the methods from the previous slides can be used (e.g. cross validation, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>-fold CV, Mallow’s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>p</mi></msub><annotation encoding="application/x-tex">C_p</annotation></semantics></math>). The test dataset is only used for the evaluation of the final model (estimated and build from using only the training data). The estimate of the outsample error based on the test dataset is the best possible estimate in the sense that it is unbiased. The observations used for this estimation are independent of the observations in the training data.
However, if the number of data points in the test dataset (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>) is small, the estimate of the outsample error may show large variance and hence is not reliable.</p>
</div>
</div>
<div id="logistic-regression-analysis-for-high-dimensional-data" class="section level1" number="8">
<h1><span class="header-section-number">8</span> Logistic Regression Analysis for High Dimensional Data</h1>
<div id="breast-cancer-example" class="section level2" number="8.1">
<h2><span class="header-section-number">8.1</span> Breast Cancer Example</h2>
<ul>
<li><p>Schmidt <em>et al.</em>, 2008, Cancer Research, <strong>68</strong>, 5405-5413</p></li>
<li><p>Gene expression patterns in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">n=200</annotation></semantics></math> breast tumors were investigated (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>22283</mn></mrow><annotation encoding="application/x-tex">p=22283</annotation></semantics></math> genes)</p></li>
<li><p>After surgery the tumors were graded by a pathologist (stage 1,2,3)</p></li>
<li><p>Here the objective is to predict stage 3 from the gene expression data (prediction of binary outcome)</p></li>
<li><p>If the prediction model works well, it can be used to predict the stage from a biopsy sample.</p></li>
</ul>
</div>
<div id="data-1" class="section level2" number="8.2">
<h2><span class="header-section-number">8.2</span> Data</h2>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="co">#BiocManager::install(&quot;genefu&quot;)</span></span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a><span class="co">#BiocManager::install(&quot;breastCancerMAINZ&quot;)</span></span>
<span id="cb41-3"><a href="#cb41-3" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" tabindex="-1"></a><span class="fu">library</span>(genefu)</span>
<span id="cb41-5"><a href="#cb41-5" tabindex="-1"></a><span class="fu">library</span>(breastCancerMAINZ)</span>
<span id="cb41-6"><a href="#cb41-6" tabindex="-1"></a><span class="fu">data</span>(mainz)</span>
<span id="cb41-7"><a href="#cb41-7" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">exprs</span>(mainz)) <span class="co"># gene expressions</span></span>
<span id="cb41-9"><a href="#cb41-9" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X)</span>
<span id="cb41-10"><a href="#cb41-10" tabindex="-1"></a>H <span class="ot">&lt;-</span> <span class="fu">diag</span>(n)<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span>n<span class="sc">*</span><span class="fu">matrix</span>(<span class="dv">1</span>,<span class="at">ncol=</span>n,<span class="at">nrow=</span>n)</span>
<span id="cb41-11"><a href="#cb41-11" tabindex="-1"></a>X <span class="ot">&lt;-</span> H<span class="sc">%*%</span>X</span>
<span id="cb41-12"><a href="#cb41-12" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">pData</span>(mainz)<span class="sc">$</span>grade<span class="sc">==</span><span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb41-13"><a href="#cb41-13" tabindex="-1"></a><span class="fu">table</span>(Y)</span></code></pre></div>
<pre><code>#&gt; Y
#&gt;   0   1 
#&gt; 165  35</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>svdX <span class="ot">&lt;-</span> <span class="fu">svd</span>(X)</span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>Zk <span class="ot">&lt;-</span> svdX<span class="sc">$</span>u[,<span class="dv">1</span><span class="sc">:</span>k] <span class="sc">%*%</span> <span class="fu">diag</span>(svdX<span class="sc">$</span>d[<span class="dv">1</span><span class="sc">:</span>k])</span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a><span class="fu">colnames</span>(Zk) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;Z&quot;</span>,<span class="dv">1</span><span class="sc">:</span>k)</span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a>Zk <span class="sc">%&gt;%</span></span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a>  as.data.frame <span class="sc">%&gt;%</span></span>
<span id="cb43-8"><a href="#cb43-8" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">grade =</span> Y <span class="sc">%&gt;%</span> as.factor) <span class="sc">%&gt;%</span></span>
<span id="cb43-9"><a href="#cb43-9" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x=</span> Z1, <span class="at">y =</span> Z2, <span class="at">color =</span> grade)) <span class="sc">+</span></span>
<span id="cb43-10"><a href="#cb43-10" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<hr />
</div>
<div id="logistic-regression-models" class="section level2" number="8.3">
<h2><span class="header-section-number">8.3</span> Logistic regression models</h2>
<p>Binary outcomes are often analysed with <strong>logistic regression models</strong>.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math> denote the binary (1/0, case/control, positive/negative) outcome, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math> the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>-dimensional predictor.</p>
<p>Logistic regression assumes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>∣</mo><mi>𝐱</mi><mo>∼</mo><mtext mathvariant="normal">Bernoulli</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>π</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
   Y \mid \mathbf{x} \sim \text{Bernoulli}(\pi(\mathbf{x}))
</annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">P</mtext><mrow><mo stretchy="true" form="prefix">[</mo><mi>Y</mi><mo>=</mo><mn>1</mn><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\pi(\mathbf{x}) = \text{P}\left[Y=1\mid \mathbf{x}\right]</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>ln</mo><mfrac><mrow><mi>π</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mn>1</mn><mo>−</mo><mi>π</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msup><mi>𝛃</mi><mi>T</mi></msup><mi>𝐱</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \ln \frac{\pi(\mathbf{x})}{1-\pi(\mathbf{x})}=\beta_0 + \boldsymbol{\beta}^T\mathbf{x}.
</annotation></semantics></math></p>
<p>The parameters are typically estimated by maximising the log-likelihood, which is denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">l(\mathbf{
\beta})</annotation></semantics></math>, i.e.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msub><mtext mathvariant="normal">ArgMax</mtext><mi>β</mi></msub><mi>l</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
   \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}).
</annotation></semantics></math></p>
<ul>
<li><p>Maximum likelihood is only applicable when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n&gt;p</annotation></semantics></math>.</p></li>
<li><p>When <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">p&gt;n</annotation></semantics></math> penalised maximum likelihood methods are applicable.</p></li>
</ul>
<hr />
</div>
<div id="penalized-maximum-likelihood" class="section level2" number="8.4">
<h2><span class="header-section-number">8.4</span> Penalized maximum likelihood</h2>
<p>Penalised estimation methods (e.g. lasso and ridge) can als be applied to maximum likelihood, resulting in the <strong>penalised maximum likelihood estimator</strong>.</p>
<p>Lasso:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msub><mtext mathvariant="normal">ArgMax</mtext><mi>β</mi></msub><mi>l</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>1</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\lambda \Vert \boldsymbol{\beta}\Vert_1.
</annotation></semantics></math></p>
<p>Ridge:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msub><mtext mathvariant="normal">ArgMax</mtext><mi>β</mi></msub><mi>l</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\lambda \Vert \boldsymbol{\beta}\Vert_2^2.
</annotation></semantics></math></p>
<p>Once the parameters are estimated, the model may be used to compute
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mover><mtext mathvariant="normal">P</mtext><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">[</mo><mi>Y</mi><mo>=</mo><mn>1</mn><mo>∣</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \hat{\pi}(\mathbf{x}) = \hat{\text{P}}\left[Y=1\mid \mathbf{x}\right].
</annotation></semantics></math>
With these estimated probabilities the prediction rule becomes
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>≤</mo><mi>c</mi></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">predict </mtext><mspace width="0.333em"></mspace></mrow><mi>Y</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐱</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>&gt;</mo><mi>c</mi></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">predict </mtext><mspace width="0.333em"></mspace></mrow><mi>Y</mi><mo>=</mo><mn>1</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
  \hat{\pi}(\mathbf{x}) &amp;\leq c&amp; \text{predict } Y=0 \\
  \hat{\pi}(\mathbf{x}) &amp;&gt;c &amp; \text{predict } Y=1
\end{eqnarray*}</annotation></semantics></math>
with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>c</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;c&lt;1</annotation></semantics></math> a threshold that either is fixed (e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">c=1/2</annotation></semantics></math>), depends on prior probabilities, or is empirically determined by optimising e.g. the Area Under the ROC Curve (AUC) or by finding a good compromise between sensitivity and specificity.</p>
<p>Note that logistic regression directly models the <strong>Posterior probability</strong> that an observation belongs to class <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Y=1</annotation></semantics></math>, given the predictor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐱</mi><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math>.</p>
</div>
<div id="model-evaluation" class="section level2" number="8.5">
<h2><span class="header-section-number">8.5</span> Model evaluation</h2>
<p>Common model evaluation criteria for binary prediction models are:</p>
<ul>
<li><p>sensitivity = true positive rate (TPR)</p></li>
<li><p>specificity = true negative rate (TNR)</p></li>
<li><p>misclassification error</p></li>
<li><p>area under the ROC curve (AUC)</p></li>
</ul>
<p>These criteria can again be estimated via cross validation or via splitting of the data into training and test/validation data.</p>
<div id="sensitivity-of-a-model-pi-with-threshold-c" class="section level3" number="8.5.1">
<h3><span class="header-section-number">8.5.1</span> Sensitivity of a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> with threshold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math></h3>
<p>Sensitivity is the probability to correctly predict a positive outcome:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">sens</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>π</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">P</mtext><msup><mi>X</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mi>c</mi><mo>∣</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>=</mo><mn>1</mn><mo>∣</mo><mi>𝒯</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{sens}(\pi,c)=\text{P}_{X^*}\left[\hat\pi(\mathbf{X}^*)&gt;c \mid Y^*=1 \mid {\mathcal{T}}\right].
</annotation></semantics></math></p>
<p>It is also known as the true positive rate (TPR).</p>
</div>
<div id="specificity-of-a-model-pi-with-threshold-c" class="section level3" number="8.5.2">
<h3><span class="header-section-number">8.5.2</span> Specificity of a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> with threshold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math></h3>
<p>Specificity is the probability to correctly predict a negative outcome:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">spec</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>π</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mtext mathvariant="normal">P</mtext><msup><mi>X</mi><mo>*</mo></msup></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mi>c</mi><mo>∣</mo><msup><mi>Y</mi><mo>*</mo></msup><mo>=</mo><mn>0</mn><mo>∣</mo><mi>𝒯</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{spec}(\pi,c)=\text{P}_{X^*}\left[\hat\pi(\mathbf{X}^*)\leq c \mid Y^*=0 \mid {\mathcal{T}}\right].
</annotation></semantics></math></p>
<p>It is also known as the true negative rate (TNR).</p>
<hr />
</div>
<div id="misclassification-error-of-a-model-pi-with-threshold-c" class="section level3" number="8.5.3">
<h3><span class="header-section-number">8.5.3</span> Misclassification error of a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> with threshold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math></h3>
<p>The misclassification error is the probability to incorrectly predict an outcome:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">mce</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>π</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mo>=</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mtext mathvariant="normal">P</mtext><mrow><msup><mi>X</mi><mo>*</mo></msup><mo>,</mo><msup><mi>Y</mi><mo>*</mo></msup></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mi>c</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>=</mo><mn>1</mn><mo>∣</mo><mi>𝒯</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="left" style="text-align: left"><mi>+</mi><msub><mtext mathvariant="normal">P</mtext><mrow><msup><mi>X</mi><mo>*</mo></msup><mo>,</mo><msup><mi>Y</mi><mo>*</mo></msup></mrow></msub><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐗</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mi>c</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><msup><mi>Y</mi><mo>*</mo></msup><mo>=</mo><mn>0</mn><mo>∣</mo><mi>𝒯</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{eqnarray*}
\text{mce}(\pi,c) &amp;=&amp;\text{P}_{X^*,Y^*}\left[\hat\pi(\mathbf{X})\leq c \text{ and } Y^*=1 \mid {\mathcal{T}}\right] \\
&amp;  &amp; + \text{P}_{X^*,Y^*}\left[\hat\pi(\mathbf{X})&gt; c \text{ and } Y^*=0 \mid {\mathcal{T}}\right].
\end{eqnarray*}</annotation></semantics></math></p>
<p>Note that in the definitions of sensitivity, specificity and the misclassification error, the probabilities refer to the distribution of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mo>*</mo></msup><mo>,</mo><msup><mi>Y</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{X}^*,Y^*)</annotation></semantics></math>, which is independent of the training data, conditional on the training data. This is in line with the test or generalisation error. The misclassification error is actually the test error when a 0/1 loss function is used. Just as before, the sensitivity, specificity and the misclassification error can also be averaged over the distribution of the training data set, which is in line with the expected test error which has been discussed earlier.</p>
<hr />
</div>
<div id="roc-curve-of-a-model-pi" class="section level3" number="8.5.4">
<h3><span class="header-section-number">8.5.4</span> ROC curve of a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math></h3>
<p>The Receiver Operating Characteristic (ROC) curve for model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is given by the function</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">ROC</mtext><mo>:</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>:</mo><mi>c</mi><mo>↦</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mtext mathvariant="normal">spec</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>π</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mtext mathvariant="normal">sens</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>π</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{ROC}: [0,1] \rightarrow [0,1]\times [0,1]: c \mapsto (1-\text{spec}(\pi,c), \text{sens}(\pi,c)).
</annotation></semantics></math></p>
<p>For when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> moves from 1 to 0, the ROC function defines a curve in the plane <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[0,1]\times [0,1]</annotation></semantics></math>, moving from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c=1</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c=0</annotation></semantics></math>.</p>
<p>The horizontal axis of the ROC curve shows 1-specificity. This is also known as the False Positive Rate (FPR).</p>
<hr />
</div>
<div id="area-under-the-curve-auc-of-a-model-pi" class="section level3" number="8.5.5">
<h3><span class="header-section-number">8.5.5</span> Area under the curve (AUC) of a model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math></h3>
<p>The area under the curve (AUC) for model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> is area under the ROC curve and is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mtext mathvariant="normal">ROC</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>c</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
\int_0^1 \text{ROC}(c) dc.
</annotation></semantics></math></p>
<p>Some notes about the AUC:</p>
<ul>
<li><p>AUC=0.5 results when the ROC curve is the diagonal. This corresponds to flipping a coin, i.e. a complete random prediction.</p></li>
<li><p>AUC=1 results from the perfect ROC curve, which is the ROC curve through the points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math>. This ROC curve includes a threshold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> such that sensitivity and specificity are equal to one.</p></li>
</ul>
</div>
</div>
<div id="breast-cancer-example-1" class="section level2" number="8.6">
<h2><span class="header-section-number">8.6</span> Breast cancer example</h2>
<div id="data-2" class="section level3" number="8.6.1">
<h3><span class="header-section-number">8.6.1</span> Data</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">library</span>(glmnet)</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a><span class="co">#BiocManager::install(&quot;genefu&quot;)</span></span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a><span class="co">#BiocManager::install(&quot;breastCancerMAINZ&quot;)</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a><span class="fu">library</span>(genefu)</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a><span class="fu">library</span>(breastCancerMAINZ)</span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a><span class="fu">data</span>(mainz)</span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">exprs</span>(mainz)) <span class="co"># gene expressions</span></span>
<span id="cb44-11"><a href="#cb44-11" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X)</span>
<span id="cb44-12"><a href="#cb44-12" tabindex="-1"></a>H <span class="ot">&lt;-</span> <span class="fu">diag</span>(n)<span class="sc">-</span><span class="dv">1</span><span class="sc">/</span>n<span class="sc">*</span><span class="fu">matrix</span>(<span class="dv">1</span>,<span class="at">ncol=</span>n,<span class="at">nrow=</span>n)</span>
<span id="cb44-13"><a href="#cb44-13" tabindex="-1"></a>X <span class="ot">&lt;-</span> H<span class="sc">%*%</span>X</span>
<span id="cb44-14"><a href="#cb44-14" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">pData</span>(mainz)<span class="sc">$</span>grade<span class="sc">==</span><span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb44-15"><a href="#cb44-15" tabindex="-1"></a><span class="fu">table</span>(Y)</span></code></pre></div>
<pre><code>#&gt; Y
#&gt;   0   1 
#&gt; 165  35</code></pre>
<hr />
<p>From the table of the outcomes in Y we read that</p>
<ul>
<li>35 tumors were graded as stage 3 and</li>
<li>165 tumors were graded as stage 1 or 2.</li>
</ul>
<p>In this the stage 3 tumors are referred to as cases or postives and the stage 1 and 2 tumors as controls or negatives.</p>
<hr />
</div>
<div id="training-and-test-dataset" class="section level3" number="8.6.2">
<h3><span class="header-section-number">8.6.2</span> Training and test dataset</h3>
<p>The use of the lasso logistic regression for the prediction of stage 3 breast cancer is illustrated here by</p>
<ul>
<li><p>randomly splitting the dataset into a training dataset (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>80</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">80\%</annotation></semantics></math> of data = 160 tumors) and a test dataset (40 tumors)</p></li>
<li><p>using the training data to select a good <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> value in the lasso logistic regression model (through 10-fold CV)</p></li>
<li><p>evaluating the final model by means of the test dataset (ROC Curve, AUC).</p></li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="do">## Used to provide same results as in previous R version</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="fu">RNGkind</span>(<span class="at">sample.kind =</span> <span class="st">&quot;Rounding&quot;</span>)</span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">6977326</span>)</span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a><span class="do">####</span></span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X)</span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a>nTrain <span class="ot">&lt;-</span> <span class="fu">round</span>(<span class="fl">0.8</span><span class="sc">*</span>n)</span>
<span id="cb46-8"><a href="#cb46-8" tabindex="-1"></a>nTrain</span></code></pre></div>
<pre><code>#&gt; [1] 160</code></pre>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>indTrain <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>n,nTrain)</span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>XTrain <span class="ot">&lt;-</span> X[indTrain,]</span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a>YTrain <span class="ot">&lt;-</span> Y[indTrain]</span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a>XTest <span class="ot">&lt;-</span> X[<span class="sc">-</span>indTrain,]</span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a>YTest <span class="ot">&lt;-</span> Y[<span class="sc">-</span>indTrain]</span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a><span class="fu">table</span>(YTest)</span></code></pre></div>
<pre><code>#&gt; YTest
#&gt;  0  1 
#&gt; 32  8</code></pre>
<p>Note that the randomly selected test data has 20% cases of stage 3 tumors.
This is a bit higher than the 17.5% in the complete data.</p>
<p>One could also perform the random splitting among the positives and the negatives separately (stratified splitting).</p>
</div>
<div id="model-fitting-based-on-training-data" class="section level3" number="8.6.3">
<h3><span class="header-section-number">8.6.3</span> Model fitting based on training data</h3>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a>mLasso <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>  <span class="at">x =</span> XTrain,</span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a>  <span class="at">family=</span><span class="st">&quot;binomial&quot;</span>)  <span class="co"># lasso: alpha = 1</span></span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a><span class="fu">plot</span>(mLasso, <span class="at">xvar =</span> <span class="st">&quot;lambda&quot;</span>, <span class="at">xlim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">6</span>,<span class="sc">-</span><span class="fl">1.5</span>))</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<hr />
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a>mCvLasso <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(</span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a>  <span class="at">x =</span> XTrain,</span>
<span id="cb51-3"><a href="#cb51-3" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb51-4"><a href="#cb51-4" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb51-5"><a href="#cb51-5" tabindex="-1"></a>  <span class="at">type.measure =</span> <span class="st">&quot;class&quot;</span>,</span>
<span id="cb51-6"><a href="#cb51-6" tabindex="-1"></a>    <span class="at">family =</span> <span class="st">&quot;binomial&quot;</span>)  <span class="co"># lasso alpha = 1</span></span>
<span id="cb51-7"><a href="#cb51-7" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" tabindex="-1"></a><span class="fu">plot</span>(mCvLasso)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a>mCvLasso</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Call:  cv.glmnet(x = XTrain, y = YTrain, type.measure = &quot;class&quot;, alpha = 1,      family = &quot;binomial&quot;) 
#&gt; 
#&gt; Measure: Misclassification Error 
#&gt; 
#&gt;     Lambda Index Measure      SE Nonzero
#&gt; min 0.1044    14  0.1437 0.03366      18
#&gt; 1se 0.1911     1  0.1688 0.03492       0</code></pre>
<p>The total misclassification error is used here to select a good value for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="co"># BiocManager::install(&quot;plotROC&quot;)</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="fu">library</span>(plotROC)</span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a>dfLassoOpt <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a>  <span class="at">pi =</span> <span class="fu">predict</span>(mCvLasso,</span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>    <span class="at">newx =</span> XTest,</span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a>    <span class="at">s =</span> mCvLasso<span class="sc">$</span>lambda.min,</span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">&quot;response&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">c</span>(.),</span>
<span id="cb54-9"><a href="#cb54-9" tabindex="-1"></a>  <span class="at">known.truth =</span> YTest)</span>
<span id="cb54-10"><a href="#cb54-10" tabindex="-1"></a></span>
<span id="cb54-11"><a href="#cb54-11" tabindex="-1"></a>roc <span class="ot">&lt;-</span></span>
<span id="cb54-12"><a href="#cb54-12" tabindex="-1"></a>  dfLassoOpt  <span class="sc">%&gt;%</span></span>
<span id="cb54-13"><a href="#cb54-13" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">d =</span> known.truth, <span class="at">m =</span> pi)) <span class="sc">+</span></span>
<span id="cb54-14"><a href="#cb54-14" tabindex="-1"></a>  <span class="fu">geom_roc</span>(<span class="at">n.cuts =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb54-15"><a href="#cb54-15" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;1-specificity (FPR)&quot;</span>) <span class="sc">+</span></span>
<span id="cb54-16"><a href="#cb54-16" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;sensitivity (TPR)&quot;</span>)</span>
<span id="cb54-17"><a href="#cb54-17" tabindex="-1"></a></span>
<span id="cb54-18"><a href="#cb54-18" tabindex="-1"></a>roc</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-36-1.png" width="672" /></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="fu">calc_auc</span>(roc)</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["PANEL"],"name":[1],"type":["fct"],"align":["left"]},{"label":["group"],"name":[2],"type":["int"],"align":["right"]},{"label":["AUC"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"-1","3":"0.8320312","_rn_":"1"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ul>
<li><p>The ROC curve is shown for the model based on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> with the smallest misclassification error. The model has an AUC of 0.83.</p></li>
<li><p>Based on this ROC curve an appropriate threshold <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> can be chosen. For example, from the ROC curve we see that it is possible to attain a specificity and a sensitivity of 75%.</p></li>
<li><p>The sensitivities and specificities in the ROC curve are unbiased (independent test dataset) for the prediction model build from the training data. The estimates of sensitivity and specificity, however, are based on only 40 observations.</p></li>
</ul>
<hr />
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a>mLambdaOpt <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(<span class="at">x =</span> XTrain,</span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a>  <span class="at">lambda =</span> mCvLasso<span class="sc">$</span>lambda.min,</span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a>  <span class="at">family=</span><span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a><span class="fu">qplot</span>(</span>
<span id="cb56-8"><a href="#cb56-8" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="fu">coef</span>(mLambdaOpt))[<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb56-9"><a href="#cb56-9" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="fu">coef</span>(mLambdaOpt))[<span class="sc">-</span><span class="dv">1</span>,<span class="dv">3</span>]) <span class="sc">+</span></span>
<span id="cb56-10"><a href="#cb56-10" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;gene ID&quot;</span>) <span class="sc">+</span></span>
<span id="cb56-11"><a href="#cb56-11" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;beta-hat&quot;</span>) <span class="sc">+</span></span>
<span id="cb56-12"><a href="#cb56-12" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="dv">0</span>, <span class="at">color =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<ul>
<li>The model with the optimal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> has only 19 non-zero parameter estimates.</li>
<li>Thus only 19 genes are involved in the prediction model.</li>
<li>These 19 parameter estimates are plotting in the graph.
A listing of the model output would show the names of the genes.</li>
</ul>
<hr />
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a>dfLasso1se <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>  <span class="at">pi =</span> <span class="fu">predict</span>(mCvLasso,</span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a>    <span class="at">newx =</span> XTest,</span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a>    <span class="at">s =</span> mCvLasso<span class="sc">$</span>lambda<span class="fl">.1</span>se,</span>
<span id="cb57-5"><a href="#cb57-5" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">&quot;response&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">c</span>(.),</span>
<span id="cb57-6"><a href="#cb57-6" tabindex="-1"></a>  <span class="at">known.truth =</span> YTest)</span>
<span id="cb57-7"><a href="#cb57-7" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" tabindex="-1"></a>roc <span class="ot">&lt;-</span></span>
<span id="cb57-9"><a href="#cb57-9" tabindex="-1"></a>  <span class="fu">rbind</span>(</span>
<span id="cb57-10"><a href="#cb57-10" tabindex="-1"></a>    dfLassoOpt <span class="sc">%&gt;%</span></span>
<span id="cb57-11"><a href="#cb57-11" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">method =</span> <span class="st">&quot;min&quot;</span>),</span>
<span id="cb57-12"><a href="#cb57-12" tabindex="-1"></a>    dfLasso1se <span class="sc">%&gt;%</span></span>
<span id="cb57-13"><a href="#cb57-13" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">method =</span> <span class="st">&quot;1se&quot;</span>)</span>
<span id="cb57-14"><a href="#cb57-14" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb57-15"><a href="#cb57-15" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">d =</span> known.truth, <span class="at">m =</span> pi, <span class="at">color =</span> method)) <span class="sc">+</span></span>
<span id="cb57-16"><a href="#cb57-16" tabindex="-1"></a>  <span class="fu">geom_roc</span>(<span class="at">n.cuts =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb57-17"><a href="#cb57-17" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;1-specificity (FPR)&quot;</span>) <span class="sc">+</span></span>
<span id="cb57-18"><a href="#cb57-18" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;sensitivity (TPR)&quot;</span>)</span>
<span id="cb57-19"><a href="#cb57-19" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" tabindex="-1"></a>roc</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-38-1.png" width="672" /></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">calc_auc</span>(roc)</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["PANEL"],"name":[1],"type":["fct"],"align":["left"]},{"label":["group"],"name":[2],"type":["int"],"align":["right"]},{"label":["method"],"name":[3],"type":["chr"],"align":["left"]},{"label":["AUC"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"1se","4":"0.5000000","_rn_":"1"},{"1":"1","2":"2","3":"min","4":"0.8320312","_rn_":"2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ul>
<li><p>When using the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> of the optimal model up to 1 standard deviation, a diagonal ROC curve is obtained and hence AUC is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.5</mn><annotation encoding="application/x-tex">0.5</annotation></semantics></math>.</p></li>
<li><p>This prediction model is thus equivalent to flipping a coin for making the prediction.</p></li>
<li><p>The reason is that with this choice of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> (strong penalisation) almost all predictors are removed from the model.</p></li>
<li><p>Therefore, do never blindly choose for the ``optimal’’ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> as defined here, but assess the performance of the model first.</p></li>
</ul>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a>mLambda1se <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(<span class="at">x =</span> XTrain,</span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="dv">1</span>,</span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>  <span class="at">lambda =</span> mCvLasso<span class="sc">$</span>lambda<span class="fl">.1</span>se,</span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>  <span class="at">family=</span><span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>mLambda1se <span class="sc">%&gt;%</span></span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>  coef <span class="sc">%&gt;%</span></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a>  summary</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["i"],"name":[1],"type":["int"],"align":["right"]},{"label":["j"],"name":[2],"type":["int"],"align":["right"]},{"label":["x"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"-1.594512"},{"1":"2","2":"1","3":"0.000000"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<hr />
</div>
</div>
<div id="the-elastic-net" class="section level2" number="8.7">
<h2><span class="header-section-number">8.7</span> The Elastic Net</h2>
<p>The lasso and ridge regression have positive and negative properties.</p>
<ul>
<li><p>Lasso</p>
<ul>
<li><p>positive: sparse solution</p></li>
<li><p>negative: at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\min(n,p)</annotation></semantics></math> predictors can be selected</p></li>
<li><p>negative: tend to select one predictor among a group of highly correlated predictors</p></li>
</ul></li>
<li><p>Ridge</p>
<ul>
<li>negative: no sparse solution</li>
<li>positive: more than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\min(n,p)</annotation></semantics></math> predictors can be selected</li>
</ul></li>
</ul>
<p>A compromise between lasso and ridge: the <strong>elastic net</strong>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msub><mtext mathvariant="normal">ArgMax</mtext><mi>β</mi></msub><mi>l</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>γ</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>1</mn></msub><mo>−</mo><msub><mi>γ</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\gamma_1 \Vert \boldsymbol\beta\Vert_1 -\gamma_2 \Vert \boldsymbol\beta\Vert_2^2.
</annotation></semantics></math></p>
<p>The elastic gives a sparse solution with potentially more than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\min(n,p)</annotation></semantics></math> predictors.</p>
<hr />
<p>The <code>glmnet</code> R function uses the following parameterisation,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝛃</mi><mo accent="true">̂</mo></mover><mo>=</mo><msub><mtext mathvariant="normal">ArgMax</mtext><mi>β</mi></msub><mi>l</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝛃</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>λ</mi><mi>α</mi><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msub><mo stretchy="false" form="postfix">‖</mo><mn>1</mn></msub><mo>−</mo><mi>λ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">‖</mo><mi>𝛃</mi><msubsup><mo stretchy="false" form="postfix">‖</mo><mn>2</mn><mn>2</mn></msubsup><mi>.</mi></mrow><annotation encoding="application/x-tex">
  \hat{\boldsymbol{\beta}} = \text{ArgMax}_\beta l(\boldsymbol{\beta}) -\lambda\alpha \Vert \boldsymbol\beta\Vert_1 -\lambda(1-\alpha) \Vert \boldsymbol\beta\Vert_2^2.
</annotation></semantics></math></p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> parameter gives weight to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math> penalty term (hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha=1</annotation></semantics></math> gives the lasso, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\alpha=0</annotation></semantics></math> gives ridge).</p></li>
<li><p>a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> parameter to give weight to the penalisation</p></li>
<li><p>Note that the combination of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math> gives the same flexibility as the combination of the parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\lambda_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">\lambda_2</annotation></semantics></math>.</p></li>
</ul>
<hr />
<div id="breast-cancer-example-2" class="section level3" number="8.7.1">
<h3><span class="header-section-number">8.7.1</span> Breast cancer example</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>mElastic <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(</span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>  <span class="at">x =</span> XTrain,</span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fl">0.5</span>,</span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>  <span class="at">family=</span><span class="st">&quot;binomial&quot;</span>)  <span class="co"># elastic net</span></span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" tabindex="-1"></a><span class="fu">plot</span>(mElastic, <span class="at">xvar =</span> <span class="st">&quot;lambda&quot;</span>,<span class="at">xlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">5.5</span>,<span class="sc">-</span><span class="dv">1</span>))</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-40-1.png" width="672" /></p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a>mCvElastic <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(<span class="at">x =</span> XTrain,</span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fl">0.5</span>,</span>
<span id="cb61-4"><a href="#cb61-4" tabindex="-1"></a>  <span class="at">family =</span> <span class="st">&quot;binomial&quot;</span>,</span>
<span id="cb61-5"><a href="#cb61-5" tabindex="-1"></a>    <span class="at">type.measure =</span> <span class="st">&quot;class&quot;</span>)  <span class="co"># elastic net</span></span>
<span id="cb61-6"><a href="#cb61-6" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" tabindex="-1"></a><span class="fu">plot</span>(mCvElastic)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-41-1.png" width="672" /></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a>mCvElastic</span></code></pre></div>
<pre><code>#&gt; 
#&gt; Call:  cv.glmnet(x = XTrain, y = YTrain, type.measure = &quot;class&quot;, alpha = 0.5,      family = &quot;binomial&quot;) 
#&gt; 
#&gt; Measure: Misclassification Error 
#&gt; 
#&gt;      Lambda Index Measure      SE Nonzero
#&gt; min 0.01859    66  0.1313 0.02708     148
#&gt; 1se 0.21876    13  0.1562 0.03391      26</code></pre>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a>dfElast <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>  <span class="at">pi =</span> <span class="fu">predict</span>(mElastic,</span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a>    <span class="at">newx =</span> XTest,</span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>    <span class="at">s =</span> mCvElastic<span class="sc">$</span>lambda.min,</span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">&quot;response&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">c</span>(.),</span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a>  <span class="at">known.truth =</span> YTest)</span>
<span id="cb64-7"><a href="#cb64-7" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" tabindex="-1"></a>roc <span class="ot">&lt;-</span> <span class="fu">rbind</span>(</span>
<span id="cb64-9"><a href="#cb64-9" tabindex="-1"></a>  dfLassoOpt <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">method =</span> <span class="st">&quot;lasso&quot;</span>),</span>
<span id="cb64-10"><a href="#cb64-10" tabindex="-1"></a>  dfElast <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">method =</span> <span class="st">&quot;elast. net&quot;</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb64-11"><a href="#cb64-11" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">d =</span> known.truth, <span class="at">m =</span> pi, <span class="at">color =</span> method)) <span class="sc">+</span></span>
<span id="cb64-12"><a href="#cb64-12" tabindex="-1"></a>  <span class="fu">geom_roc</span>(<span class="at">n.cuts =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb64-13"><a href="#cb64-13" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;1-specificity (FPR)&quot;</span>) <span class="sc">+</span></span>
<span id="cb64-14"><a href="#cb64-14" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;sensitivity (TPR)&quot;</span>)</span>
<span id="cb64-15"><a href="#cb64-15" tabindex="-1"></a></span>
<span id="cb64-16"><a href="#cb64-16" tabindex="-1"></a>roc</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-42-1.png" width="672" /></p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a><span class="fu">calc_auc</span>(roc)</span></code></pre></div>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["PANEL"],"name":[1],"type":["fct"],"align":["left"]},{"label":["group"],"name":[2],"type":["int"],"align":["right"]},{"label":["method"],"name":[3],"type":["chr"],"align":["left"]},{"label":["AUC"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"1","2":"1","3":"elast. net","4":"0.8398438","_rn_":"1"},{"1":"1","2":"2","3":"lasso","4":"0.8320312","_rn_":"2"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<ul>
<li>More parameters are used than for the lasso, but the performance does not improve.</li>
</ul>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a>mElasticOpt <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(<span class="at">x =</span> XTrain,</span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>  <span class="at">y =</span> YTrain,</span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fl">0.5</span>,</span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a>  <span class="at">lambda =</span> mCvElastic<span class="sc">$</span>lambda.min,</span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a>  <span class="at">family=</span><span class="st">&quot;binomial&quot;</span>)</span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a></span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a><span class="fu">qplot</span>(</span>
<span id="cb66-8"><a href="#cb66-8" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="fu">coef</span>(mElasticOpt))[<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>],</span>
<span id="cb66-9"><a href="#cb66-9" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="fu">coef</span>(mElasticOpt))[<span class="sc">-</span><span class="dv">1</span>,<span class="dv">3</span>]) <span class="sc">+</span></span>
<span id="cb66-10"><a href="#cb66-10" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">&quot;gene ID&quot;</span>) <span class="sc">+</span></span>
<span id="cb66-11"><a href="#cb66-11" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">&quot;beta-hat&quot;</span>) <span class="sc">+</span></span>
<span id="cb66-12"><a href="#cb66-12" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="dv">0</span>, <span class="at">color =</span> <span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="prediction_files/figure-html/unnamed-chunk-43-1.png" width="672" /></p>
</div>
</div>
</div>
<div id="acknowledgement" class="section level1 unnumbered">
<h1>Acknowledgement</h1>
<ul>
<li>Olivier Thas for sharing his materials of Analysis of High Dimensional Data 2019-2020, which I used as the starting point for this chapter.</li>
</ul>
</div>
<div id="session-info" class="section level1 unnumbered">
<h1>Session info</h1>
<details>
<summary>
Session info
</summary>
<pre><code>#&gt; [1] &quot;2025-10-20 15:42:49 CEST&quot;</code></pre>
<pre><code>#&gt; ─ Session info ───────────────────────────────────────────────────────────────
#&gt;  setting  value
#&gt;  version  R version 4.4.0 RC (2024-04-16 r86468)
#&gt;  os       macOS 15.6
#&gt;  system   aarch64, darwin20
#&gt;  ui       X11
#&gt;  language (EN)
#&gt;  collate  en_US.UTF-8
#&gt;  ctype    en_US.UTF-8
#&gt;  tz       Europe/Brussels
#&gt;  date     2025-10-20
#&gt;  pandoc   3.4 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64/ (via rmarkdown)
#&gt; 
#&gt; ─ Packages ───────────────────────────────────────────────────────────────────
#&gt;  package           * version    date (UTC) lib source
#&gt;  AIMS              * 1.36.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  AnnotationDbi       1.66.0     2024-05-01 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  Biobase           * 2.64.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  BiocFileCache       2.12.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  BiocGenerics      * 0.54.0     2025-04-15 [1] Bioconductor 3.21 (R 4.4.0)
#&gt;  biomaRt           * 2.60.1     2024-06-26 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  Biostrings          2.72.1     2024-06-02 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  bit                 4.5.0      2024-09-20 [1] CRAN (R 4.4.1)
#&gt;  bit64               4.5.2      2024-09-22 [1] CRAN (R 4.4.1)
#&gt;  blob                1.2.4      2023-03-17 [1] CRAN (R 4.4.0)
#&gt;  bookdown            0.40       2024-07-02 [1] CRAN (R 4.4.0)
#&gt;  bootstrap           2019.6     2019-06-17 [1] CRAN (R 4.4.0)
#&gt;  breastCancerMAINZ * 1.42.0     2024-05-02 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  bslib               0.8.0      2024-07-29 [1] CRAN (R 4.4.0)
#&gt;  cachem              1.1.0      2024-05-16 [1] CRAN (R 4.4.0)
#&gt;  class               7.3-22     2023-05-03 [1] CRAN (R 4.4.0)
#&gt;  cli                 3.6.3      2024-06-21 [1] CRAN (R 4.4.0)
#&gt;  cluster             2.1.6      2023-12-01 [1] CRAN (R 4.4.0)
#&gt;  codetools           0.2-20     2024-03-31 [1] CRAN (R 4.4.0)
#&gt;  colorspace          2.1-1      2024-07-26 [1] CRAN (R 4.4.0)
#&gt;  crayon              1.5.3      2024-06-20 [1] CRAN (R 4.4.0)
#&gt;  curl                5.2.3      2024-09-20 [1] CRAN (R 4.4.1)
#&gt;  DAAG              * 1.25.6     2024-05-26 [1] CRAN (R 4.4.0)
#&gt;  data.table          1.17.6     2025-06-17 [1] CRAN (R 4.4.1)
#&gt;  DBI                 1.2.3      2024-06-02 [1] CRAN (R 4.4.0)
#&gt;  dbplyr              2.5.0      2024-03-19 [1] CRAN (R 4.4.0)
#&gt;  deldir              2.0-4      2024-02-28 [1] CRAN (R 4.4.0)
#&gt;  digest              0.6.37     2024-08-19 [1] CRAN (R 4.4.1)
#&gt;  dplyr             * 1.1.4      2023-11-17 [1] CRAN (R 4.4.0)
#&gt;  e1071             * 1.7-16     2024-09-16 [1] CRAN (R 4.4.1)
#&gt;  evaluate            1.0.0      2024-09-17 [1] CRAN (R 4.4.1)
#&gt;  fansi               1.0.6      2023-12-08 [1] CRAN (R 4.4.0)
#&gt;  farver              2.1.2      2024-05-13 [1] CRAN (R 4.4.0)
#&gt;  fastmap             1.2.0      2024-05-15 [1] CRAN (R 4.4.0)
#&gt;  filelock            1.0.3      2023-12-11 [1] CRAN (R 4.4.0)
#&gt;  forcats           * 1.0.0      2023-01-29 [1] CRAN (R 4.4.0)
#&gt;  foreach             1.5.2      2022-02-02 [1] CRAN (R 4.4.0)
#&gt;  future              1.34.0     2024-07-29 [1] CRAN (R 4.4.0)
#&gt;  future.apply        1.11.2     2024-03-28 [1] CRAN (R 4.4.0)
#&gt;  genefu            * 2.36.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  generics          * 0.1.3      2022-07-05 [1] CRAN (R 4.4.0)
#&gt;  GenomeInfoDb        1.40.1     2024-06-16 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  GenomeInfoDbData    1.2.12     2024-04-24 [1] Bioconductor
#&gt;  ggforce           * 0.4.2      2024-02-19 [1] CRAN (R 4.4.0)
#&gt;  ggplot2           * 3.5.1      2024-04-23 [1] CRAN (R 4.4.0)
#&gt;  glmnet            * 4.1-8      2023-08-22 [1] CRAN (R 4.4.0)
#&gt;  globals             0.16.3     2024-03-08 [1] CRAN (R 4.4.0)
#&gt;  glue                1.8.0      2024-09-30 [1] CRAN (R 4.4.1)
#&gt;  gridExtra         * 2.3        2017-09-09 [1] CRAN (R 4.4.0)
#&gt;  gtable              0.3.5      2024-04-22 [1] CRAN (R 4.4.0)
#&gt;  highr               0.11       2024-05-26 [1] CRAN (R 4.4.0)
#&gt;  hms                 1.1.3      2023-03-21 [1] CRAN (R 4.4.0)
#&gt;  htmltools           0.5.8.1    2024-04-04 [1] CRAN (R 4.4.0)
#&gt;  httr                1.4.7      2023-08-15 [1] CRAN (R 4.4.0)
#&gt;  httr2               1.0.5      2024-09-26 [1] CRAN (R 4.4.1)
#&gt;  iC10              * 2.0.2      2024-07-19 [1] CRAN (R 4.4.0)
#&gt;  iC10TrainingData    2.0.1      2024-07-16 [1] CRAN (R 4.4.0)
#&gt;  impute              1.78.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  interp              1.1-6      2024-01-26 [1] CRAN (R 4.4.0)
#&gt;  IRanges             2.38.1     2024-07-03 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  iterators           1.0.14     2022-02-05 [1] CRAN (R 4.4.0)
#&gt;  jpeg                0.1-10     2022-11-29 [1] CRAN (R 4.4.0)
#&gt;  jquerylib           0.1.4      2021-04-26 [1] CRAN (R 4.4.0)
#&gt;  jsonlite            1.8.9      2024-09-20 [1] CRAN (R 4.4.1)
#&gt;  KEGGREST            1.44.1     2024-06-19 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  KernSmooth          2.23-24    2024-05-17 [1] CRAN (R 4.4.0)
#&gt;  knitr               1.48       2024-07-07 [1] CRAN (R 4.4.0)
#&gt;  labeling            0.4.3      2023-08-29 [1] CRAN (R 4.4.0)
#&gt;  latex2exp         * 0.9.6      2022-11-28 [1] CRAN (R 4.4.0)
#&gt;  lattice             0.22-6     2024-03-20 [1] CRAN (R 4.4.0)
#&gt;  latticeExtra        0.6-30     2022-07-04 [1] CRAN (R 4.4.0)
#&gt;  lava                1.8.0      2024-03-05 [1] CRAN (R 4.4.0)
#&gt;  lifecycle           1.0.4      2023-11-07 [1] CRAN (R 4.4.0)
#&gt;  limma               3.60.6     2024-10-02 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  listenv             0.9.1      2024-01-29 [1] CRAN (R 4.4.0)
#&gt;  lubridate         * 1.9.3      2023-09-27 [1] CRAN (R 4.4.0)
#&gt;  magrittr            2.0.3      2022-03-30 [1] CRAN (R 4.4.0)
#&gt;  MASS                7.3-61     2024-06-13 [1] CRAN (R 4.4.0)
#&gt;  Matrix            * 1.7-0      2024-03-22 [1] CRAN (R 4.4.0)
#&gt;  mclust              6.1.1      2024-04-29 [1] CRAN (R 4.4.0)
#&gt;  memoise             2.0.1      2021-11-26 [1] CRAN (R 4.4.0)
#&gt;  mgcv              * 1.9-1      2023-12-21 [1] CRAN (R 4.4.0)
#&gt;  munsell             0.5.1      2024-04-01 [1] CRAN (R 4.4.0)
#&gt;  nlme              * 3.1-166    2024-08-14 [1] CRAN (R 4.4.0)
#&gt;  pamr                1.57       2024-07-01 [1] CRAN (R 4.4.0)
#&gt;  parallelly          1.38.0     2024-07-27 [1] CRAN (R 4.4.0)
#&gt;  pillar              1.9.0      2023-03-22 [1] CRAN (R 4.4.0)
#&gt;  pkgconfig           2.0.3      2019-09-22 [1] CRAN (R 4.4.0)
#&gt;  plotROC           * 2.3.1      2023-10-06 [1] CRAN (R 4.4.0)
#&gt;  plyr                1.8.9      2023-10-02 [1] CRAN (R 4.4.0)
#&gt;  png                 0.1-8      2022-11-29 [1] CRAN (R 4.4.0)
#&gt;  polyclip            1.10-7     2024-07-23 [1] CRAN (R 4.4.0)
#&gt;  prettyunits         1.2.0      2023-09-24 [1] CRAN (R 4.4.0)
#&gt;  prodlim           * 2024.06.25 2024-06-24 [1] CRAN (R 4.4.0)
#&gt;  progress            1.2.3      2023-12-06 [1] CRAN (R 4.4.0)
#&gt;  proxy               0.4-27     2022-06-09 [1] CRAN (R 4.4.0)
#&gt;  purrr             * 1.0.2      2023-08-10 [1] CRAN (R 4.4.0)
#&gt;  R6                  2.5.1      2021-08-19 [1] CRAN (R 4.4.0)
#&gt;  rappdirs            0.3.3      2021-01-31 [1] CRAN (R 4.4.0)
#&gt;  rbibutils           2.2.16     2023-10-25 [1] CRAN (R 4.4.0)
#&gt;  RColorBrewer        1.1-3      2022-04-03 [1] CRAN (R 4.4.0)
#&gt;  Rcpp                1.0.13-1   2024-11-02 [1] CRAN (R 4.4.1)
#&gt;  Rdpack              2.6.1      2024-08-06 [1] CRAN (R 4.4.0)
#&gt;  readr             * 2.1.5      2024-01-10 [1] CRAN (R 4.4.0)
#&gt;  rlang               1.1.4      2024-06-04 [1] CRAN (R 4.4.0)
#&gt;  rmarkdown           2.28       2024-08-17 [1] CRAN (R 4.4.0)
#&gt;  rmeta               3.0        2018-03-20 [1] CRAN (R 4.4.0)
#&gt;  RSQLite             2.3.7      2024-05-27 [1] CRAN (R 4.4.0)
#&gt;  rstudioapi          0.16.0     2024-03-24 [1] CRAN (R 4.4.0)
#&gt;  S4Vectors           0.42.1     2024-07-03 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  sass                0.4.9      2024-03-15 [1] CRAN (R 4.4.0)
#&gt;  scales              1.3.0      2023-11-28 [1] CRAN (R 4.4.0)
#&gt;  SemiPar           * 1.0-4.2    2018-04-16 [1] CRAN (R 4.4.0)
#&gt;  sessioninfo         1.2.2      2021-12-06 [1] CRAN (R 4.4.0)
#&gt;  shape               1.4.6.1    2024-02-23 [1] CRAN (R 4.4.0)
#&gt;  statmod             1.5.0      2023-01-06 [1] CRAN (R 4.4.0)
#&gt;  stringi             1.8.4      2024-05-06 [1] CRAN (R 4.4.0)
#&gt;  stringr           * 1.5.1      2023-11-14 [1] CRAN (R 4.4.0)
#&gt;  SuppDists           1.1-9.8    2024-09-03 [1] CRAN (R 4.4.1)
#&gt;  survcomp          * 1.54.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  survival          * 3.7-0      2024-06-05 [1] CRAN (R 4.4.0)
#&gt;  survivalROC         1.0.3.1    2022-12-05 [1] CRAN (R 4.4.0)
#&gt;  tibble            * 3.2.1      2023-03-20 [1] CRAN (R 4.4.0)
#&gt;  tidyr             * 1.3.1      2024-01-24 [1] CRAN (R 4.4.0)
#&gt;  tidyselect          1.2.1      2024-03-11 [1] CRAN (R 4.4.0)
#&gt;  tidyverse         * 2.0.0      2023-02-22 [1] CRAN (R 4.4.0)
#&gt;  timechange          0.3.0      2024-01-18 [1] CRAN (R 4.4.0)
#&gt;  tweenr              2.0.3      2024-02-26 [1] CRAN (R 4.4.0)
#&gt;  tzdb                0.4.0      2023-05-12 [1] CRAN (R 4.4.0)
#&gt;  UCSC.utils          1.0.0      2024-05-06 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  utf8                1.2.4      2023-10-22 [1] CRAN (R 4.4.0)
#&gt;  vctrs               0.6.5      2023-12-01 [1] CRAN (R 4.4.0)
#&gt;  vroom               1.6.5      2023-12-05 [1] CRAN (R 4.4.0)
#&gt;  withr               3.0.1      2024-07-31 [1] CRAN (R 4.4.0)
#&gt;  xfun                0.47       2024-08-17 [1] CRAN (R 4.4.0)
#&gt;  xml2                1.3.6      2023-12-04 [1] CRAN (R 4.4.0)
#&gt;  XVector             0.44.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt;  yaml                2.3.10     2024-07-26 [1] CRAN (R 4.4.0)
#&gt;  zlibbioc            1.50.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
#&gt; 
#&gt;  [1] /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library
#&gt; 
#&gt; ──────────────────────────────────────────────────────────────────────────────</code></pre>
</details>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiMy4gUHJlZGljdGlvbiB3aXRoIEhpZ2ggRGltZW5zaW9uYWwgUHJlZGljdG9ycyIKYXV0aG9yOiAiTGlldmVuIENsZW1lbnQiCmRhdGU6ICJzdGF0T21pY3MsIEdoZW50IFVuaXZlcnNpdHkgKGh0dHBzOi8vc3RhdG9taWNzLmdpdGh1Yi5pbykiCm91dHB1dDoKICBib29rZG93bjo6cGRmX2RvY3VtZW50MjoKICAgIHRvYzogdHJ1ZQogICAgbnVtYmVyX3NlY3Rpb25zOiB0cnVlCiAgICBsYXRleF9lbmdpbmU6IHhlbGF0ZXgKYWx3YXlzX2FsbG93X2h0bWw6IHRydWUKLS0tCgpgYGB7ciwgY2hpbGQ9Il9zZXR1cC5SbWQifQpgYGAKCmBgYHtyIGVjaG89RkFMU0UsIG1lc3NhZ2U9IEZBTFNFfQpsaWJyYXJ5KHRpZHl2ZXJzZSkKbGlicmFyeShncmlkRXh0cmEpCmBgYAoKIyBJbnRyb2R1Y3Rpb24KCiMjIFByZWRpY3Rpb24gd2l0aCBIaWdoIERpbWVuc2lvbmFsIFByZWRpY3RvcnMKCkdlbmVyYWwgc2V0dGluZzoKCi0gICBBaW06IGJ1aWxkIGEgKipwcmVkaWN0aW9uIG1vZGVsKiogdGhhdCBnaXZlcyBhIHByZWRpY3Rpb24gb2YgYW4gb3V0Y29tZSBmb3IgYSBnaXZlbiBzZXQgb2YgcHJlZGljdG9ycy4KCi0gV2UgdXNlICRYJCB0byByZWZlciB0byB0aGUgcHJlZGljdG9ycyBhbmQgJFkkIHRvIHJlZmVyIHRvIHRoZSBvdXRjb21lLgoKCi0gQSAqKnRyYWluaW5nIGRhdGEgc2V0KiogaXMgYXZhaWxhYmxlLCBzYXkgJChcbWF0aGJme1h9LFxtYXRoYmZ7WX0pJC4gSXQgY29udGFpbnMgJG4kIG9ic2VydmF0aW9ucyBvbiBvdXRjb21lcyBhbmQgb24gJHAkIHByZWRpY3RvcnMuCgotIFVzaW5nIHRoZSB0cmFpbmluZyBkYXRhLCBhIHByZWRpY3Rpb24gbW9kZWwgaXMgYnVpbGQsIHNheSAkXGhhdHttfShcbWF0aGJme1h9KSQuIFRoaXMgdHlwaWNhbGx5IGludm9sdmVzICoqbW9kZWwgYnVpbGRpbmcgKGZlYXR1cmUgc2VsZWN0aW9uKSoqIGFuZCBwYXJhbWV0ZXIgZXN0aW1hdGlvbi4KCgotICAgRHVyaW5nIHRoZSBtb2RlbCBidWlsZGluZywgcG90ZW50aWFsICoqbW9kZWxzIG5lZWQgdG8gYmUgZXZhbHVhdGVkKiogaW4gdGVybXMgb2YgdGhlaXIgcHJlZGljdGlvbiBxdWFsaXR5LgoKIyMgRXhhbXBsZTogVG94aWNvZ2Vub21pY3MgaW4gZWFybHkgZHJ1ZyBkZXZlbG9wbWVudAoKIyMjIEJhY2tncm91bmQKCi0gRWZmZWN0IG9mIGNvbXBvdW5kIG9uIGdlbmUgZXhwcmVzc2lvbi4KCi0gSW5zaWdodCBpbiBhY3Rpb24gYW5kIHRveGljaXR5IG9mIGRydWcgaW4gZWFybHkgcGhhc2UKLSBEZXRlcm1pbmUgYWN0aXZpdHkgd2l0aCBiaW8tYXNzYXk6IGUuZy4gYmluZGluZyBhZmZpbml0eSBvZiBjb21wb3VuZCB0byBjZWxsIHdhbGwgcmVjZXB0b3IgKHRhcmdldCwgSUM1MCkuCi0gRWFybHkgcGhhc2U6ICAyMCB0byA1MCBjb21wb3VuZHMKLSBCYXNlZCBvbiBpbiB2aXRybyByZXN1bHRzIG9uZSBhaW1zIHRvIGdldCBpbnNpZ2h0IGluIGhvdyB0byBidWlsZCBiZXR0ZXIgY29tcG91bmQgKGhpZ2hlciBvbi10YXJnZXQgYWN0aXZpdHkgbGVzcyB0b3hpY2l0eS4KLSBTbWFsbCB2YXJpYXRpb25zIGluIG1vbGVjdWxhciBzdHJ1Y3R1cmUgbGVhZCB0byB2YXJpYXRpb25zIGluIEJBIGFuZCBnZW5lIGV4cHJlc3Npb24uCi0gQWltOiBCdWlsZCBtb2RlbCB0byBwcmVkaWN0IGJpby1hY3Rpdml0eSBiYXNlZCBvbiBnZW5lIGV4cHJlc3Npb24gaW4gbGl2ZXIgY2VsbCBsaW5lLgoKIyMjIERhdGEKCi0gMzAgY2hlbWljYWwgY29tcG91bmRzIGhhdmUgYmVlbiBzY3JlZW5lZCBmb3IgdG94aWNpdHkKCi0gQmlvYXNzYXkgZGF0YSBvbiB0b3hpY2l0eSBzY3JlZW5pbmcKCi0gR2VuZSBleHByZXNzaW9ucyBpbiBhIGxpdmVyIGNlbGwgbGluZSBhcmUgcHJvZmlsZWQgZm9yIGVhY2ggY29tcG91bmQgKDQwMDAgZ2VuZXMpCgoKYGBge3J9CnRveERhdGEgPC0gcmVhZF9jc3YoCiAgImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGF0T21pY3MvSERBMjAyMC9kYXRhL3RveERhdGFDZW50ZXJlZC5jc3YiLAogIGNvbF90eXBlcyA9IGNvbHMoKQopCnN2ZFggPC0gc3ZkKHRveERhdGFbLC0xXSkKYGBgCgpEYXRhIGlzIGFscmVhZHkgY2VudGVyZWQ6CgpgYGB7cn0KdG94RGF0YSAlPiUKICBjb2xNZWFucyAlPiUKICByYW5nZQpgYGAKCmBgYHtyfQogdG94RGF0YSAlPiUKICBuYW1lcyAlPiUKICBoZWFkCmBgYAoKLSBGaXJzdCBjb2x1bW4gY29udGFpbnMgZGF0YSBvbiBCaW9hc3NheS4KLSBUaGUgaGlnaGVyIHRoZSBzY29yZSBvbiBCaW9hc3NheSB0aGUgbW9yZSB0b3hpYyB0aGUgY29tcG91bmQKLSBPdGhlciBjb2x1bW5zIGNvbnRhaW4gZGF0YSBvbiBnZW5lIGV4cHJlc3Npb24gWDEsIC4uLiAsIFg0MDAwCgojIyMgRGF0YSBleHBsb3JhdGlvbgoKYGBge3J9CnRveERhdGEgJT4lCiAgZ2dwbG90KGFlcyh4PSIiLHk9QkEpKSArCiAgZ2VvbV9ib3hwbG90KG91dGxpZXIuc2hhcGU9TkEpICsKICBnZW9tX3BvaW50KHBvc2l0aW9uPSJqaXR0ZXIiKQpgYGAKCmBgYHtyfQpzdmRYIDwtIHRveERhdGFbLC0xXSAlPiUKICBzdmQKCmsgPC0gMgpWayA8LSBzdmRYJHZbLDE6a10KVWsgPC0gc3ZkWCR1WywxOmtdCkRrIDwtIGRpYWcoc3ZkWCRkWzE6a10pClprIDwtIFVrJSolRGsKY29sbmFtZXMoWmspIDwtIHBhc3RlMCgiWiIsMTprKQpjb2xuYW1lcyhWaykgPC0gcGFzdGUwKCJWIiwxOmspCgpaayAlPiUKICBhcy5kYXRhLmZyYW1lICU+JQogIG11dGF0ZShCQSA9IHRveERhdGEgJT4lIHB1bGwoQkEpKSAlPiUKICBnZ3Bsb3QoYWVzKHg9IFoxLCB5ID0gWjIsIGNvbG9yID0gQkEpKSArCiAgZ2VvbV9wb2ludChzaXplID0gMykgKwogIHNjYWxlX2NvbG91cl9ncmFkaWVudDIobG93ID0gImJsdWUiLG1pZD0id2hpdGUiLGhpZ2g9InJlZCIpICsKICBnZW9tX3BvaW50KHNpemUgPSAzLCBwY2ggPSAyMSwgY29sb3IgPSAiYmxhY2siKQpgYGAKCi0gU2NvcmVzIG9uIHRoZSBmaXJzdCB0d28gcHJpbmNpcGFsIGNvbXBvbmVudHMgKG9yIE1EUyBwbG90KS4KLSBFYWNoIHBvaW50IGNvcnJlc3BvbmRzIHRvIGEgY29tcG91bmQuCi0gQ29sb3IgY29kZSByZWZlcnMgdG8gdGhlIHRveGljaXR5IHNjb3JlIChoaWdoZXIgc2NvcmUgbW9yZSB0b3hpYykuCi0gQ2xlYXIgc2VwYXJhdGlvbiBiZXR3ZWVuIGNvbXBvdW5kcyBhY2NvcmRpbmcgdG8gdG94aWNpdHkuCgotLS0KCi0gTmV4dCBsb2dpYyBzdGVwIGluIGEgUENBIGlzIHRvIGludGVycHJldCB0aGUgcHJpbmNpcGFsIGNvbXBvbmVudHMuCi0gV2UgdGh1cyBoYXZlIHRvIGFzc2VzcyB0aGUgbG9hZGluZ3MuCi0gV2UgY2FuIGFkZCBhIHZlY3RvciBmb3IgZWFjaCBnZW5lIHRvIGdldCBhIGJpcGxvdCwgYnV0IHRoaXMgd291bGQgcmVxdWlyZSBwbG90dGluZyA0MDAwIHZlY3RvcnMsIHdoaWNoIHdvdWxkIHJlbmRlciB0aGUgcGxvdCB1bnJlYWRhYmxlLgoKQWx0ZXJuYXRpdmUgZ3JhcGggdG8gbG9vayBhdCB0aGUgbWFueSBsb2FkaW5ncyBvZiB0aGUgZmlyc3QgdHdvIFBDcy4KCmBgYHtyfQpncmlkLmFycmFuZ2UoCiAgVmsgJT4lCiAgICBhcy5kYXRhLmZyYW1lICU+JQogICAgbXV0YXRlKGdlbmVJRCA9IDE6bnJvdyhWaykpICU+JQogICAgZ2dwbG90KGFlcyh4ID0gZ2VuZUlELCB5ID0gVjEpKSArCiAgICBnZW9tX3BvaW50KHBjaD0yMSkgKwogICAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gYygtMiwwLDIpKnNkKFZrWywxXSksIGNvbCA9ICJyZWQiKSAsCiAgVmsgJT4lCiAgICBhcy5kYXRhLmZyYW1lICU+JQogICAgbXV0YXRlKGdlbmVJRCA9IDE6bnJvdyhWaykpICU+JQogICAgZ2dwbG90KGFlcyh4ID0gZ2VuZUlELCB5ID0gVjIpKSArCiAgICBnZW9tX3BvaW50KHBjaD0yMSkgKwogICAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gYygtMiwwLDIpKnNkKFZrWywyXSksIGNvbCA9ICJyZWQiKSwKICBuY29sPTIpCmBgYAoKLSBJdCBpcyBhbG1vc3QgaW1wb3NzaWJsZSB0byBpbnRlcnByZXQgdGhlIFBDcyBiZWNhdXNlIHRoZXJlIGFyZSA0MDAwIGdlbmVzIGNvbnRyaWJ1dGluZyB0byBlYWNoIFBDLgoKLSBJbiBhbiBhdHRlbXB0IHRvIGZpbmQgdGhlIG1vc3QgaW1wb3J0YW50IGdlbmVzIChpbiB0aGUgc2Vuc2UgdGhhdCB0aGV5IGRyaXZlIHRoZSBpbnRlcnByZXRhdGlvbiBvZiB0aGUgUENzKSwgdGhlIHBsb3RzIHNob3cgaG9yaXpvbnRhbCByZWZlcmVuY2UgbGluZXM6IHRoZSBhdmVyYWdlIG9mIHRoZSBsb2FkaW5ncywgYW5kIHRoZSBhdmVyYWdlIMKxIHR3aWNlIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIGxvYWRpbmdzLiBJbiBiZXR3ZWVuIHRoZSBsaW5lcyB3ZSBleHBlY3RzIGFib3V0IDk1JSBvZiB0aGUgbG9hZGluZ3MgKGlmIHRoZXkgd2VyZSBub3JtYWxseSBkaXN0cmlidXRlZCkuCgotIFRoZSBwb2ludHMgb3V0c2lkZSB0aGUgYmFuZCBjb21lIGZyb20gdGhlIGdlbmVzIHRoYXQgaGF2ZSByYXRoZXIgbGFyZ2UgbG9hZGluZ3MgKGluIGFic29sdXRlIHZhbHVlKSBhbmQgaGVuY2UgYXJlIGltcG9ydGFudCBmb3IgdGhlIGludGVycHJldGF0aW9uIG9mIHRoZSBQQ3MuCgotIE5vdGUsIHRoYXQgcGFydGljdWxhcmx5IGZvciB0aGUgZmlyc3QgUEMsIG9ubHkgYSBmZXcgZ2VuZXMgc2hvdyBhIG1hcmtlZGx5IGxhcmdlIGxvYWRpbmdzIHRoYXQgYXJlIG5lZ2F0aXZlLiBUaGlzIG1lYW5zIHRoYXQgYW4gdXByZWd1bGF0aW9uIG9mIHRoZXNlIGdlbmVzIHdpbGwgbGVhZCB0byBsb3cgc2NvcmVzIG9uIFBDMS4KLSBUaGVzZSBnZW5lcyB3aWxsIHZlcnkgbGlrZWx5IHBsYXkgYW4gaW1wb3J0YW50IHJvbGUgaW4gdGhlIHRveGljaXR5IG1lY2hhbmlzbS4KLSBJbmRlZWQsIGxvdyBzY29yZXMgb24gUEMxIGFyZSBpbiB0aGUgZGlyZWN0aW9uIG9mIG1vcmUgdG94aWNpdHkuCi0gSW4gdGhlIG5leHQgY2hhcHRlciB3ZSB3aWxsIGludHJvZHVjZSBhIG1ldGhvZCB0byBvYnRhaW4gc3BhcnNlIFBDcy4KCiMjIyBQcmVkaWN0aW9uIG1vZGVsCgpgYGB7cn0KbTEgPC0gbG0oQkEgfiAtMSArIC4sIHRveERhdGEpCgptMSAlPiUKICBjb2VmICU+JQogIGhlYWQoNDApCgptMSAlPiUKICBjb2VmICU+JQogIGlzLm5hICU+JQogIHN1bQoKc3VtbWFyeShtMSkkci5zcXVhcmVkCmBgYAoKUHJvYmxlbT8/CgojIyBCcmFpbiBleGFtcGxlCgotIENvdXJ0ZXN5IHRvIFNvbG9tb24gS3Vyei4gU3RhdGlzdGljYWwgcmV0aGlua2luZyB3aXRoIGJybXMsIGdncGxvdDIsIGFuZCB0aGUgdGlkeXZlcnNlIHZlcnNpb24gMS4yLjAuCgpodHRwczovL2Jvb2tkb3duLm9yZy9jb250ZW50LzM4OTAvCmh0dHBzOi8vZ2l0aHViLmNvbS9BU0t1cnovU3RhdGlzdGljYWxfUmV0aGlua2luZ193aXRoX2JybXNfZ2dwbG90Ml9hbmRfdGhlX3RpZHl2ZXJzZQoKLSBEYXRhIHdpdGggYnJhaW4gc2l6ZSBhbmQgYm9keSBzaXplIGZvciBzZXZlbiBzcGVjaWVzCgpgYGB7cn0KYnJhaW4gPC0KdGliYmxlKHNwZWNpZXMgPSBjKCJhZmFyZW5zaXMiLCAiYWZyaWNhbnVzIiwgImhhYmlsaXMiLCAiYm9pc2VpIiwgInJ1ZG9sZmVuc2lzIiwgImVyZ2FzdGVyIiwgInNhcGllbnMiKSwKICAgICAgIGJyYWluICAgPSBjKDQzOCwgNDUyLCA2MTIsIDUyMSwgNzUyLCA4NzEsIDEzNTApLAogICAgICAgbWFzcyAgICA9IGMoMzcuMCwgMzUuNSwgMzQuNSwgNDEuNSwgNTUuNSwgNjEuMCwgNTMuNSkpCmBgYAoKIyMjIERhdGEgZXhwbG9yYXRpb24KCmBgYHtyfQpicmFpbgoKcCA8LSBicmFpbiAlPiUKICBnZ3Bsb3QoYWVzKHggPSAgbWFzcywgeSA9IGJyYWluLCBsYWJlbCA9IHNwZWNpZXMpKSArCiAgZ2VvbV9wb2ludCgpCgpwICsgZ2VvbV90ZXh0KG51ZGdlX3kgPSA0MCkKYGBgCgojIyMgTW9kZWxzCgpTaXggbW9kZWxzIHJhbmdlIGluIGNvbXBsZXhpdHkgZnJvbSB0aGUgc2ltcGxlIHVuaXZhcmlhdGUgbW9kZWwKClxiZWdpbnthbGlnbip9Clx0ZXh0e2JyYWlufV9pICYgXHNpbSBcb3BlcmF0b3JuYW1le05vcm1hbH0gKFxtdV9pLCBcc2lnbWEpIFxcClxtdV9pICYgPSBcYmV0YV8wICsgXGJldGFfMSBcdGV4dHttYXNzfV9pLApcZW5ke2FsaWduKn0KCnRvIHRoZSBkaXp6eWluZyBzaXh0aC1kZWdyZWUgcG9seW5vbWlhbCBtb2RlbAoKXGJlZ2lue2FsaWduKn0KXHRleHR7YnJhaW59X2kgJiBcc2ltIFxvcGVyYXRvcm5hbWV7Tm9ybWFsfSAoXG11X2ksIFxzaWdtYSkgXFwKXG11X2kgJiA9IFxiZXRhXzAgKyBcYmV0YV8xIFx0ZXh0e21hc3N9X2kgKyBcYmV0YV8yIFx0ZXh0e21hc3N9X2leMiArIFxiZXRhXzMgXHRleHR7bWFzc31faV4zICsgXGJldGFfNCBcdGV4dHttYXNzfV9pXjQgKyBcYmV0YV81IFx0ZXh0e21hc3N9X2leNSArIFxiZXRhXzYgXHRleHR7bWFzc31faV42LgpcZW5ke2FsaWduKn0KCmBgYHtyLCBtZXNzYWdlID0gRiwgd2FybmluZyA9IEZ9CmZvcm11bGFzIDwtIHNhcHBseSgxOjYsIGZ1bmN0aW9uKGkpCiAgcmV0dXJuKAogICAgIHBhc3RlMCgiSShtYXNzXiIsMTppLCIpIikgJT4lIHBhc3RlKGNvbGxhcHNlPSIgKyAiKQogICAgKQopCgpmb3JtdWxhcyA8LSBzYXBwbHkoCiAgcGFzdGUwKCJicmFpbiB+ICIsIGZvcm11bGFzKSwKICBhcy5mb3JtdWxhKQoKbW9kZWxzIDwtIGxhcHBseShmb3JtdWxhcywgbG0gLCBkYXRhID0gYnJhaW4pCmBgYAoKYGBge3J9CmRhdGEuZnJhbWUoCiAgZm9ybXVsYT1mb3JtdWxhcyAlPiUKICAgIGFzLmNoYXJhY3RlciwKICByMiA9IHNhcHBseSgKICAgIG1vZGVscywKICAgIGZ1bmN0aW9uKG1vZCkgc3VtbWFyeShtb2QpJHIuc3F1YXJlZCkKICApICAlPiUKICBnZ3Bsb3QoCiAgICBhZXMoeCA9IHIyLAogICAgICB5ID0gZm9ybXVsYSwKICAgICAgbGFiZWwgPSByMiAlPiUKICAgICAgICByb3VuZCgyKSAlPiUKICAgICAgICBhcy5jaGFyYWN0ZXIpCiAgKSArCiAgZ2VvbV90ZXh0KCkKYGBgCgpXZSBwbG90IHRoZSBmaXQgZm9yIGVhY2ggbW9kZWwgaW5kaXZpZHVhbGx5IGFuZCB0aGVtIGFycmFuZ2UgdGhlbSB0b2dldGhlciBpbiBvbmUgcGxvdC4KCmBgYHtyfQpwbG90cyA8LSBsYXBwbHkoMTo2LCBmdW5jdGlvbihpKQp7CiAgcCArCiAgZ2VvbV9zbW9vdGgobWV0aG9kID0gImxtIiwgZm9ybXVsYSA9IHkgfiBwb2x5KHgsaSkpICsKICBnZ3RpdGxlKAogICAgcGFzdGUwKAogICAgICAicjIgPSAiLAogICAgICByb3VuZChzdW1tYXJ5KG1vZGVsc1tbaV1dKSRyLnNxdWFyZWQqMTAwLDEpLAogICAgICAiJSIpCiAgICApCn0pCgpkby5jYWxsKCJncmlkLmFycmFuZ2UiLGMocGxvdHMsIG5jb2wgPSAzKSkKYGBgCgotIFdlIGNsZWFybHkgc2VlIHRoYXQgaW5jcmVhc2luZyB0aGUgbW9kZWwgY29tcGxleGl0eSBhbHdheXMgcHJvZHVjZXMgYSBmaXQgd2l0aCBhIHNtYWxsZXIgU1NFLgotIFRoZSBwcm9ibGVtIG9mIG92ZXJmaXR0aW5nIGlzIHZlcnkgb2J2aW91cy4gVGhlIG1vcmUgY29tcGxleCBwb2x5bm9taWFsIG1vZGVscyB3aWxsIG5vdCBnZW5lcmFsaXNlIHdlbGwgZm9yIHByZWRpY3Rpb24hCi0gV2UgZXZlbiBoYXZlIGEgbW9kZWwgdGhhdCBmaXRzIHRoZSBkYXRhIHBlcmZlY3RseSwgYnV0IHRoYXQgd2lsbCBtYWtlIHZlcnkgYWJzdXJkIHByZWRpdGlvbnMhCgotIFRvbyBmZXcgcGFyYW1ldGVycyBodXJ0cywgdG9vLiBGaXQgdGhlIHVuZGVyZml0IGludGVyY2VwdC1vbmx5IG1vZGVsLgoKYGBge3J9Cm0wIDwtIGxtKGJyYWluIH4gMSwgYnJhaW4pCnN1bW1hcnkobTApCgpwICsKICBzdGF0X3Ntb290aChtZXRob2QgPSAibG0iLCBmb3JtdWxhID0geSB+IDEpICsKICBnZ3RpdGxlKAogICAgcGFzdGUwKAogICAgICAicjIgPSAiLAogICAgICByb3VuZChzdW1tYXJ5KG0wKSRyLnNxdWFyZWQqMTAwLDEpLAogICAgICAiJSIpCiAgICApCmBgYAoKVGhlIHVuZGVyZml0IG1vZGVsIGRpZCBub3QgbGVhcm4gYW55dGhpbmcgYWJvdXQgdGhlIHJlbGF0aW9uIGJldHdlZW4gbWFzcyBhbmQgYnJhaW4uIEl0IHdvdWxkIGFsc28gZG8gYSB2ZXJ5IHBvb3Igam9iIGZvciBwcmVkaWN0aW5nIG5ldyBkYXRhLgoKIyMgT3ZlcnZpZXcKCldlIHdpbGwgbWFrZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gY29udGludW91cyBhbmQgZGlzY3JldGUgb3V0Y29tZXMuIEluIHRoaXMgY291cnNlIHdlIGZvY3VzIG9uCgotIExpbmVhciByZWdyZXNzaW9uIG1vZGVscyBmb3IgY29udGlub3VzIG91dGNvbWVzCgogIC0gUGVuYWxpc2VkIHJlZ3Jlc3Npb246IExhc3NvIGFuZCByaWRnZQogIC0gUHJpbmNpcGFsIGNvbXBvbmVudCByZWdyZXNzaW9uIChQQ1IpCgotIExvZ2lzdGljIHJlZ3Jlc3Npb24gbW9kZWxzIGZvciBiaW5hcnkgb3V0Y29tZXMKCiAgLSBQZW5hbGlzZWQgcmVncmVzc2lvbjogTGFzc28gYW5kIHJpZGdlCgpGb3IgYWxsIHR5cGVzIG9mIG1vZGVsLCB3ZSB3aWxsIGRpc2N1c3MgZmVhdHVyZSBzZWxlY3Rpb24gbWV0aG9kcy4KCiMgTGluZWFyIFJlZ3Jlc3Npb24gZm9yIEhpZ2ggRGltZW5zaW9uYWwgRGF0YQoKQ29uc2lkZXIgbGluZWFyIHJlZ3Jlc3Npb24gbW9kZWwgKGZvciBkb3VibGUgY2VudGVyZWQgZGF0YSkKXFsKICBZX2kgPSBcYmV0YV8xWF97aTF9ICsgXGJldGFfMiBYX3tpMn0gKyBcY2RvdHMgKyBcYmV0YV9wWF97aXB9ICsgXGVwc2lsb25faSAsClxdCndpdGggJFx0ZXh0e0V9XGxlZnRbXGVwc2lsb24gXG1pZCBcbWF0aGJme1h9XHJpZ2h0XT0wJCBhbmQgJFx0ZXh0e3Zhcn1cbGVmdFtcZXBzaWxvbiBcbWlkIFxtYXRoYmZ7WH1ccmlnaHRdPVxzaWdtYV4yJC4KCkluIG1hdHJpeCBub3RhdGlvbiB0aGUgbW9kZWwgYmVjb21lcwpcWwogIFxtYXRoYmZ7WX0gPSBcbWF0aGJme1h9XG1hdGhiZlxiZXRhICsgXG1hdGhiZlxlcHNpbG9uLgpcXQpUaGUgbGVhc3Qgc3F1YXJlcyBlc3RpbWF0b3Igb2YgJFxtYXRoYmZcYmV0YSQgaXMgZ2l2ZW4gYnkKXFsKICBcaGF0e1xtYXRoYmZcYmV0YX0gPSAoXG1hdGhiZntYfV5UXG1hdGhiZntYfSleey0xfVxtYXRoYmZ7WH1eVFxtYXRoYmZ7WX0gLApcXQphbmQgdGhlIHZhcmlhbmNlIG9mICRcaGF0e1xtYXRoYmZcYmV0YX0kIGVxdWFscwpcWwogIFx0ZXh0e3Zhcn1cbGVmdFtcaGF0e1xtYXRoYmZcYmV0YX1ccmlnaHRdID0gKFxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH0pXnstMX1cc2lnbWFeMi4KXF0KJFxsb25ncmlnaHRhcnJvdyQgdGhlICRwIFx0aW1lcyBwJCBtYXRyaXggJChcbWF0aGJme1h9XlRcbWF0aGJme1h9KV57LTF9JCBpcyBjcnVjaWFsCgpOb3RlLCB0aGF0CgotIHdpdGggZG91YmxlIGNlbnRlcmVkIGRhdGEgaXQgaXMgbWVhbnQgdGhhdCBib3RoIHRoZSByZXNwb25zZXMgYXJlIGNlbnRlcmVkIChtZWFuIG9mICRcbWF0aGJme1l9JCBpcyB6ZXJvKSBhbmQgdGhhdCBhbGwgcHJlZGljdG9ycyBhcmUgY2VudGVyZWQgKGNvbHVtbnMgb2YgJFxtYXRoYmZ7WH0kIGhhdmUgemVybyBtZWFuKS4gV2l0aCBkb3VibGUgY2VudGVyZWQgZGF0YSB0aGUgaW50ZXJjZXB0IGluIGEgbGluZWFyIHJlZ3Jlc3Npb24gbW9kZWwgaXMgYWx3YXlzIGV4YWN0bHkgZXF1YWwgdG8gemVybyBhbmQgaGVuY2UgdGhlIGludGVyY2VwdCBtdXN0IG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgbW9kZWwuCgotIHdlIGRvIG5vdCBhc3N1bWUgdGhhdCB0aGUgcmVzaWR1YWxzIGFyZSBub3JtYWxseSBkaXN0cmlidXRlZC4gRm9yIHByZWRpY3Rpb24gcHVycG9zZXMgdGhpcyBpcyBvZnRlbiBub3QgcmVxdWlyZWQgKG5vcm1hbGl0eSBpcyBwYXJ0aWN1bGFybHkgaW1wb3J0YW50IGZvciBzdGF0aXN0aWNhbCBpbmZlcmVuY2UgaW4gc21hbGwgc2FtcGxlcykuCgojIyBMaW5lYXIgUmVncmVzc2lvbiBmb3IgbXVsdGl2YXJpYXRlIGRhdGEgdnMgSGlnaCBEaW1lbnNpb25hbCBEYXRhCgotICRcbWF0aGJme1heVFh9JCBhbmQgJChcbWF0aGJme1heVFh9KV57LTF9JCBhcmUgJHAgXHRpbWVzIHAkIG1hdHJpY2VzCgotICRcbWF0aGJme1heVFh9JCBjYW4gb25seSBiZSBpbnZlcnRlZCBpZiBpdCBoYXMgcmFuayAkcCQKCi0gUmFuayBvZiBhIG1hdHJpeCBvZiBmb3JtICRcbWF0aGJme1heVFh9JCwgd2l0aCAkXG1hdGhiZntYfSQgYW5kICRuXHRpbWVzIHAkIG1hdHJpeCwgY2FuIG5ldmVyIGJlIGxhcmdlciB0aGFuICRcbWluKG4scCkkLgoKLSBpbiBtb3N0IHJlZ3Jlc3Npb24gcHJvYmxlbXMgJG4+cCQgYW5kIHJhbmsgb2YgJChcbWF0aGJme1heVFh9KSQgZXF1YWxzICRwJAoKLSBpbiBoaWdoIGRpbWVuc2lvbmFsIHJlZ3Jlc3Npb24gcHJvYmxlbXMgJHAgPj4+IG4kIGFuZCByYW5rIG9mICQoXG1hdGhiZntYXlRYfSkkIGVxdWFscyAkbjxwJAoKLSBpbiB0aGUgdG94aWNvZ2Vub21pY3MgZXhhbXBsZSAkbj0zMDxwPTQwMDAkIGFuZCAkXHRleHR7cmFua30oXG1hdGhiZntYXlRYfSlcbGVxIG49MzAkLgogICRcbG9uZ3JpZ2h0YXJyb3ckICQoXG1hdGhiZntYXlRYfSleey0xfSQgZG9lcyBub3QgZXhpc3QsIGFuZCBuZWl0aGVyIGRvZXMgJFxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fSQuCgojIyBDYW4gU1ZEIGhlbHA/CiAgLSBTaW5jZSB0aGUgY29sdW1ucyBvZiAkXG1hdGhiZntYfSQgYXJlIGNlbnRlcmVkLCAkXG1hdGhiZntYXlRYfSBccHJvcHRvIFx0ZXh0e3Zhcn1cbGVmdFtcbWF0aGJme1h9XHJpZ2h0XSQuCgogIC0gaWYgJFx0ZXh0e3Jhbmt9KFxtYXRoYmZ7WF5UWH0pPW49MzAkLCB0aGUgUENBIHdpbGwgZ2l2ZSAzMCBjb21wb25lbnRzLCBlYWNoIGJlaW5nIGEgbGluZWFyIGNvbWJpbmF0aW9uIG9mICRwPTQwMDAkIHZhcmlhYmxlcy4gVGhlc2UgMzAgUENzIGNvbnRhaW4gYWxsIGluZm9ybWF0aW9uIHByZXNlbnQgaW4gdGhlIG9yaWdpbmFsICRcbWF0aGJme1h9JCBkYXRhLgoKICAtIGlmICRcdGV4dHtyYW5rfShcbWF0aGJme1h9KT1uPTMwJCwgdGhlIFNWRCBvZiAkXG1hdGhiZntYfSQgaXMgZ2l2ZW4gYnkKICBcWwogICBcbWF0aGJme1h9ID0gXHN1bV97aT0xfV5uIFxkZWx0YV9pIFxtYXRoYmZ7dX1faSBcbWF0aGJme3Z9X2leVCA9IFxtYXRoYmZ7VX0gXGJvbGRzeW1ib2x7XERlbHRhfSBcbWF0aGJme1Z9XlQgPSBcbWF0aGJme1pWfV5ULAogIFxdCiAgd2l0aCAkXG1hdGhiZntafSQgdGhlICRuXHRpbWVzIG4kIG1hdHJpeCB3aXRoIHRoZSBzY29yZXMgb24gdGhlICRuJCBQQ3MuCgogIC0gU3RpbGwgcHJvYmxlbWF0aWMgYmVjYXVzZSBpZiB3ZSB1c2UgYWxsIFBDcyAkbj1wJC4KCgojIFByaW5jaXBhbCBDb21wb25lbnQgUmVncmVzc2lvbgoKQSBwcmluY2lwYWwgY29tcG9uZW50IHJlZ3Jlc3Npb24gKFBDUikgY29uc2lzdHMgb2YKCjEuIHRyYW5zZm9ybWluZyAkcD00MDAwJCBkaW1lbnNpb25hbCAkWCQtdmFyaWFibGUgdG8gdGhlICRuPTMwJCBkaW1lbnNpb25hbCAkWiQtdmFyaWFibGUgKFBDIHNjb3JlcykuIFRoZSAkbiQgUENzIGFyZSBtdXR1YWxseSB1bmNvcnJlbGF0ZWQuCgoyLiB1c2luZyB0aGUgJG4kIFBDLXZhcmlhYmxlcyBhcyByZWdyZXNzb3JzIGluIGEgbGluZWFyIHJlZ3Jlc3Npb24gbW9kZWwKCjMuIHBlcmZvcm1pbmcgZmVhdHVyZSBzZWxlY3Rpb24gdG8gc2VsZWN0IHRoZSBtb3N0IGltcG9ydGFudCByZWdyZXNzb3JzIChQQykuCgpGZWF0dXJlIHNlbGVjdGlvbiBpcyBrZXksIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBoYXZlIGFzIG1hbnkgcmVncmVzc29ycyBhcyB0aGVyZSBhcmUgb2JzZXJ2YXRpb25zIGluIHRoZSBkYXRhLiBUaGlzIHdvdWxkIHJlc3VsdCBpbiB6ZXJvIHJlc2lkdWFsIGRlZ3JlZXMgb2YgZnJlZWRvbS4gKHNlZSBsYXRlcikKCi0tLQoKVG8ga2VlcCB0aGUgZXhwb3NpdGlvbiBnZW5lcmFsIHNvIHRoYXQgd2UgYWxsb3cgZm9yIGEgZmVhdHVyZSBzZWxlY3Rpb24gdG8gaGF2ZSB0YWtlbiBwbGFjZSwgSSB1c2UgdGhlIG5vdGF0aW9uICRcbWF0aGJme1V9X1MkIHRvIGRlbm90ZSBhIG1hdHJpeCB3aXRoIGxlZnQtc2luZ3VsYXIgY29sdW1uIHZlY3RvcnMgJFxtYXRoYmZ7dX1faSQsIHdpdGggJGkgXGluIHtcbWF0aGNhbHtTfX0kICgke1xtYXRoY2Fse1N9fSQgYW4gaW5kZXggc2V0IHJlZmVycmluZyB0byB0aGUgUENzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZWdyZXNzaW9uIG1vZGVsKS4KCkZvciBleGFtcGxlLCBzdXBwb3NlIHRoYXQgYSBmZWF0dXJlIHNlbGVjdGlvbiBtZXRob2QgaGFzIHJlc3VsdGVkIGluIHRoZSBzZWxlY3Rpb24gb2YgUENzIDEsIDMgYW5kIDEyIGZvciBpbmNsdXNpb24gaW4gdGhlIHByZWRpY3Rpb24gbW9kZWwsIHRoZW4gJHtcbWF0aGNhbHtTfX09XHsxLDMsMTJcfSQgYW5kClxbCiBcbWF0aGJme1V9X1MgPSBcYmVnaW57cG1hdHJpeH0KICBcbWF0aGJme3V9XzEgJiBcbWF0aGJme3V9XzMgJiBcbWF0aGJme3V9X3sxMn0KIFxlbmR7cG1hdHJpeH0uClxdCgotLS0KCiMjIyBFeGFtcGxlIG1vZGVsIGJhc2VkIG9uIGZpcnN0IDQgUENzCgpgYGB7cn0KayA8LSAzMApVayA8LSBzdmRYJHVbLDE6a10KRGsgPC0gZGlhZyhzdmRYJGRbMTprXSkKWmsgPC0gVWslKiVEawpZIDwtIHRveERhdGEgJT4lCiAgcHVsbChCQSkKCm00IDwtIGxtKFl+WmtbLDE6NF0pCnN1bW1hcnkobTQpCmBgYAoKTm90ZToKCi0gdGhlIGludGVyY2VwdCBpcyBlc3RpbWF0ZWQgYXMgemVyby4gKFdoeT8pIFRoZSBtb2RlbCBjb3VsZCBoYXZlIGJlZW4gZml0dGVkIGFzCgpgYGAKbTQgPC0gbG0oWX4tMStaa1ssMTo0XSkKYGBgCgotIHRoZSBQQy1wcmVkaWN0b3JzIGFyZSB1bmNvcnJlbGF0ZWQgKGJ5IGNvbnN0cnVjdGlvbikKCi0gZmlyc3QgUEMtcHJlZGljdG9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBtb3N0IGltcG9ydGFudCBwcmVkaWN0b3JzCgotICRwJC12YWx1ZXMgYXJlIG5vdCB2ZXJ5IG1lYW5pbmdmdWwgd2hlbiBwcmVkaWN0aW9uIGlzIHRoZSBvYmplY3RpdmUKCk1ldGhvZHMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHdpbGwgYmUgZGlzY3Vzc2VkIGxhdGVyLgoKIyBSaWRnZSBSZWdyZXNzaW9uCgojIyBQZW5hbHR5CgogVGhlIHJpZGdlIHBhcmFtZXRlciBlc3RpbWF0b3IgaXMgZGVmaW5lZCBhcyB0aGUgcGFyYW1ldGVyICRcbWF0aGJmXGJldGEkIHRoYXQgbWluaW1pc2VzIHRoZSAqKnBlbmFsaXNlZCBsZWFzdCBzcXVhcmVzIGNyaXRlcmlvbioqCgogXFsKIFx0ZXh0e1NTRX1fXHRleHR7cGVufT1cVmVydFxtYXRoYmZ7WX0gLSBcbWF0aGJme1hcYmV0YX1cVmVydF8yXjIgKyBcbGFtYmRhIFxWZXJ0IFxib2xkc3ltYm9se1xiZXRhfSBcVmVydF8yXjIKXF0KCi0gJFxWZXJ0IFxib2xkc3ltYm9se1xiZXRhfSBcVmVydF8yXjI9XHN1bV97aj0xfV5wIFxiZXRhX2peMiQgaXMgdGhlICoqJExfMiQgcGVuYWx0eSB0ZXJtKioKCi0gJFxsYW1iZGE+MCQgaXMgdGhlIHBlbmFsdHkgcGFyYW1ldGVyICh0byBiZSBjaG9zZW4gYnkgdGhlIHVzZXIpLgoKTm90ZSwgdGhhdCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gbWluaW1pemluZwpcWwpcVmVydFxtYXRoYmZ7WX0gLSBcbWF0aGJme1hcYmV0YX1cVmVydF8yXjIgXHRleHR7IHN1YmplY3QgdG8gfSBcVmVydCBcYm9sZHN5bWJvbHtcYmV0YX1cVmVydF4yXzJcbGVxIHMKXF0KCk5vdGUsIHRoYXQgJHMkIGhhcyBhIG9uZS10by1vbmUgY29ycmVzcG9uZGVuY2Ugd2l0aCAkXGxhbWJkYSQKCiMjIEdyYXBoaWNhbCBpbnRlcnByZXRhdGlvbgoKYGBge3IgZWNobyA9IEZBTFNFLCB3YXJuaW5nID0gRkFMU0UsIG1lc3NhZ2UgPSBGQUxTRX0KbGlicmFyeShnZ2ZvcmNlKQpsaWJyYXJ5KGxhdGV4MmV4cCkKbGlicmFyeShncmlkRXh0cmEpCgpwMSA8LSBnZ3Bsb3QoKSArCiAgZ2VvbV9lbGxpcHNlKGFlcyh4MCA9IDQsIHkwID0gMTEsIGEgPSAxMCwgYiA9IDMsIGFuZ2xlID0gcGkgLyA0KSkgKwogIGdlb21fZWxsaXBzZShhZXMoeDAgPSA0LCB5MCA9IDExLCBhID0gNSwgYiA9IDEuNSwgYW5nbGUgPSBwaSAvIDQpKSArCiAgeGxpbSgtMTIuNSwgMTIuNSkgKwogIHlsaW0oLTUsIDIwKSArCiAgZ2VvbV9wb2ludChhZXMoeCA9IDQsIHkgPSAxMSkpICsKICBhbm5vdGF0ZSgidGV4dCIsIGxhYmVsID0gVGVYKCIkKFxcaGF0e1xcYmV0YX1fMV57b2xzfSwgXFxoYXR7XFxiZXRhfV8yXntvbHN9KSQiKSwgeCA9IC01LCB5ID0gMTUsIHNpemUgPSA2LCBwYXJzZSA9IFRSVUUpICsKICB4bGFiKFRlWCgiJFxcYmV0YV8xJCIpKSArCiAgeWxhYihUZVgoIiRcXGJldGFfMiQiKSkgKwogIGdlb21fc2VnbWVudCgKICAgIGFlcyh4ID0gLTUsIHkgPSAxMi41LCB4ZW5kID0gMy43LCB5ZW5kID0gMTEuMyksCiAgICBhcnJvdyA9IGFycm93KGxlbmd0aCA9IHVuaXQoMC4yNSwgImNtIikpCiAgICApICsKICBjb29yZF9maXhlZCgpCgpwUmlkZ2UgPC0gcDEgKwogIGdlb21fY2lyY2xlKGFlcyh4MCA9IDAsIHkwID0gMCwgciA9IDMuOSkgLCBjb2xvciA9ICJyZWQiKSArCiAgZ2VvbV9wb2ludChhZXMoeCA9IC0xLjEsIHkgPSAzLjc1KSwgY29sb3IgPSAicmVkIikgKwogIGFubm90YXRlKCJ0ZXh0IiwgbGFiZWwgPSBUZVgoIiQoXFxoYXR7XFxiZXRhfV8xXntyaWRnZX0sIFxcaGF0e1xcYmV0YX1fMl57cmlkZ2V9KSQiKSwgeCA9IC04LjEsIHkgPSA0LjQ1LCBzaXplID0gNiwgcGFyc2UgPSBUUlVFLCBjb2xvciA9ICJyZWQiKSArCiAgZ2d0aXRsZSgiUmlkZ2UiKSArCiAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMCwgY29sb3IgPSAiZ3JleSIpICsKICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSAwLCBjb2xvciA9ICJncmV5IikgKwogIHRoZW1lX21pbmltYWwoKQoKcFJpZGdlCmBgYAoKIyMgU29sdXRpb24KClRoZSBzb2x1dGlvbiBpcyBnaXZlbiBieQpcWwogIFxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fSA9IChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSBcbWF0aGJme1heVCBZfS4KXF0KSXQgY2FuIGJlIHNob3duIHRoYXQgJChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSkkIGlzIGFsd2F5cyBvZiByYW5rICRwJCBpZiAkXGxhbWJkYT4wJC4KCkhlbmNlLCAkKFxtYXRoYmZ7WF5UWH0rXGxhbWJkYSBcbWF0aGJme0l9KSQgaXMgaW52ZXJ0aWJsZSBhbmQgJFxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fSQgZXhpc3RzIGV2ZW4gaWYgJHA+Pj5uJC4KCldlIGFsc28gZmluZApcWwogIFx0ZXh0e3Zhcn1cbGVmdFtcaGF0e1xtYXRoYmZcYmV0YX1ccmlnaHRdID0gKFxtYXRoYmZ7WF5UWH0rXGxhbWJkYSBcbWF0aGJme0l9KV57LTF9IFxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH0gKFxtYXRoYmZ7WF5UWH0rXGxhbWJkYSBcbWF0aGJme0l9KV57LTF9XHNpZ21hXjIKXF0KCkhvd2V2ZXIsIGl0IGNhbiBiZSBzaG93biB0aGF0IGltcHJvdmVkIGludGVydmFscyB0aGF0IGFsc28gYWNjb3VudCBmb3IgdGhlIGJpYXMgY2FuIGJlIGNvbnN0cnVjdGVkIGJ5IHVzaW5nOgoKXFsKICBcdGV4dHt2YXJ9XGxlZnRbXGhhdHtcbWF0aGJmXGJldGF9XHJpZ2h0XSA9IChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSAgXHNpZ21hXjIuClxdCgojIyMgUHJvb2YKClRoZSBjcml0ZXJpb24gdG8gYmUgbWluaW1pc2VkIGlzCiAgXFsKICAgXHRleHR7U1NFfV9cdGV4dHtwZW59PVxWZXJ0XG1hdGhiZntZfSAtIFxtYXRoYmZ7WFxiZXRhfVxWZXJ0XzJeMiArIFxsYW1iZGEgXFZlcnQgXGJvbGRzeW1ib2x7XGJldGF9IFxWZXJ0XzJeMi4KIFxdCiBGaXJzdCB3ZSByZS1leHByZXNzIFNTRSBpbiBtYXRyaXggbm90YXRpb246CiBcWwogICBcdGV4dHtTU0V9X1x0ZXh0e3Blbn0gPSAoXG1hdGhiZntZfS1cbWF0aGJme1hcYmV0YX0pXlQoXG1hdGhiZntZfS1cbWF0aGJme1hcYmV0YX0pICsgXGxhbWJkYSBcYm9sZHN5bWJvbHtcYmV0YX1eVFxib2xkc3ltYm9se1xiZXRhfS4KIFxdCiBUaGUgcGFydGlhbCBkZXJpdmF0aXZlIHcuci50LiAkXGJvbGRzeW1ib2x7XGJldGF9JCBpcwogXFsKICAgXGZyYWN7XHBhcnRpYWx9e1xwYXJ0aWFsIFxib2xkc3ltYm9se1xiZXRhfX1cdGV4dHtTU0V9X1x0ZXh0e3Blbn0gPSAtMlxtYXRoYmZ7WH1eVChcbWF0aGJme1l9LVxtYXRoYmZ7WFxiZXRhfSkrMlxsYW1iZGFcYm9sZHN5bWJvbHtcYmV0YX0uCiBcXQogU29sdmluZyAkXGZyYWN7XHBhcnRpYWx9e1xwYXJ0aWFsIFxib2xkc3ltYm9se1xiZXRhfX1cdGV4dHtTU0V9X1x0ZXh0e3Blbn09MCQgZ2l2ZXMKIFxbCiAgIFxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fSA9IChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSBcbWF0aGJme1heVCBZfS4KIFxdCiAoYXNzdW1wdGlvbjogJChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSkkIGlzIG9mIHJhbmsgJHAkLiBUaGlzIGlzIGFsd2F5cyB0cnVlIGlmICRcbGFtYmRhPjAkKQoKIyMgTGluayB3aXRoIFNWRAoKIyMjIFNWRCBhbmQgaW52ZXJzZQpXcml0ZSB0aGUgU1ZEIG9mICRcbWF0aGJme1h9JCAoJHA+biQpIGFzClxbCiAgIFxtYXRoYmZ7WH0gPSBcc3VtX3tpPTF9Xm4gXGRlbHRhX2kgXG1hdGhiZnt1fV9pIFxtYXRoYmZ7dn1faV5UID0gXHN1bV97aT0xfV5wIFxkZWx0YV9pIFxtYXRoYmZ7dX1faSBcbWF0aGJme3Z9X2leVCAgPSBcbWF0aGJme1V9XGJvbGRzeW1ib2x7XERlbHRhfSBcbWF0aGJme1Z9XlQgLApcXQp3aXRoCgotICRcZGVsdGFfe24rMX09XGRlbHRhX3tuKzJ9PSBcY2RvdHMgPSBcZGVsdGFfcD0wJAoKLSAkXGJvbGRzeW1ib2x7XERlbHRhfSQgYSAkcFx0aW1lcyBwJCBkaWFnb25hbCBtYXRyaXggb2YgdGhlICRcZGVsdGFfMSxcbGRvdHMsIFxkZWx0YV9wJAoKLSAgJFxtYXRoYmZ7VX0kIGFuICRuXHRpbWVzIHAkIG1hdHJpeCBhbmQgJFxtYXRoYmZ7Vn0kIGEgJHAgXHRpbWVzIHAkIG1hdHJpeC4gTm90ZSB0aGF0IG9ubHkgdGhlIGZpcnN0ICRuJCBjb2x1bW5zIG9mICRcbWF0aGJme1V9JCBhbmQgJFxtYXRoYmZ7Vn0kIGFyZSBpbmZvcm1hdGl2ZS4KCldpdGggdGhlIFNWRCBvZiAkXG1hdGhiZntYfSQgd2Ugd3JpdGUKIFxbCiAgIFxtYXRoYmZ7WH1eVFxtYXRoYmZ7WH0gPSBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhCiAgICAgfV4yXG1hdGhiZntWfV5ULgogXF0KIFRoZSBpbnZlcnNlIG9mICRcbWF0aGJme1h9XlRcbWF0aGJme1h9JCBpcyB0aGVuIGdpdmVuIGJ5CiBcWwogICAoXG1hdGhiZntYfV5UXG1hdGhiZntYfSleey0xfSA9IFxtYXRoYmZ7Vn1cYm9sZHN5bWJvbHtcRGVsdGF9XnstMn1cbWF0aGJme1Z9XlQuCiBcXQogU2luY2UgJFxib2xkc3ltYm9se1xEZWx0YX0kIGhhcyAkXGRlbHRhX3tuKzF9PVxkZWx0YV97bisyfT0gXGNkb3RzID0gXGRlbHRhX3A9MCQsIGl0IGlzIG5vdCBpbnZlcnRpYmxlLgoKIyMjIFNWRCBvZiBwZW5hbGlzZWQgbWF0cml4ICRcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSQKCkl0IGNhbiBiZSBzaG93biB0aGF0ClxbCiAgXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0gPSBcbWF0aGJme1Z9IChcYm9sZHN5bWJvbHtcRGVsdGF9XjIrXGxhbWJkYSBcbWF0aGJme0l9KSBcbWF0aGJme1Z9XlQgLApcXQppLmUuIGFkZGluZyBhIGNvbnN0YW50IHRvIHRoZSBkaWFnb25hbCBlbGVtZW50cyBkb2VzIG5vdCBhZmZlY3QgdGhlIGVpZ2VudmVjdG9ycywgYW5kIGFsbCBlaWdlbnZhbHVlcyBhcmUgaW5jcmVhc2VkIGJ5IHRoaXMgY29uc3RhbnQuCiRcbG9uZ3JpZ2h0YXJyb3ckIHplcm8gZWlnZW52YWx1ZXMgYmVjb21lICRcbGFtYmRhJC4KCkhlbmNlLApcWwogIChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSA9IFxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntWfV5UICwKXF0Kd2hpY2ggY2FuIGJlIGNvbXB1dGVkIGV2ZW4gd2hlbiBzb21lIGVpZ2VudmFsdWVzIGluICRcYm9sZHN5bWJvbHtcRGVsdGF9XjIkIGFyZSB6ZXJvLgoKTm90ZSwgdGhhdCBmb3IgaGlnaCBkaW1lbnNpb25hbCBkYXRhICgkcD4+Pm4kKSBtYW55IGVpZ2VudmFsdWVzIGFyZSB6ZXJvIGJlY2F1c2UgJFxtYXRoYmZ7WF5UWH0kIGlzIGEgJHAgXHRpbWVzIHAkIG1hdHJpeCBhbmQgaGFzIHJhbmsgJG4kLgoKVGhlIGlkZW50aXR5ICRcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSA9IFxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pIFxtYXRoYmZ7Vn1eVCQgaXMgZWFzaWx5IGNoZWNrZWQ6ClxbCiAgXG1hdGhiZntWfSAoXGJvbGRzeW1ib2x7XERlbHRhfV4yK1xsYW1iZGEgXG1hdGhiZntJfSkgXG1hdGhiZntWfV5UID0gXG1hdGhiZntWfVxib2xkc3ltYm9se1xEZWx0YX1eMlxtYXRoYmZ7Vn1eVCArIFxsYW1iZGEgXG1hdGhiZntWVn1eVCAgPSBcbWF0aGJme1Z9XGJvbGRzeW1ib2x7XERlbHRhfV4yXG1hdGhiZntWfV5UICsgXGxhbWJkYSBcbWF0aGJme0l9ID0gXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0uClxdCgoKIyMgUHJvcGVydGllcwoKLSBUaGUgUmlkZ2UgZXN0aW1hdG9yIGlzIGJpYXNlZCEgVGhlICRcYm9sZHN5bWJvbHtcYmV0YX0kIGFyZSBzaHJ1bmtlbiB0byB6ZXJvIQpcYmVnaW57ZXFuYXJyYXl9CiBcdGV4dHtFfVtcaGF0e1xib2xkc3ltYm9se1xiZXRhfX1dICY9JiAoXG1hdGhiZntYXlRYfStcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntYfV5UIFx0ZXh0e0V9W1xtYXRoYmZ7WX1dXFwKJj0mIChcbWF0aGJme1h9XlRcbWF0aGJme1h9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSBcbWF0aGJme1h9XlQgXG1hdGhiZntYfVxib2xkc3ltYm9se1xiZXRhfVxcClxlbmR7ZXFuYXJyYXl9CgotIE5vdGUsIHRoYXQgdGhlIHNocmlua2FnZSBpcyBsYXJnZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlciBlaWdlbnZhbHVlcy4KClxiZWdpbntlcW5hcnJheX0KXHRleHR7RX1bXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19XSY9JlxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXG1hdGhiZntWfV5UIFxtYXRoYmZ7Vn0gXGJvbGRzeW1ib2x7XERlbHRhfV4yIFxtYXRoYmZ7Vn1eVFxib2xkc3ltYm9se1xiZXRhfVxcCiY9JlxtYXRoYmZ7Vn0gKFxib2xkc3ltYm9se1xEZWx0YX1eMitcbGFtYmRhIFxtYXRoYmZ7SX0pXnstMX0gXGJvbGRzeW1ib2x7XERlbHRhfV4yIFxtYXRoYmZ7Vn1eVFxib2xkc3ltYm9se1xiZXRhfVxcCiY9JiBcbWF0aGJme1Z9ClxsZWZ0W1xiZWdpbnthcnJheX17Y2NjfQpcZnJhY3tcZGVsdGFfMV4yfXtcZGVsdGFfMV4yK1xsYW1iZGF9JlxsZG90cyYwIFxcCiZcdmRvdHMmXFwKMCZcbGRvdHMmXGZyYWN7XGRlbHRhX3JeMn17XGRlbHRhX3JeMitcbGFtYmRhfQpcZW5ke2FycmF5fVxyaWdodF0KXG1hdGhiZntWfV5UXGJvbGRzeW1ib2x7XGJldGF9ClxlbmR7ZXFuYXJyYXl9CgotICB0aGUgdmFyaWFuY2Ugb2YgdGhlIHByZWRpY3Rpb24gJFxoYXR7e1l9fShcbWF0aGJme3h9KT1cbWF0aGJme3h9XlRcaGF0XGJldGEkLAogIFxbCiAgICBcdGV4dHt2YXJ9XGxlZnRbXGhhdHt7WX19KFxtYXRoYmZ7eH0pXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSA9IFxtYXRoYmZ7eH1eVChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfVxtYXRoYmZ7eH0KICBcXQogIGlzIHNtYWxsZXIgdGhhbiB3aXRoIHRoZSBsZWFzdC1zcXVhcmVzIGVzdGltYXRvci4KCi0gIHRocm91Z2ggdGhlIGJpYXMtdmFyaWFuY2UgdHJhZGUtb2ZmIGl0IGlzIGhvcGVkIHRoYXQgYmV0dGVyIHByZWRpY3Rpb25zIGluIHRlcm1zIG9mIGV4cGVjdGVkIGNvbmRpdGlvbmFsIHRlc3QgZXJyb3IgY2FuIGJlIG9idGFpbmVkLCBmb3IgYW4gYXBwcm9wcmlhdGUgY2hvaWNlIG9mICRcbGFtYmRhJC4KCgpSZWNhbGwgdGhlIGV4cHJlc3Npb24gb2YgdGhlIGV4cGVjdGVkIGNvbmRpdGlvbmFsIHRlc3QgZXJyb3IKXGJlZ2lue2VxbmFycmF5fQogIEVycihcbWF0aGJme3h9KSAmPSYgXHRleHR7RX1cbGVmdFsoXGhhdHtZfSAtIFleKileMlxtaWQgXG1hdGhiZnt4fVxyaWdodF1cXAogICY9JgogIFx0ZXh0e3Zhcn1cbGVmdFtcaGF0e1l9XG1pZCBcbWF0aGJme3h9XHJpZ2h0XSArIFx0ZXh0e2JpYXN9XjIoXG1hdGhiZnt4fSkrCiAgXHRleHR7dmFyfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0KXGVuZHtlcW5hcnJheX0Kd2hlcmUKCi0gJFxoYXR7WX09XGhhdHtZfShcbWF0aGJme3h9KT1cbWF0aGJme3h9XlRcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0kIGlzIHRoZSBwcmVkaWN0aW9uIGF0ICRcbWF0aGJme3h9JAotICRZXiokIGlzIGFuIG91dGNvbWUgYXQgcHJlZGljdG9yICRcbWF0aGJme3h9JAotICRcbXUoXG1hdGhiZnt4fSkgPSBcdGV4dHtFfVxsZWZ0W1xoYXR7WX1cbWlkIFxtYXRoYmZ7eH1ccmlnaHRdIFx0ZXh0eyBhbmQgfSBcbXVeKih4KT1cdGV4dHtFfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0kCi0gJFx0ZXh0e2JpYXN9KFxtYXRoYmZ7eH0pPVxtdShcbWF0aGJme3h9KS1cbXVeKihcbWF0aGJme3h9KSQKLSAkXHRleHR7dmFyfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0kIHRoZSBpcnJlZHVjaWJsZSBlcnJvciB0aGF0IGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgbW9kZWwuIEl0IHNpbXBseSBvcmlnaW5hdGVzIGZyb20gb2JzZXJ2YXRpb25zIHRoYXQgcmFuZG9tbHkgZmx1Y3R1YXRlIGFyb3VuZCB0aGUgdHJ1ZSBtZWFuICRcbXVeKih4KSQuCgojIyBUb3hpY29nZW5vbWljcyBleGFtcGxlCgpgYGB7cn0KbGlicmFyeShnbG1uZXQpCm1SaWRnZSA8LSBnbG1uZXQoCiAgeCA9IHRveERhdGFbLC0xXSAlPiUKICAgIGFzLm1hdHJpeCwKICB5ID0gdG94RGF0YSAlPiUKICAgIHB1bGwoQkEpLAogIGFscGhhID0gMCkgIyByaWRnZTogYWxwaGEgPSAwCgpwbG90KG1SaWRnZSwgeHZhcj0ibGFtYmRhIikKYGBgCgoKVGhlIFIgZnVuY3Rpb24gXHRleHRzZntnbG1uZXR9IHVzZXMgXHRleHRzZntsYW1iZGF9IHRvIHJlZmVyIHRvIHRoZSBwZW5hbHR5IHBhcmFtZXRlci4gSW4gdGhpcyBjb3Vyc2Ugd2UgdXNlICRcbGFtYmRhJCwgYmVjYXVzZSAkXGxhbWJkYSQgaXMgb2Z0ZW4gdXNlZCBhcyBlaWdlbnZhbHVlcy4KClRoZSBncmFwaCBzaG93cyB0aGF0IHdpdGggaW5jcmVhc2luZyBwZW5hbHR5IHBhcmFtZXRlciwgdGhlIHBhcmFtZXRlciBlc3RpbWF0ZXMgYXJlIHNocnVua2VuIHRvd2FyZHMgemVyby4gVGhlIGVzdGltYXRlcyB3aWxsIG9ubHkgcmVhY2ggemVybyBmb3IgJFxsYW1iZGEgXHJpZ2h0YXJyb3cgXGluZnR5JC4gVGhlIHN0cm9uZ2VyIHRoZSBzaHJpbmthZ2UsIHRoZSBsYXJnZXIgdGhlIGJpYXMgKHRvd2FyZHMgemVybykgYW5kIHRoZSBzbWFsbGVyIHRoZSB2YXJpYW5jZSBvZiB0aGUgcGFyYW1ldGVyIGVzdGltYXRvcnMgKGFuZCBoZW5jZSBhbHNvIHNtYWxsZXIgdmFyaWFuY2Ugb2YgdGhlIHByZWRpY3Rpb25zKS4KCkFub3RoZXIgKGluZm9ybWFsKSB2aWV3cG9pbnQgaXMgdGhlIGZvbGxvd2luZy4gQnkgc2hyaW5raW5nIHRoZSBlc3RpbWF0ZXMgdG93YXJkcyB6ZXJvLCB0aGUgZXN0aW1hdGVzIGxvb3NlIHNvbWUgb2YgdGhlaXIgYGBkZWdyZWVzIG9mIGZyZWVkb20nJyBzbyB0aGF0IHRoZSBwYXJhbWV0ZXJzIGJlY29tZSBlc3RpbWFibGUgd2l0aCBvbmx5ICRuPHAkIGRhdGEgcG9pbnRzLiBFdmVuIHdpdGggYSB2ZXJ5IHNtYWxsICRcbGFtYmRhPjAkLCB0aGUgcGFyYW1ldGVycyByZWdhaW4gdGhlaXIgZXN0aW1hYmlsaXR5LiBIb3dldmVyLCBub3RlIHRoYXQgdGhlIHZhcmlhbmNlIG9mIHRoZSBlc3RpbWF0b3IgaXMgZ2l2ZW4gYnkKXFsKICBcdGV4dHt2YXJ9XGxlZnRbXGhhdHtcbWF0aGJmXGJldGF9XHJpZ2h0XSA9IChcbWF0aGJme1heVFh9K1xsYW1iZGEgXG1hdGhiZntJfSleey0xfSBcc2lnbWFeMiA9IFxtYXRoYmZ7Vn0oXGJvbGRzeW1ib2x7XERlbHRhfV4yK1xsYW1iZGFcbWF0aGJme0l9KV57LTF9XG1hdGhiZntWfV5UXHNpZ21hXjIuClxdCkhlbmNlLCBhIHNtYWxsICRcbGFtYmRhJCB3aWxsIHJlc3VsdCBpbiBsYXJnZSB2YXJpYW5jZXMgb2YgdGhlIHBhcmFtZXRlciBlc3RpbWF0b3JzLiBUaGUgbGFyZ2VyICRcbGFtYmRhJCwgdGhlIHNtYWxsZXIgdGhlIHZhcmlhbmNlcyBiZWNvbWUuIEluIHRoZSBsaW1pdCwgYXMgJFxsYW1iZGFccmlnaHRhcnJvd1xpbmZ0eSQsIHRoZSBlc3RpbWF0ZXMgYXJlIGNvbnZlcmdlZCB0byB6ZXJvIGFuZCBzaG93IG5vIHZhcmlhYmlsaXR5IGFueSBsb25nZXIuCgojIExhc3NvIFJlZ3Jlc3Npb24KCi0gVGhlIExhc3NvIGlzIGFub3RoZXIgZXhhbXBsZSBvZiBwZW5hbGlzZWQgcmVncmVzc2lvbi4KCi0gVGhlIGxhc3NvIGVzdGltYXRvciBvZiAkXGJvbGRzeW1ib2x7XGJldGF9JCBpcyB0aGUgc29sdXRpb24gdG8gbWluaW1pc2luZyB0aGUgcGVuYWxpc2VkIFNTRQpcWwogXHRleHR7U1NFfV9cdGV4dHtwZW59ID0gXHN1bV97aT0xfV5uIChZX2kgLSBcbWF0aGJme3h9X2leVFxib2xkc3ltYm9se1xiZXRhfSleMiArIFxsYW1iZGEgXHN1bV97aj0xfV5wIFx2ZXJ0IFxiZXRhX2pcdmVydC4KXF0KCgpvciwgZXF1aXZhbGVudGx5LCBtaW5pbWlzaW5nCgpcWwpcdGV4dHtTU0V9ICA9IFxWZXJ0IFxtYXRoYmZ7WX0gLSBcbWF0aGJme1hcYmV0YX1cVmVydF8yXjIgXHRleHR7IHN1YmplY3QgdG8gfSBcVmVydCBcbWF0aGJmXGJldGFcVmVydF8xIFxsZXEgYwpcXQp3aXRoCgotICRcVmVydCBcbWF0aGJmXGJldGFcVmVydF8xID0gXHN1bVxsaW1pdHNfe2o9MX1ecCBcdmVydCBcYmV0YV9qIFx2ZXJ0JAoKLSBEZXNwaXRlIHN0cm9uZyBzaW1pbGFyaXR5IGJldHdlZW4gcmlkZ2UgYW5kIGxhc3NvIHJlZ3Jlc3Npb24gKCRMXzIkIHZlcnN1cyAkTF8xJCBub3JtIGluIHBlbmFsdHkgdGVybSksIHRoZXJlIGlzIG5vIGFuYWx5dGljYWwgc29sdXRpb24gb2YgdGhlIGxhc3NvIHBhcmFtZXRlciBlc3RpbWF0b3Igb2YgJFxtYXRoYmZcYmV0YSQuCgotIEZvcnR1bmF0ZWx5LCBjb21wdXRhdGlvbmFsIGVmZmljaWVudCBhbGdvcml0aG1zIGhhdmUgYmVlbiBpbXBsZW1lbnRlZCBpbiBzdGF0aXN0aWNhbCBzb2Z0d2FyZQoKLSBUaGUgTGFzc28gZXN0aW1hdG9yIG9mICRcYm9sZHN5bWJvbHtcYmV0YX0kIGlzIGJpYXNlZCBhbmQgZ2VuZXJhbGx5IGhhcyBhIHNtYWxsZXIgdmFyaWFuY2UgdGhlbiB0aGUgbGVhc3Qtc3F1YXJlcyBlc3RpbWF0b3IuCgotIEhlbmNlLCB0aGUgYmlhcy12YXJpYW5jZSB0cmFkZS1vZmYgbWF5IGhlcmUgYWxzbyBoZWxwIGluIGZpbmRpbmcgYmV0dGVyIHByZWRpY3Rpb25zIHdpdGggYmlhc2VkIGVzdGltYXRvcnMuCgotIEluIGNvbnRyYXN0IHRvIHJpZGdlIHJlZ3Jlc3Npb24sIGhvd2V2ZXIsIHRoZSBsYXNzbyBlc3RpbWF0b3IgY2FuIGdpdmUgYXQgbW9zdCAkXG1pbihwLG4pJCBub24temVybyAkXGJldGEkLWVzdGltYXRlcy4KCi0gSGVuY2UsIGF0IGZpcnN0IHNpZ2h0IHRoZSBsYXNzbyBpcyBub3QgZGlyZWN0bHkgYXBwcm9wcmlhdGUgZm9yIGhpZ2gtZGltZW5zaW9uYWwgc2V0dGluZ3MuCgotIEFuIGltcG9ydGFudCBhZHZhbnRhZ2Ugb2YgdGhlIGxhc3NvIGlzIHRoYXQgY2hvb3NpbmcgYW4gYXBwcm9wcmlhdGUgdmFsdWUgZm9yICRcbGFtYmRhJCBpcyBhIGtpbmQgYSBtb2RlbCBidWlsZGluZyBvciBmZWF0dXJlIHNlbGVjdGlvbiBwcm9jZWR1cmUgKHNlZSBmdXJ0aGVyKS4KCiMjIEdyYXBoaWNhbCBpbnRlcnByZXRhdGlvbiBvZiBMYXNzbyB2cyByaWRnZQoKTm90ZSB0aGF0IHRoZSBsYXNzbyBpcyBhIGNvbnN0cmFpbmVkIHJlZ3Jlc3Npb24gcHJvYmxlbSB3aXRoCgpcWwpcVmVydCBcbWF0aGJme1l9IC0gXG1hdGhiZntYXGJldGF9XFZlcnRfMl4yIFx0ZXh0eyBzdWJqZWN0IHRvIH0gXFZlcnQgXG1hdGhiZlxiZXRhXFZlcnRfMSBcbGVxIGMKXF0KYW5kIHJpZGdlClxbClxWZXJ0IFxtYXRoYmZ7WX0gLSBcbWF0aGJme1hcYmV0YX1cVmVydF8yXjIgXHRleHR7IHN1YmplY3QgdG8gfSBcVmVydCBcbWF0aGJmXGJldGFcVmVydF4yXzIgXGxlcSBjClxdCgpgYGB7ciBlY2hvID0gRkFMU0UsIHdhcm5pbmcgPSBGQUxTRSwgbWVzc2FnZSA9IEZBTFNFfQpwTGFzc28gPC0gcDEgKwogIGdlb21fc2VnbWVudChhZXMoeCA9IDAsIHkgPSA0LjIgLCB4ZW5kID0gNC4yLCB5ZW5kID0gMCksIGNvbG9yID0gInJlZCIpICsKICBnZW9tX3NlZ21lbnQoYWVzKHggPSAwLCB5ID0gNC4yICwgeGVuZCA9IC0gNC4yLCB5ZW5kID0gMCksIGNvbG9yID0gInJlZCIpICsKICBnZW9tX3NlZ21lbnQoYWVzKHggPSA0LjIsIHkgPSAwICwgeGVuZCA9IDAsIHllbmQgPSAtNC4yKSwgY29sb3IgPSAicmVkIikgKwogIGdlb21fc2VnbWVudChhZXMoeCA9IDAsIHkgPSAtIDQuMiAsIHhlbmQgPSAtIDQuMiwgeWVuZCA9IDApLCBjb2xvciA9ICJyZWQiKSArCiAgZ2VvbV9wb2ludChhZXMoeCA9IDAsIHkgPSA0LjIpLCBjb2xvciA9ICJyZWQiKSArCiAgYW5ub3RhdGUoInRleHQiLCBsYWJlbCA9IFRlWCgiJChcXGhhdHtcXGJldGF9XzFee2xhc3NvfSwgXFxoYXR7XFxiZXRhfV8yXntsYXNzb30pJCIpLCB4ID0gNywgeSA9IDQuMiwgc2l6ZSA9IDYsIHBhcnNlID0gVFJVRSwgY29sb3IgPSAicmVkIikgKwogIGdndGl0bGUoIkxhc3NvIikgKwogIGdlb21fdmxpbmUoeGludGVyY2VwdCA9IDAsIGNvbG9yID0gImdyZXkiKSArCiAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gMCwgY29sb3IgPSAiZ3JleSIpICsKICB0aGVtZV9taW5pbWFsKCkKCmdyaWQuYXJyYW5nZShwTGFzc28sIHBSaWRnZSwgbmNvbCA9IDIpCmBgYAoKTm90ZSwgdGhhdAoKLSBwYXJhbWV0ZXJzIGZvciB0aGUgbGFzc28gY2FuIG5ldmVyIHN3aXRjaCBzaWduLCB0aGV5IGFyZSBzZXQgYXQgemVybyEgU2VsZWN0aW9uIQotIHJpZGdlIHJlZ3Jlc3Npb24gY2FuIGxlYWQgdG8gcGFyYW1ldGVycyB0aGF0IHN3aXRjaCBzaWduLgoKIyMgVG94aWNvZ2Vub21pY3MgZXhhbXBsZQoKYGBge3J9Cm1MYXNzbyA8LSBnbG1uZXQoCiAgeCA9IHRveERhdGFbLC0xXSAlPiUKICAgIGFzLm1hdHJpeCwKICB5ID0gdG94RGF0YSAlPiUKICAgIHB1bGwoQkEpLAphbHBoYSA9IDEpCnBsb3QobUxhc3NvLCB4dmFyID0gImxhbWJkYSIpCmBgYAoKLSBUaGUgZ3JhcGggd2l0aCB0aGUgcGF0aHMgb2YgdGhlIHBhcmFtZXRlciBlc3RpbWF0ZXMgbmljZWx5IGlsbHVzdHJhdGVzIHRoZSB0eXBpY2FsIGJlaGF2aW91ciBvZiB0aGUgbGFzc28gZXN0aW1hdGVzIGFzIGEgZnVuY3Rpb24gb2YgJFxsYW1iZGEkOiB3aGVuICRcbGFtYmRhJCBpbmNyZWFzZXMgdGhlIGVzdGltYXRlcyBhcmUgc2hydW5rZW4gdG93YXJkcyB6ZXJvLgoKLSBXaGVuIGFuIGVzdGltYXRlIGhpdHMgemVybywgaXQgcmVtYWlucyBleGFjdGx5IGVxdWFsIHRvIHplcm8gd2hlbiAkXGdhbW1hJCBmdXJ0aGVyIGluY3JlYXNlcy4gQSBwYXJhbWV0ZXIgZXN0aW1hdGUgZXF1YWwgdG8gemVybywgc2F5ICRcaGF0XGJldGFfaj0wJCwgaW1wbGllcyB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIHByZWRpY3RvciAkeF9qJCBpcyBubyBsb25nZXIgaW5jbHVkZWQgaW4gdGhlIG1vZGVsIChpLmUuICRcYmV0YV9qeF9qPTAkKS4KCi0gVGhlIG1vZGVsIGZpdCBpcyBrbm93biBhcyBhIHNwYXJzZSBtb2RlbCBmaXQgKG1hbnkgemVyb2VzKS4gSGVuY2UsIGNob29zaW5nIGEgYXBwcm9wcmlhdGUgdmFsdWUgZm9yICRcZ2FtbWEkIGlzIGxpa2UgY2hvb3NpbmcgdGhlIGltcG9ydGFudCBwcmVkaWN0b3JzIGluIHRoZSBtb2RlbCAoZmVhdHVyZSBzZWxlY3Rpb24pLgoKCiMgU3BsaW5lcyBhbmQgdGhlIGNvbm5lY3Rpb24gdG8gcmlkZ2UgcmVncmVzc2lvbi4KCiMjIExpZGFyIGRhdGFzZXQKCi0gTElEQVIgKGxpZ2h0IGRldGVjdGlvbiBhbmQgcmFuZ2luZykgdXNlcyB0aGUgcmVmbGVjdGlvbiBvZiBsYXNlci1lbWl0dGVkIGxpZ2h0IHRvIGRldGVjdCBjaGVtaWNhbCBjb21wb3VuZHMgaW4gdGhlIGF0bW9zcGhlcmUuCi0gVGhlIExJREFSIHRlY2huaXF1ZSBoYXMgcHJvdmVuIHRvIGJlIGFuIGVmZmljaWVudCB0b29sIGZvciBtb25pdG9yaW5nIHRoZSBkaXN0cmlidXRpb24gb2Ygc2V2ZXJhbCBhdG1vc3BoZXJpYyBwb2xsdXRhbnRzIG9mIGltcG9ydGFuY2U7IHNlZSBTaWdyaXN0ICgxOTk0KS4KLSBUaGUgcmFuZ2UgaXMgdGhlIGRpc3RhbmNlIHRyYXZlbGVkIGJlZm9yZSB0aGUgbGlnaHQgaXMgcmVmbGVjdGVkIGJhY2sgdG8gaXRzIHNvdXJjZS4KLSBUaGUgbG9ncmF0aW8gaXMgdGhlIGxvZ2FyaXRobSBvZiB0aGUgcmF0aW8gb2YgcmVjZWl2ZWQgbGlnaHQgZnJvbSB0d28gbGFzZXIgc291cmNlcy4KCiAgLSBPbmUgc291cmNlIGhhZCBhIGZyZXF1ZW5jeSBlcXVhbCB0byB0aGUgcmVzb25hbmNlIGZyZXF1ZW5jeSBvZiB0aGUgY29tcG91bmQgb2YgaW50ZXJlc3QsIHdoaWNoIHdhcyBtZXJjdXJ5IGluIHRoaXMgc3R1ZHkuCiAgLSBUaGUgb3RoZXIgc291cmNlIGhhZCBhIGZyZXF1ZW5jeSBvZmYgdGhpcyByZXNvbmFuY2UgZnJlcXVlbmN5LgoKICAtIFRoZSBjb25jZW50cmF0aW9uIG9mIG1lcmN1cnkgY2FuIGJlIGRlcml2ZWQgZnJvbSBhIHJlZ3Jlc3Npb24gbW9kZWwgb2YgdGhlIGxvZ3JhdGlvIGluIGZ1bmN0aW9uIG9mICB0aGUgcmFuZ2UgZm9yIGVhY2ggcmFuZ2UgeC4KCmBgYHtyfQpsaWJyYXJ5KCJTZW1pUGFyIikKZGF0YShsaWRhcikKcExpZGFyIDwtIGxpZGFyICU+JQogIGdncGxvdChhZXMoeCA9IHJhbmdlLCB5ID0gbG9ncmF0aW8pKSArCiAgZ2VvbV9wb2ludCgpICsKICB4bGFiKCJyYW5nZSAobSkiKQoKcExpZGFyICsKICBnZW9tX3Ntb290aCgpCmBgYAoKLSBUaGUgZGF0YSBpcyBub24tbGluZWFyCi0gTGluZWFyIHJlZ3Jlc3Npb24gd2lsbCBub3Qgd29yayEKLSBUaGUgZGF0YSBzaG93cyBhIHNtb290aCByZWxhdGlvbiBiZXR3ZWVuIHRoZSBsb2dyYXRpbyBhbmQgdGhlIHJhbmdlCgojIyBCYXNpcyBleHBhbnNpb24KClxbeV9pPWYoeF9pKStcZXBzaWxvbl9pLFxdCndpdGgKXFtmKHgpPVxzdW1cbGltaXRzX3trPTF9XksgXHRoZXRhX2sgYl9rKHgpXF0KCi0gIFNlbGVjdCBzZXQgb2YgYmFzaXMgZnVuY3Rpb25zICRiX2soeCkkCi0gIFNlbGVjdCBudW1iZXIgb2YgYmFzaXMgZnVuY3Rpb25zICRLJAotICBFeGFtcGxlcwoKICAgIC0gIFBvbHlub21pYWwgbW9kZWw6ICR4XmskCiAgICAtICBPcnRob2dvbmFsIHNlcmllczogRm91cmllciwgTGVnZW5kcmUgcG9seW5vbWlhbHMsIFdhdmVsZXRzCiAgICAtICBQb2x5bm9taWFsIHNwbGluZXM6ICQxLCB4LCAoeC10X20pXyskIHdpdGggJG09MSwgXGxkb3RzLCBLLTIkIGtub3RzICR0X20kCiAgICAtICAuLi4KCiMjIyBUcnVuY3RhdGVkIGxpbmUgYmFzaXMKClxbeV9pPWYoeF9pKStcZXBzaWxvbl9pLFxdCgotICBPbmUgb2YgdGhlIG1vc3Qgc2ltcGxlIGJhc2lzIGV4cGFuc2lvbnMKLSAgJGYoeF9pKT1cYmV0YV8wK1xiZXRhXzF4X2krXHN1bVxsaW1pdHNfe209MX1ee0stMn1cdGhldGFfbSh4X2ktdF9tKV8rJCB3aXRoICQoLilfKyQgdGhlIG9wZXJhdG9yIHRoYXQgdGFrZXMgdGhlIHBvc2l0aXZlIHBhcnQuCi0gIE5vdGUsIHRoYXQgYmV0dGVyIGJhc2lzIGV4cGFuc2lvbnMgZXhpc3QsIHdoaWNoIGFyZSBvcnRob2dvbmFsLCBjb21wdXRhdGlvbmFsIG1vcmUgc3RhYmxlIGFuZC9vciBjb250aW51b3VzIGRlcml2YXRpdmUgYmV5b25kIGZpcnN0IG9yZGVyCi0gIFdlIHdpbGwgdXNlIHRoaXMgYmFzaXMgZm9yIGRpZGFjdGljYWwgcHVycG9zZXMKLSBXZSBjYW4gdXNlIE9MUyB0byBmaXQgeSB3LnIudC4gdGhlIGJhc2lzLgoKYGBge3J9Cmtub3RzIDwtIHNlcSg0MDAsNzAwLDEyLjUpCgpiYXNpcyA8LSBzYXBwbHkoa25vdHMsCiAgZnVuY3Rpb24oayx5KSAoeS1rKSooeT5rKSwKICB5PSBsaWRhciAlPiUgcHVsbChyYW5nZSkKICApCgpiYXNpc0V4cCA8LSBjYmluZCgxLCByYW5nZSA9IGxpZGFyICU+JSBwdWxsKHJhbmdlKSwgYmFzaXMpCgpzcGxpbmVGaXRMcyA8LSBsbShsb2dyYXRpbyB+IC0xICsgYmFzaXNFeHAsIGxpZGFyKQoKcEJhc2lzIDwtIGJhc2lzRXhwWywtMV0gJT4lCiAgZGF0YS5mcmFtZSAlPiUKICBnYXRoZXIoImJhc2lzIiwidmFsdWVzIiwtMSkgJT4lCiAgZ2dwbG90KGFlcyh4ID0gcmFuZ2UsIHkgPSB2YWx1ZXMsIGNvbG9yID0gYmFzaXMpKSArCiAgZ2VvbV9saW5lKCkgKwogIHRoZW1lKGxlZ2VuZC5wb3NpdGlvbj0ibm9uZSIpICsKICB5bGFiKCJiYXNpcyIpCgpncmlkLmFycmFuZ2UoCiAgcExpZGFyICsKICAgIGdlb21fbGluZShhZXMoeCA9IGxpZGFyJHJhbmdlLCB5ID0gc3BsaW5lRml0THMkZml0dGVkKSwgbHdkID0gMiksCiAgcEJhc2lzLAogIG5jb2w9MSkKYGBgCgotIE5vdGUsIHRoYXQgdGhlIG1vZGVsIGlzIG92ZXJmaXR0aW5nIQotIFRoZSBmaXQgaXMgdmVyeSB3aWdnbHkgYW5kIGlzIHR1bmVkIHRvbyBtdWNoIHRvIHRoZSBkYXRhLgotIFRoZSBmaXQgaGFzIGEgbGFyZ2UgdmFyaWFuY2UgYW5kIGxvdyBiaWFzLgotIEl0IHdpbGwgdGhlcmVmb3JlIG5vdCBnZW5lcmFsaXNlIHdlbGwgdG8gcHJlZGljdCB0aGUgbG9ncmF0aW8gb2YgZnV0dXJlIG9ic2VydmF0aW9ucy4KCiMjIyMgU29sdXRpb24gZm9yIG92ZXJmaXR0aW5nPwoKLSBXZSBjb3VsZCBwZXJmb3JtIG1vZGVsIHNlbGVjdGlvbiBvbiB0aGUgYmFzaXMgdG8gc2VsZWN0IHRoZSBpbXBvcnRhbnQgYmFzaXMgZnVuY3Rpb25zIHRvIG1vZGVsIHRoZSBzaWduYWwuIEJ1dCwgdGhpcyB3aWxsIGhhdmUgdGhlIHVuZGVzaXJlZCBwcm9wZXJ0eSB0aGF0IHRoZSBmaXQgd2lsbCBubyBsb25nZXIgYmUgc21vb3RoLgoKLSBXZSBjYW4gYWxzbyBhZG9wdCBhIHJpZGdlIHBlbmFsdHkhCi0gSG93ZXZlciwgd2UgZG8gbm90IHdhbnQgdG8gcGVuYWxpc2UgdGhlIGludGVyY2VwdCBhbmQgdGhlIGxpbmVhciB0ZXJtLgotIFJpZGdlIGNyaXRlcmlvbgoKXFtcVmVydFxtYXRoYmZ7WX0tXG1hdGhiZntYXGJldGF9XFZlcnReMitcbGFtYmRhXGJvbGRzeW1ib2x7XGJldGF9XlRcbWF0aGJme0R9XGJvbGRzeW1ib2x7XGJldGF9ClxdCgpXaXRoICRcbWF0aGJme0R9JCB3aXRoIGRpbWVuc2lvbnMgKEssSyk6ICRcbWF0aGJme0R9PVxsZWZ0W1xiZWdpbnthcnJheX17Y2N9XG1hdGhiZnswfV97Mlx0aW1lczJ9JiBcbWF0aGJmezB9X3syXHRpbWVzIEstMn1cXApcbWF0aGJmezB9X3tLLTJcdGltZXMyfSZcbWF0aGJme0l9X3tLLTJcdGltZXMgSy0yfVxlbmR7YXJyYXl9XHJpZ2h0XSQKCi0gSGVyZSB3ZSB3aWxsIHNldCB0aGUgcGVuYWx0eSBhdCA5MDAuCgpgYGB7cn0KRCA8LSBkaWFnKG5jb2woYmFzaXNFeHApKQpEWzE6MiwxOjJdIDwtIDAKbGFtYmRhIDwtIDkwMApiZXRhUmlkZ2UgPC0gc29sdmUodChiYXNpc0V4cCklKiViYXNpc0V4cCsobGFtYmRhKkQpKSUqJXQoYmFzaXNFeHApJSolbGlkYXIkbG9ncmF0aW8KZ3JpZC5hcnJhbmdlKAogIHBMaWRhciArCiAgICBnZW9tX2xpbmUoYWVzKHggPSBsaWRhciRyYW5nZSwgeSA9IGMoYmFzaXNFeHAgJSolIGJldGFSaWRnZSkpLCBsd2QgPSAyKSwKICBwQmFzaXMsCiAgbmNvbD0xKQpgYGAKCkhvdyBkbyB3ZSBjaG9vc2UgJFxsYW1iZGEkPwoKLS0tCgojIEV2YWx1YXRpb24gb2YgUHJlZGljdGlvbiBNb2RlbHMKCgpQcmVkaWN0aW9ucyBhcmUgY2FsY3VsYXRlZCB3aXRoIHRoZSBmaXR0ZWQgbW9kZWwKIFxbCiAgIFxoYXR7WX0oXG1hdGhiZnt4fSkgPSBcaGF0e219KFxtYXRoYmZ7eH0pPVxtYXRoYmZ7eH1eVFxoYXR7XGJldGF9CiBcXQogd2hlbiBmb2N1c3Npbmcgb24gcHJlZGljdGlvbiwgd2Ugd2FudCB0aGUgcHJlZGljdGlvbiBlcnJvciB0byBiZSBhcyBzbWFsbCBhcyBwb3NzaWJsZS4KClRoZSAqKnByZWRpY3Rpb24gZXJyb3IqKiBmb3IgYSBwcmVkaWN0aW9uIGF0IGNvdmFyaWF0ZSBwYXR0ZXJuICRcbWF0aGJme3h9JCBpcyBnaXZlbiBieQogIFxbCiAgICAgXGhhdHtZfShcbWF0aGJme3h9KSAtIFleKiwKICBcXQp3aGVyZQoKLSAkXGhhdHtZfShcbWF0aGJme3h9KT1cbWF0aGJme3h9XlRcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0kIGlzIHRoZSBwcmVkaWN0aW9uIGF0ICRcbWF0aGJme3h9JAoKLSAgJFleKiQgaXMgYW4gb3V0Y29tZSBhdCBjb3ZhcmlhdGUgcGF0dGVybiAkXG1hdGhiZnt4fSQKClByZWRpY3Rpb24gaXMgdHlwaWNhbGx5IHVzZWQgdG8gcHJlZGljdCBhbiBvdXRjb21lIGJlZm9yZSBpdCBpcyBvYnNlcnZlZC4KCi0gSGVuY2UsIHRoZSBvdXRjb21lICRZXiokIGlzIG5vdCBvYnNlcnZlZCB5ZXQsIGFuZAotIHRoZSBwcmVkaWN0aW9uIGVycm9yIGNhbm5vdCBiZSBjb21wdXRlZC4KCi0tLQoKLSBSZWNhbGwgdGhhdCB0aGUgcHJlZGljdGlvbiBtb2RlbCAkXGhhdHtZfShcbWF0aGJme3h9KSQgaXMgZXN0aW1hdGVkIGJ5IHVzaW5nIGRhdGEgaW4gdGhlIHRyYWluaW5nIGRhdGEgc2V0ICQoXG1hdGhiZntYfSxcbWF0aGJme1l9KSQsIGFuZAotIHRoYXQgdGhlIG91dGNvbWUgJFleKiQgaXMgYW4gb3V0Y29tZSBhdCAkXG1hdGhiZnt4fSQgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBpbmRlcGVuZGVudCBvZiB0aGUgdHJhaW5pbmcgZGF0YS4KCi0gR29hbCBpcyB0byB1c2UgcHJlZGljdGlvbiBtb2RlbCBmb3IgcHJlZGljdGluZyBhIGZ1dHVyZSBvYnNlcnZhdGlvbiAoJFleKiQpLCBpLmUuIGFuIG9ic2VydmF0aW9uIHRoYXQgc3RpbGwgaGFzIHRvIGJlIHJlYWxpc2VkL29ic2VydmVkIChvdGhlcndpc2UgcHJlZGljdGlvbiBzZWVtcyByYXRoZXIgdXNlbGVzcykuCgotIEhlbmNlLCAkWV4qJCBjYW4gbmV2ZXIgYmUgcGFydCBvZiB0aGUgdHJhaW5pbmcgZGF0YSBzZXQuCgotLS0KCkhlcmUgd2UgcHJvdmlkZSBkZWZpbml0aW9ucyBhbmQgd2Ugc2hvdyBob3cgdGhlIHByZWRpY3Rpb24gcGVyZm9ybWFuY2Ugb2YgYSBwcmVkaWN0aW9uIG1vZGVsIGNhbiBiZSBldmFsdWF0ZWQgZnJvbSBkYXRhLgoKTGV0ICR7XG1hdGhjYWx7VH19PShcbWF0aGJme1l9LFxtYXRoYmZ7WH0pJCBkZW5vdGUgdGhlIHRyYWluaW5nIGRhdGEsIGZyb20gd2hpY2ggdGhlIHByZWRpY3Rpb24gbW9kZWwgJFxoYXR7WX0oXGNkb3QpJCBpcyBidWlsZC4gVGhpcyBidWlsZGluZyBwcm9jZXNzIHR5cGljYWxseSBpbnZvbHZlcyBmZWF0dXJlIHNlbGVjdGlvbiBhbmQgcGFyYW1ldGVyIGVzdGltYXRpb24uCgogV2Ugd2lsbCB1c2UgYSBtb3JlIGdlbmVyYWwgbm90YXRpb24gZm9yIHRoZSBwcmVkaWN0aW9uIG1vZGVsOiAkXGhhdHttfShcbWF0aGJme3h9KT1caGF0e1l9KFxtYXRoYmZ7eH0pJC4KCi0tLQoKIyMgVGVzdCBvciBHZW5lcmFsaXNhdGlvbiBFcnJvcgoKIFRoZSB0ZXN0IG9yIGdlbmVyYWxpc2F0aW9uIGVycm9yIGZvciBwcmVkaWN0aW9uIG1vZGVsICRcaGF0e219KFxjZG90KSQgaXMgZ2l2ZW4gYnkKICBcWwogICAgXHRleHR7RXJyfV97XG1hdGhjYWx7VH19ID0gXHRleHR7RX1fe1leKixYXip9XGxlZnRbKFxoYXR7bX0oXG1hdGhiZntYfV4qKSAtIFleKileMlxtaWQge1xtYXRoY2Fse1R9fVxyaWdodF0KICBcXQogIHdoZXJlICQoWV4qLFheKikkIGlzIGluZGVwZW5kZW50IG9mIHRoZSB0cmFpbmluZyBkYXRhLgoKLS0tCgotIE5vdGUgdGhhdCB0aGUgdGVzdCBlcnJvciBpcyBjb25kaXRpb25hbCBvbiB0aGUgdHJhaW5pbmcgZGF0YSAke1xtYXRoY2Fse1R9fSQuCi0gSGVuY2UsIHRoZSB0ZXN0IGVycm9yIGV2YWx1YXRlcyB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIHNpbmdsZSBtb2RlbCBidWlsZCBmcm9tIHRoZSBvYnNlcnZlZCB0cmFpbmluZyBkYXRhLgotIFRoaXMgaXMgdGhlIHVsdGltYXRlIHRhcmdldCBvZiB0aGUgbW9kZWwgYXNzZXNzbWVudCwgYmVjYXVzZSBpdCBpcyBleGFjdGx5IHRoaXMgcHJlZGljdGlvbiBtb2RlbCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBwcmFjdGljZSBhbmQgYXBwbGllZCB0byBmdXR1cmUgcHJlZGljdG9ycyAkXG1hdGhiZntYfV4qJCB0byBwcmVkaWN0ICRZXiokLgotIFRoZSB0ZXN0IGVycm9yIGlzIGRlZmluZWQgYXMgYW4gYXZlcmFnZSBvdmVyIGFsbCBzdWNoIGZ1dHVyZSBvYnNlcnZhdGlvbnMgJChZXiosXG1hdGhiZntYfV4qKSQuCgotLS0KCiMjIENvbmRpdGlvbmFsIHRlc3QgZXJyb3IKClNvbWV0aW1lcyB0aGUgY29uZGl0aW9uYWwgdGVzdCBlcnJvciBpcyB1c2VkOgoKVGhlIGNvbmRpdGlvbmFsIHRlc3QgZXJyb3IgaW4gJFxtYXRoYmZ7eH0kIGZvciBwcmVkaWN0aW9uIG1vZGVsICRcaGF0e219KFxtYXRoYmZ7eH0pJCBpcyBnaXZlbiBieQogXFsKICAgXHRleHR7RXJyfV97XG1hdGhjYWx7VH19KFxtYXRoYmZ7eH0pID0gXHRleHR7RX1fe1leKn1cbGVmdFsoXGhhdHttfShcbWF0aGJme3h9KSAtIFleKileMlxtaWQge1xtYXRoY2Fse1R9fSwgXG1hdGhiZnt4fVxyaWdodF0KIFxdCiB3aGVyZSAkWV4qJCBpcyBhbiBvdXRjb21lIGF0IHByZWRpY3RvciAkXG1hdGhiZnt4fSQsIGluZGVwZW5kZW50IG9mIHRoZSB0cmFpbmluZyBkYXRhLgoKIEhlbmNlLAogXFsKICAgXHRleHR7RXJyfV97XG1hdGhjYWx7VH19ID0gXHRleHR7RX1fe1heKn1cbGVmdFtcdGV4dHtFcnJ9X3tcbWF0aGNhbHtUfX0oXG1hdGhiZntYfV4qKVxyaWdodF0uCiBcXQoKQSBjbG9zZWx5IHJlbGF0ZWQgZXJyb3IgaXMgdGhlICoqaW5zYW1wbGUgZXJyb3IqKi4KCi0tLQoKIyMgSW5zYW1wbGUgRXJyb3IKClRoZSBpbnNhbXBsZSBlcnJvciBmb3IgcHJlZGljdGlvbiBtb2RlbCAkXGhhdHttfShcbWF0aGJme3h9KSQgaXMgZ2l2ZW4gYnkKIFxbCiAgIFx0ZXh0e0Vycn1fe1x0ZXh0e2lufSBcbWF0aGNhbHtUfX0gPSBcZnJhY3sxfXtufVxzdW1fe2k9MX1ebiBcdGV4dHtFcnJ9X3tcbWF0aGNhbHtUfX0oXG1hdGhiZnt4fV9pKSwKIFxdCgppLmUuIHRoZSBpbnNhbXBsZSBlcnJvciBpcyB0aGUgc2FtcGxlIGF2ZXJhZ2Ugb2YgdGhlIGNvbmRpdGlvbmFsIHRlc3QgZXJyb3JzIGV2YWx1YXRlZCBpbiB0aGUgJG4kIHRyYWluaW5nIGRhdGFzZXQgcHJlZGljdG9ycyAkXG1hdGhiZnt4fV9pJC4KClNpbmNlICRcdGV4dHtFcnJ9X3tcbWF0aGNhbHtUfX0kIGlzIGFuIGF2ZXJhZ2Ugb3ZlciBhbGwgJFxtYXRoYmZ7WH0kLCBldmVuIG92ZXIgdGhvc2UgcHJlZGljdG9ycyBub3Qgb2JzZXJ2ZWQgaW4gdGhlIHRyYWluaW5nIGRhdGFzZXQsIGl0IGlzIHNvbWV0aW1lcyByZWZlcnJlZCB0byBhcyB0aGUgKipvdXRzYW1wbGUgZXJyb3IqKi4KCi0tLQoKIyMgRXN0aW1hdGlvbiBvZiB0aGUgaW5zYW1wbGUgZXJyb3IKCldlIHN0YXJ0IHdpdGggaW50cm9kdWNpbmcgdGhlIHRyYWluaW5nIGVycm9yIHJhdGUsIHdoaWNoIGlzIGNsb3NlbHkgcmVsYXRlZCB0byB0aGUgTVNFIGluIGxpbmVhciBtb2RlbHMuCgojIyMgVHJhaW5pbmcgZXJyb3IKCiBUaGUgdHJhaW5pbmcgZXJyb3IgaXMgZ2l2ZW4gYnkKIFxbCiAgIFxvdmVybGluZXtcdGV4dHtlcnJ9fSA9IFxmcmFjezF9e259XHN1bV97aT0xfV5uIChZX2kgLSBcaGF0e219KFxtYXRoYmZ7eH1faSkpXjIgLAogXF0KIHdoZXJlIHRoZSAkKFlfaSxcbWF0aGJme3h9X2kpJCBmcm9tIHRoZSB0cmFpbmluZyBkYXRhc2V0IHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgdGhlIGNhbGN1bGF0aW9uIG9mICRcaGF0e219JC4KCi0gVGhlIHRyYWluaW5nIGVycm9yIGlzIGFuIG92ZXJseSBvcHRpbWlzdGljIGVzdGltYXRlIG9mIHRoZSB0ZXN0IGVycm9yICRcdGV4dHtFcnJ9X3tcbWF0aGNhbHtUfX0kLgoKLSBUaGUgdHJhaW5pbmcgZXJyb3Igd2lsbCBuZXZlciBpbmNyZWFzZXMgd2hlbiB0aGUgbW9kZWwgYmVjb21lcyBtb3JlIGNvbXBsZXguICRcbG9uZ3JpZ2h0YXJyb3ckIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5IGFzIGEgbW9kZWwgc2VsZWN0aW9uIGNyaXRlcmlvbi4KCkluZGVlZCwgbW9kZWwgcGFyYW1ldGVycyBhcmUgb2Z0ZW4gZXN0aW1hdGVkIGJ5IG1pbmltaXNpbmcgdGhlIHRyYWluaW5nIGVycm9yIChjZnIuIFNTRSkuCgotIEhlbmNlIHRoZSBmaXR0ZWQgbW9kZWwgYWRhcHRzIHRvIHRoZSB0cmFpbmluZyBkYXRhLCBhbmQKLSB0cmFpbmluZyBlcnJvciB3aWxsIGJlIGFuIG92ZXJseSBvcHRpbWlzdGljIGVzdGltYXRlIG9mIHRoZSB0ZXN0IGVycm9yICRcdGV4dHtFcnJ9X3tcbWF0aGNhbHtUfX0kLgoKLS0tCgpJdCBjYW4gYmUgc2hvd24gdGhhdCB0aGUgdHJhaW5pbmcgZXJyb3IgaXMgcmVsYXRlZCB0byB0aGUgaW5zYW1wbGUgdGVzdCBlcnJvciB2aWEKClxbClx0ZXh0e0V9X1xtYXRoYmZ7WX0KXGxlZnRbXHRleHR7RXJyfV97XHRleHR7aW59e1xtYXRoY2Fse1R9fX1ccmlnaHRdID0gXHRleHR7RX1fXG1hdGhiZntZfVxsZWZ0W1xvdmVybGluZXtcdGV4dHtlcnJ9fVxyaWdodF0gKyBcZnJhY3syfXtufVxzdW1fe2k9MX1ebiBcdGV4dHtjb3Z9X1xtYXRoYmZ7WX1cbGVmdFtcaGF0e219KFxtYXRoYmZ7eH1faSksWV9pXHJpZ2h0XSwKXF0KCk5vdGUsIHRoYXQgZm9yIGxpbmVhciBtb2RlbHMKXFsgXGhhdHttfShcbWF0aGJme3h9X2kpID0gXG1hdGhiZntYfVxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fT0gXG1hdGhiZntYfShcbWF0aGJme1h9XlRcbWF0aGJme1h9KV57LTF9XG1hdGhiZntYfV5UXG1hdGhiZntZfSA9IFxtYXRoYmZ7SFl9ClxdCndpdGgKCi0gJFxtYXRoYmZ7SH0kIHRoZSBoYXQgbWF0cml4IGFuZAotIGFsbCAkWV9pJCBhcmUgYXNzdW1lZCB0byBiZSBpbmRlcGVuZGVudGx5IGRpc3RyaWJ1dGVkICAkTihcbWF0aGJme1h9XGJvbGRzeW1ib2x7XGJldGF9LFxzaWdtYV4yKSQKCkhlbmNlLCBmb3IgbGluZWFyIG1vZGVscyB3aXRoIGluZGVwZW5kZW50IG9ic2VydmF0aW9ucwoKXGJlZ2lue2VxbmFycmF5fQpcdGV4dHtjb3Z9X1xtYXRoYmZ7WX1cbGVmdFtcaGF0e219KFxtYXRoYmZ7eH1faSksWV9pKVxyaWdodF0gJj0mClx0ZXh0e2Nvdn1fXG1hdGhiZntZfVxsZWZ0W1xtYXRoYmZ7SH1fe2l9XlRcbWF0aGJme1l9LFlfaSlccmlnaHRdXFwKJj0mIFx0ZXh0e2Nvdn1fXG1hdGhiZntZfVxsZWZ0W2hfe2lpfSBZX2ksWV9pXHJpZ2h0XVxcCiY9JiBoX3tpaX0gXHRleHR7Y292fV9cbWF0aGJme1l9XGxlZnRbWV9pLFlfaVxyaWdodF1cXAomPSYgaF97aWl9IFxzaWdtYV4yXFwKXGVuZHtlcW5hcnJheX0KCkFuZCB3ZSBjYW4gdGh1cyBlc3RpbWF0ZSB0aGUgaW5zYW1wbGUgZXJyb3IgYnkgTWFsbG93J3MgJENfcCQKClxiZWdpbntlcW5hcnJheX0KQ19wICY9JiBcb3ZlcmxpbmV7XHRleHR7ZXJyfX0gKyBcZnJhY3syXHNpZ21hXjJ9e259XHRleHR7dHJ9KFxtYXRoYmZ7SH0pXFwKJj0mIFxvdmVybGluZXtcdGV4dHtlcnJ9fSArIFxmcmFjezJcc2lnbWFeMnB9e259ClxlbmR7ZXFuYXJyYXl9Cgp3aXRoICRwJCB0aGUgbnVtYmVyIG9mIHByZWRpY3RvcnMuCgotIE1hbGxvdydzICRDX3AkIGlzIG9mdGVuIHVzZWQgZm9yIG1vZGVsIHNlbGVjdGlvbi4KLSBOb3RlLCB0aGF0IHdlIGNhbiBhbHNvIGNvbnNpZGVyIGl0IGFzIGEga2luZCBvZiBwZW5hbGl6ZWQgbGVhc3Qgc3F1YXJlczoKClxbCm4gXHRpbWVzIENfcCA9IFxWZXJ0IFxtYXRoYmZ7WX0gLSBcbWF0aGJme1h9XGJvbGRzeW1ib2x7XGJldGF9XFZlcnRfMl4yICsgMlxzaWdtYV4yIFxWZXJ0IFxib2xkc3ltYm9se1xiZXRhfSBcVmVydF8wClxdCndpdGggJExfMCQgbm9ybSAkXFZlcnQgXGJvbGRzeW1ib2x7XGJldGF9IFxWZXJ0XzAgPSBcc3VtX3tqPTF9XnAgXGJldGFfcF4wID0gcCQuCgotLS0KCiMjIEV4cGVjdGVkIHRlc3QgZXJyb3IKClRoZSB0ZXN0IG9yIGdlbmVyYWxpc2F0aW9uIGVycm9yIHdhcyBkZWZpbmVkIGNvbmRpdGlvbmFsbHkgb24gdGhlIHRyYWluaW5nIGRhdGEuIEJ5IGF2ZXJhZ2luZyBvdmVyIHRoZSBkaXN0cmlidXRpb24gb2YgdHJhaW5pbmcgZGF0YXNldHMsIHRoZSBleHBlY3RlZCB0ZXN0IGVycm9yIGFyaXNlcy4KClxiZWdpbntlcW5hcnJheSp9CiAgIFx0ZXh0e0V9X3tcbWF0aGNhbHtUfX1cbGVmdFtcdGV4dHtFcnJ9X3t7XG1hdGhjYWx7VH19fVxyaWdodF0KICAgICAmPSYgXHRleHR7RX1fe1xtYXRoY2Fse1R9fVxsZWZ0W1x0ZXh0e0V9X3tZXiosWF4qfVxsZWZ0WyhcaGF0e219KFxtYXRoYmZ7WH1eKikgLSBZXiopXjJcbWlkIHtcbWF0aGNhbHtUfX1ccmlnaHRdXHJpZ2h0XSBcXAogICAgICY9JiBcdGV4dHtFfV97WV4qLFheKix7XG1hdGhjYWx7VH19fVxsZWZ0WyhcaGF0e219KFxtYXRoYmZ7WH1eKikgLSBZXiopXjJccmlnaHRdLgogXGVuZHtlcW5hcnJheSp9CgogLSBUaGUgZXhwZWN0ZWQgdGVzdCBlcnJvciBtYXkgbm90IGJlIG9mIGRpcmVjdCBpbnRlcmVzdCB3aGVuIHRoZSBnb2FsIGlzIHRvIGFzc2VzcyB0aGUgcHJlZGljdGlvbiBwZXJmb3JtYW5jZSBvZiBhIHNpbmdsZSBwcmVkaWN0aW9uIG1vZGVsICRcaGF0e219KFxjZG90KSQuCgogLSBUaGUgZXhwZWN0ZWQgdGVzdCBlcnJvciBhdmVyYWdlcyB0aGUgdGVzdCBlcnJvcnMgb2YgYWxsIG1vZGVscyB0aGF0IGNhbiBiZSBidWlsZCBmcm9tIGFsbCB0cmFpbmluZyBkYXRhc2V0cywgYW5kIGhlbmNlIHRoaXMgbWF5IGJlIGxlc3MgcmVsZXZhbnQgd2hlbiB0aGUgaW50ZXJlc3QgaXMgaW4gZXZhbHVhdGluZyBvbmUgcGFydGljdWxhciBtb2RlbCB0aGF0IHJlc3VsdGVkIGZyb20gYSBzaW5nbGUgb2JzZXJ2ZWQgdHJhaW5pbmcgZGF0YXNldC4KCiAtIEFsc28gbm90ZSB0aGF0IGJ1aWxkaW5nIGEgcHJlZGljdGlvbiBtb2RlbCBpbnZvbHZlcyBib3RoIHBhcmFtZXRlciBlc3RpbWF0aW9uIGFuZCBmZWF0dXJlIHNlbGVjdGlvbi4KCiAtIEhlbmNlIHRoZSBleHBlY3RlZCB0ZXN0IGVycm9yIGFsc28gZXZhbHVhdGVzIHRoZSBmZWF0dXJlIHNlbGVjdGlvbiBwcm9jZWR1cmUgKG9uIGF2ZXJhZ2UpLgoKIC0gSWYgdGhlIGV4cGVjdGVkIHRlc3QgZXJyb3IgaXMgc21hbGwsIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCB0aGUgbW9kZWwgYnVpbGRpbmcgcHJvY2VzcyBnaXZlcyBnb29kIHByZWRpY3Rpb25zIGZvciBmdXR1cmUgb2JzZXJ2YXRpb25zICQoWV4qLFxtYXRoYmZ7WH1eKikkIG9uIGF2ZXJhZ2UuCgojIyMgRXN0aW1hdGluZyB0aGUgRXhwZWN0ZWQgdGVzdCBlcnJvcgoKVGhlIGV4cGVjdGVkIHRlc3QgZXJyb3IgbWF5IGJlIGVzdGltYXRlZCBieSBjcm9zcyB2YWxpZGF0aW9uIChDVikuCgojIyMjIExlYXZlIG9uZSBvdXQgY3Jvc3MgdmFsaWRhdGlvbiAoTE9PQ1YpfQoKVGhlIExPT0NWIGVzdGltYXRvciBvZiB0aGUgZXhwZWN0ZWQgdGVzdCBlcnJvciAob3IgZXhwZWN0ZWQgb3V0c2FtcGxlIGVycm9yKSBpcyBnaXZlbiBieQogIFxbCiAgICAgXHRleHR7Q1Z9ID0gXGZyYWN7MX17bn0gXHN1bV97aT0xfV5uIFxsZWZ0KFlfaSAtIFxoYXR7bX1eey1pfShcbWF0aGJme3h9X2kpXHJpZ2h0KV4yICwKICBcXQp3aGVyZQoKLSB0aGUgJChZX2ksXG1hdGhiZnt4fV9pKSQgZm9ybSB0aGUgdHJhaW5pbmcgZGF0YXNldAotICAgJFxoYXR7bX1eey1pfSQgaXMgdGhlIGZpdHRlZCBtb2RlbCBiYXNlZCBvbiBhbGwgdHJhaW5pbmcgZGF0YSwgZXhjZXB0IG9ic2VydmF0aW9uICRpJAotICAgJFxoYXR7bX1eey1pfShcbWF0aGJme3h9X2kpJCBpcyB0aGUgcHJlZGljdGlvbiBhdCAkXG1hdGhiZnt4fV9pJCwgd2hpY2ggaXMgdGhlIG9ic2VydmF0aW9uIGxlZnQgb3V0IHRoZSB0cmFpbmluZyBkYXRhIGJlZm9yZSBidWlsZGluZyBtb2RlbCAkbSQuCgpTb21lIHJhdGlvbmFsZSBhcyB0byB3aHkgTE9PQ1Ygb2ZmZXJzIGEgZ29vZCBlc3RpbWF0b3Igb2YgdGhlIG91dHNhbXBsZSBlcnJvcjoKCi0gdGhlIHByZWRpY3Rpb24gZXJyb3IgJFleKi1caGF0e219KFxtYXRoYmZ7eH0pJCBpcyBtaW1pY2tlZCBieSBub3QgdXNpbmcgb25lIG9mIHRoZSB0cmFpbmluZyBvdXRjb21lcyAkWV9pJCBmb3IgdGhlIGVzdGltYXRpb24gb2YgdGhlIG1vZGVsIHNvIHRoYXQgdGhpcyAkWV9pJCBwbGF5cyB0aGUgcm9sZSBvZiAkWV4qJCwgYW5kLCBjb25zZXF1ZW50bHksIHRoZSBmaXR0ZWQgbW9kZWwgJFxoYXR7bX1eey1pfSQgaXMgaW5kZXBlbmRlbnQgb2YgJFlfaSQKCiAtIHRoZSBzdW0gaW4gJENWJCBpcyBvdmVyIGFsbCAkXG1hdGhiZnt4fV9pJCBpbiB0aGUgdHJhaW5pbmcgZGF0YXNldCwgYnV0IGVhY2ggdGVybSAkXG1hdGhiZnt4fV9pJCB3YXMgbGVmdCBvdXQgb25jZSBmb3IgdGhlIGNhbGN1bGF0aW9uIG9mICRcaGF0e219XnstaX0kLiBIZW5jZSwgJFxoYXR7bX1eey1pfShcbWF0aGJme3h9X2kpJCBtaW1pY3MgYW4gb3V0c2FtcGxlIHByZWRpY3Rpb24uCgogLSB0aGUgc3VtIGluIENWIGlzIG92ZXIgJG4kIGRpZmZlcmVudCB0cmFpbmluZyBkYXRhc2V0cyAoZWFjaCBvbmUgd2l0aCBhIGRpZmZlcmVudCBvYnNlcnZhdGlvbiByZW1vdmVkKSwgYW5kIGhlbmNlIENWIGlzIGFuIGVzdGltYXRvciBvZiB0aGUgKmV4cGVjdGVkKiB0ZXN0IGVycm9yLgoKIC0gRm9yIGxpbmVhciBtb2RlbHMgdGhlIExPT0NWIGNhbiBiZSByZWFkaWx5IG9idGFpbmVkIGZyb20gdGhlIGZpdHRlZCBtb2RlbDogaS5lLgoKIFxbXHRleHR7Q1Z9ID0gXGZyYWN7MX17bn1cc3VtXGxpbWl0c197aT0xfV5uIFxmcmFje2VfaV4yfXsoMS1oX3tpaX0pXjJ9XF0KCiB3aXRoICRlX2kkIHRoZSByZXNpZHVhbHMgZnJvbSB0aGUgbW9kZWwgdGhhdCBpcyBmaXR0ZWQgYmFzZWQgb24gYWxsIHRyYWluaW5nIGRhdGEuCgotLS0KCkFuIGFsdGVybmF0aXZlIHRvIExPT0NWIGlzIHRoZSAkayQtZm9sZCBjcm9zcyB2YWxpZGF0aW9uIHByb2NlZHVyZS4gSXQgYWxzbyBnaXZlcyBhbiBlc3RpbWF0ZSBvZiB0aGUgZXhwZWN0ZWQgb3V0c2FtcGxlIGVycm9yLgoKIyMjIyAkayQtZm9sZCBjcm9zcyB2YWxpZGF0aW9uCgotICBSYW5kb21seSBkaXZpZGUgdGhlIHRyYWluaW5nIGRhdGFzZXQgaW50byAkayQgYXBwcm94aW1hdGVseSBlcXVhbCBzdWJzZXRzIC4gTGV0ICRTX2okIGRlbm90ZSB0aGUgaW5kZXggc2V0IG9mIHRoZSAkaiR0aCBzdWJzZXQgKHJlZmVycmVkIHRvIGFzIGEgKipmb2xkKiopLiBMZXQgJG5faiQgZGVub3RlIHRoZSBudW1iZXIgb2Ygb2JzZXJ2YXRpb25zIGluIGZvbGQgJGokLgoKLSBUaGUgJGskLWZvbGQgY3Jvc3MgdmFsaWRhdGlvbiBlc3RpbWF0b3Igb2YgdGhlIGV4cGVjdGVkIG91dHNhbXBsZSBlcnJvciBpcyBnaXZlbiBieQogXFsKICAgICBcdGV4dHtDVn1fayA9IFxmcmFjezF9e2t9XHN1bV97aj0xfV5rIFxmcmFjezF9e25fan0gXHN1bV97aVxpbiBTX2p9IFxsZWZ0KFlfaSAtIFxoYXR7bX1eey1TX2p9KFxtYXRoYmZ7eH1faSlccmlnaHQpXjIKIFxdCiB3aGVyZSAkXGhhdHttfV57LVNfan0kIGlzIHRoZSBtb2RlbCBmaXR0ZWQgdXNpbmcgYWxsIHRyYWluaW5nIGRhdGEsIGV4Y2VwdCBvYnNlcnZhdGlvbnMgaW4gZm9sZCAkaiQgKGkuZS4gb2JzZXJ2YXRpb25zICRpIFxpbiBTX2okKS4KCi0tLQoKVGhlIGNyb3NzIHZhbGlkYXRpb24gZXN0aW1hdG9ycyBvZiB0aGUgZXhwZWN0ZWQgb3V0c2FtcGxlIGVycm9yIGFyZSBuZWFybHkgdW5iaWFzZWQuIE9uZSBhcmd1bWVudCB0aGF0IGhlbHBzIHRvIHVuZGVyc3RhbmQgd2hlcmUgdGhlIGJpYXMgY29tZXMgZnJvbSBpcyB0aGUgZmFjdCB0aGF0IGUuZy4gaW4gZGUgTE9PQ1YgZXN0aW1hdG9yIHRoZSBtb2RlbCBpcyBmaXQgb24gb25seSAkbi0xJCBvYnNlcnZhdGlvbnMsIHdoZXJlYXMgd2UgYXJlIGFpbWluZyBhdCBlc3RpbWF0aW5nIHRoZSBvdXRzYW1wbGUgZXJyb3Igb2YgYSBtb2RlbCBmaXQgb24gYWxsICRuJCB0cmFpbmluZyBvYnNlcnZhdGlvbnMuIEZvcnR1bmF0ZWx5LCB0aGUgYmlhcyBpcyBvZnRlbiBzbWFsbCBhbmQgaXMgaW4gcHJhY3RpY2UgaGFyZGx5IGEgY29uY2Vybi4KCiRrJC1mb2xkIENWIGlzIGNvbXB1dGF0aW9uYWxseSBtb3JlIGNvbXBsZXguCgpTaW5jZSBDViBhbmQgQ1YkX2skIGFyZSBlc3RpbWF0b3JzLCB0aGV5IGFsc28gc2hvdyBzYW1wbGluZyB2YXJpYWJpbGl0eS4gU3RhbmRhcmQgZXJyb3JzIG9mIHRoZSBDViBvciBDViRfayQgY2FuIGJlIGNvbXB1dGVkLiBXZSBkb24ndCBzaG93IHRoZSBkZXRhaWxzLCBidXQgaW4gdGhlIGV4YW1wbGUgdGhpcyBpcyBpbGx1c3RyYXRlZC4KCiMjIyBCaWFzIFZhcmlhbmNlIHRyYWRlLW9mZgoKRm9yIHRoZSBleHBlY3RlZCBjb25kaXRpb25hbCB0ZXN0IGVycm9yIGluICRcbWF0aGJme3h9JCwgaXQgaG9sZHMgdGhhdApcYmVnaW57ZXFuYXJyYXkqfQogIFx0ZXh0e0V9X3tcbWF0aGNhbHtUfX1cbGVmdFtcdGV4dHtFcnJ9X3tcbWF0aGNhbHtUfX0oXG1hdGhiZnt4fSlccmlnaHRdCiAgICAmPSYgXHRleHR7RX1fe1leKix7XG1hdGhjYWx7VH19fVxsZWZ0WyhcaGF0e219KFxtYXRoYmZ7eH0pLVleKileMiBcbWlkIFxtYXRoYmZ7eH1ccmlnaHRdIFxcCiAgICAmPSYgIFx0ZXh0e3Zhcn1fe1xtYXRoYmZ7WX19XGxlZnRbXGhhdHtZfShcbWF0aGJme3h9KVxtaWQgXG1hdGhiZnt4fVxyaWdodF0gKyhcbXUoXG1hdGhiZnt4fSktXG11XiooXG1hdGhiZnt4fSkpXjIrXHRleHR7dmFyfV97WV4qfVxsZWZ0W1leKlxtaWQgXG1hdGhiZnt4fVxyaWdodF0KXGVuZHtlcW5hcnJheSp9CndoZXJlICRcbXUoXG1hdGhiZnt4fSkgPSBcdGV4dHtFfV97XG1hdGhiZntZfX1cbGVmdFtcaGF0e1l9KFxtYXRoYmZ7eH0pXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSBcdGV4dHsgYW5kIH0gXG11XiooXG1hdGhiZnt4fSk9XHRleHR7RX1fe1leKn1cbGVmdFtZXipcbWlkIFxtYXRoYmZ7eH1ccmlnaHRdJC4KCi0gKipiaWFzKio6ICRcdGV4dHtiaWFzfShcbWF0aGJme3h9KT1cbXUoXG1hdGhiZnt4fSktXG11XiooXG1hdGhiZnt4fSkkCgotICRcdGV4dHt2YXJ9X3tZXip9XGxlZnRbWV4qXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSQgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSBtb2RlbCwgYW5kIGlzIHJlZmVycmVkIHRvIGFzIHRoZSAqKmlycmVkdWNpYmxlIHZhcmlhbmNlKiouCgotLS0KClRoZSBpbXBvcnRhbmNlIG9mIHRoZSBiaWFzLXZhcmlhbmNlIHRyYWRlLW9mZiBjYW4gYmUgc2VlbiBmcm9tIGEgbW9kZWwgc2VsZWN0aW9uIHBlcnNwZWN0aXZlLiBXaGVuIHdlIGFncmVlIHRoYXQgYSBnb29kIG1vZGVsIGlzIGEgbW9kZWwgdGhhdCBoYXMgYSBzbWFsbCBleHBlY3RlZCBjb25kaXRpb25hbCB0ZXN0IGVycm9yIGF0IHNvbWUgcG9pbnQgJFxtYXRoYmZ7eH0kLCB0aGVuIHRoZSBiaWFzLXZhcmlhbmNlIHRyYWRlLW9mZiBzaG93cyB1cyB0aGF0IGEgbW9kZWwgbWF5IGJlIGJpYXNlZCBhcyBsb25nIGFzIGl0IGhhcyBhIHNtYWxsIHZhcmlhbmNlIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBiaWFzLiAgSXQgb2Z0ZW4gaGFwcGVucyB0aGF0IGEgYmlhc2VkIG1vZGVsIGhhcyBhIHN1YnN0YW50aWFsIHNtYWxsZXIgdmFyaWFuY2UuIFdoZW4gdGhlc2UgdHdvIGFyZSBjb21iaW5lZCwgYSBzbWFsbCBleHBlY3RlZCB0ZXN0IGVycm9yIG1heSBvY2N1ci4KCkFsc28gbm90ZSB0aGF0IHRoZSBtb2RlbCAkbSQgd2hpY2ggZm9ybXMgdGhlIGJhc2lzIG9mIHRoZSBwcmVkaWN0aW9uIG1vZGVsICRcaGF0e219KFxtYXRoYmZ7eH0pJCBkb2VzIE5PVCBuZWVkIHRvIHNhdGlzZnkgJG0oXG1hdGhiZnt4fSk9XG11KFxtYXRoYmZ7eH0pJCBvciAkbShcbWF0aGJme3h9KT1cbXVeKihcbWF0aGJme3h9KSQuIFRoZSBtb2RlbCAkbSQgaXMga25vd24gYnkgdGhlIGRhdGEtYW5hbHlzdCAoaXRzIHRoZSBiYXNpcyBvZiB0aGUgcHJlZGljdGlvbiBtb2RlbCksIHdoZXJlYXMgJFxtdShcbWF0aGJme3h9KSQgYW5kICRcbXVeKihcbWF0aGJme3h9KSQgYXJlIGdlbmVyYWxseSB1bmtub3duIHRvIHRoZSBkYXRhLWFuYWx5c3QuIFdlIG9ubHkgaG9wZSB0aGF0ICRtJCBzZXJ2ZXMgd2VsbCBhcyBhIHByZWRpY3Rpb24gbW9kZWwuCgotLS0KCiMjIyBJbiBwcmFjdGljZQoKV2UgdXNlIGNyb3NzIHZhbGlkYXRpb24gdG8gZXN0aW1hdGUgdGhlIGxhbWJkYSBwZW5hbHR5IGZvciBwZW5hbGlzZWQgcmVncmVzc2lvbjoKCi0gUmlkZ2UgUmVncmVzc2lvbgotIExhc3NvCi0gQnVpbGQgbW9kZWxzLCBlLmcuIHNlbGVjdCB0aGUgbnVtYmVyIG9mIFBDcyBmb3IgUENBIHJlZ3Jlc3Npb24KLSBTcGxpbmVzCgojIyMgVG94aWNvZ2Vub21pY3MgZXhhbXBsZQoKIyMjIyBMYXNzbwoKYGBge3J9CnNldC5zZWVkKDE1KQpsaWJyYXJ5KGdsbW5ldCkKbUN2TGFzc28gPC0gY3YuZ2xtbmV0KAogIHggPSB0b3hEYXRhWywtMV0gJT4lCiAgICBhcy5tYXRyaXgsCiAgeSA9IHRveERhdGEgJT4lCiAgICBwdWxsKEJBKSwKICBhbHBoYSA9IDEpICAjIGxhc3NvIGFscGhhPTEKCnBsb3QobUN2TGFzc28pCmBgYAoKRGVmYXVsdCBDViBwcm9jZWR1cmUgaW4gXHRleHRzZntjdi5nbG1uZXR9IGlzICRrPTEwJC1mb2xkIENWLgoKVGhlIEdyYXBocyBzaG93cwoKLSAxMC1mb2xkIENWIGVzdGltYXRlcyBvZiB0aGUgZXh0cmEtc2FtcGxlIGVycm9yIGFzIGEgZnVuY3Rpb24gb2YgdGhlIGxhc3NvIHBlbmFsdHkgcGFyYW1ldGVyICRcbGFtYmRhJC4KLSBlc3RpbWF0ZSBwbHVzIGFuZCBtaW51cyBvbmNlIHRoZSBlc3RpbWF0ZWQgc3RhbmRhcmQgZXJyb3Igb2YgdGhlIENWIGVzdGltYXRlIChncmV5IGJhcnMpCi0gT24gdG9wIHRoZSBudW1iZXIgb2Ygbm9uLXplcm8gcmVncmVzc2lvbiBwYXJhbWV0ZXIgZXN0aW1hdGVzIGFyZSBzaG93bi4KClR3byB2ZXJ0aWNhbCByZWZlcmVuY2UgbGluZXMgYXJlIGFkZGVkIHRvIHRoZSBncmFwaC4gVGhleSBjb3JyZXNwb25kIHRvCgotIHRoZSAkXGxvZyhcbGFtYmRhKSQgdGhhdCBnaXZlcyB0aGUgc21hbGxlc3QgQ1YgZXN0aW1hdGUgb2YgdGhlIGV4dHJhLXNhbXBsZSBlcnJvciwgYW5kCi0gdGhlIGxhcmdlc3QgJFxsb2coXGxhbWJkYSkkIHRoYXQgZ2l2ZXMgYSBDViBlc3RpbWF0ZSBvZiB0aGUgZXh0cmEtc2FtcGxlIGVycm9yIHRoYXQgaXMgd2l0aGluIG9uZSBzdGFuZGFyZCBlcnJvciBmcm9tIHRoZSBzbWFsbGVzdCBlcnJvciBlc3RpbWF0ZS4KLSBUaGUgbGF0dGVyIGNob2ljZSBvZiAkXGxhbWJkYSQgaGFzIG5vIGZpcm0gdGhlb3JldGljYWwgYmFzaXMsIGV4Y2VwdCB0aGF0IGl0IHNvbWVob3cgYWNjb3VudHMgZm9yIHRoZSBpbXByZWNpc2lvbiBvZiB0aGUgZXJyb3IgZXN0aW1hdGUuIE9uZSBjb3VsZCBsb29zZWx5IHNheSB0aGF0IHRoaXMgJFxnYW1tYSQgY29ycmVzcG9uZHMgdG8gdGhlIHNtYWxsZXN0IG1vZGVsIChpLmUuIGxlYXN0IG51bWJlciBvZiBwcmVkaWN0b3JzKSB0aGF0IGdpdmVzIGFuIGVycm9yIHRoYXQgaXMgd2l0aGluIG1hcmdpbiBvZiBlcnJvciBvZiB0aGUgZXJyb3Igb2YgdGhlIGJlc3QgbW9kZWwuCgotLS0KCmBgYHtyfQptTGFzc29PcHQgPC0gZ2xtbmV0KAogIHggPSB0b3hEYXRhWywtMV0gJT4lCiAgICBhcy5tYXRyaXgsCiAgeSA9IHRveERhdGEgJT4lCiAgICBwdWxsKEJBKSwKICAgIGFscGhhID0gMSwKICAgIGxhbWJkYSA9IG1Ddkxhc3NvJGxhbWJkYS5taW4pCgpzdW1tYXJ5KGNvZWYobUxhc3NvT3B0KSkKYGBgCgoKV2l0aCB0aGUgb3B0aW1hbCAkXGxhbWJkYSQgKHNtYWxsZXN0IGVycm9yIGVzdGltYXRlKSB0aGUgb3V0cHV0IHNob3dzIHRoZSBgciAgbnJvdyhzdW1tYXJ5KGNvZWYobUxhc3NvT3B0KSkpYCBub24temVybyBlc3RpbWF0ZWQgcmVncmVzc2lvbiBjb2VmZmljaWVudHMgKHNwYXJzZSBzb2x1dGlvbikuCgotLS0KCmBgYHtyfQptTGFzc28xc2UgPC0gZ2xtbmV0KAogIHggPSB0b3hEYXRhWywtMV0gJT4lCiAgICBhcy5tYXRyaXgsCiAgICB5PSB0b3hEYXRhICU+JQogICAgICBwdWxsKEJBKSwKICAgIGFscGhhID0gMSwKICAgIGxhbWJkYSA9IG1Ddkxhc3NvJGxhbWJkYS4xc2UpCgptTGFzc28xc2UgJT4lCiAgY29lZiAlPiUKICBzdW1tYXJ5CmBgYAoKVGhpcyBzaG93cyB0aGUgc29sdXRpb24gZm9yIHRoZSBsYXJnZXN0ICRcbGFtYmRhJCB3aXRoaW4gb25lIHN0YW5kYXJkIGVycm9yIG9mIHRoZSBvcHRpbWFsIG1vZGVsLiBOb3cgb25seSBgciAgbnJvdyhzdW1tYXJ5KGNvZWYobUxhc3NvMXNlKSkpYCBub24temVybyBlc3RpbWF0ZXMgcmVzdWx0LgoKLS0tCgojIyMjIFJpZGdlCgpgYGB7cn0KbUN2UmlkZ2UgPC0gY3YuZ2xtbmV0KAogIHggPSB0b3hEYXRhWywtMV0gJT4lCiAgICBhcy5tYXRyaXgsCiAgICB5ID0gdG94RGF0YSAlPiUKICAgICAgcHVsbChCQSksCiAgICAgIGFscGhhID0gMCkgICMgcmlkZ2UgYWxwaGE9MAoKcGxvdChtQ3ZSaWRnZSkKYGBgCgotIFJpZGdlIGRvZXMgbm90IHNlZW0gdG8gaGF2ZSBvcHRpbWFsIHNvbHV0aW9uLgotIDEwLWZvbGQgQ1YgaXMgYWxzbyBsYXJnZXIgdGhhbiBmb3IgbGFzc28uCgotLS0KCiMjIyMgUENBIHJlZ3Jlc3Npb24KCmBgYHtyIGZpZy5rZWVwID0gIm5vbmUiLCB3YXJuaW5nID0gRkFMU0V9CnNldC5zZWVkKDEyNjQpCmxpYnJhcnkoREFBRykKCnRveCA8LSBkYXRhLmZyYW1lKAogIFkgPSB0b3hEYXRhICU+JQogICAgcHVsbChCQSksCiAgUEMgPSBaaykKClBDLnNlcSA8LSAxOjI1CkVyciA8LSBudW1lcmljKDI1KQoKbUN2UGNhIDwtIGN2LmxtKAogIFl+UEMuMSwKICBkYXRhID0gdG94LAogIG0gPSA1LAogIHByaW50aXQgPSBGQUxTRSkKCkVyclsxXTwtYXR0cihtQ3ZQY2EsIm1zIikKCmZvcihpIGluIDI6MjUpIHsKICBtQ3ZQY2EgPC0gY3YubG0oCiAgICBhcy5mb3JtdWxhKAogICAgICBwYXN0ZSgiWSB+IFBDLjEgKyAiLAogICAgICAgIHBhc3RlKCJQQy4iLCAyOmksIGNvbGxhcHNlID0gIisiLCBzZXA9IiIpLAogICAgICAgIHNlcD0iIgogICAgICApCiAgICApLAogICAgZGF0YSA9IHRveCwKICAgIG0gPSA1LAogICAgcHJpbnRpdCA9IEZBTFNFKQogIEVycltpXTwtYXR0cihtQ3ZQY2EsIm1zIikKfQpgYGAKCi0gSGVyZSB3ZSBpbGx1c3RyYXRlIHByaW5jaXBhbCBjb21wb25lbnQgcmVncmVzc2lvbi4KCi0gVGhlIG1vc3QgaW1wb3J0YW50IFBDcyBhcmUgc2VsZWN0ZWQgaW4gYSBmb3J3YXJkIG1vZGVsIHNlbGVjdGlvbiBwcm9jZWR1cmUuCgotIFdpdGhpbiB0aGUgbW9kZWwgc2VsZWN0aW9uIHByb2NlZHVyZSB0aGUgbW9kZWxzIGFyZSBldmFsdWF0ZWQgd2l0aCA1LWZvbGQgQ1YgZXN0aW1hdGVzIG9mIHRoZSBvdXRzYW1wbGUgZXJyb3IuCgotIEl0IGlzIGltcG9ydGFudCB0byByZWFsaXNlIHRoYXQgYSBmb3J3YXJkIG1vZGVsIHNlbGVjdGlvbiBwcm9jZWR1cmUgd2lsbCBub3QgbmVjZXNzYXJpbHkgcmVzdWx0IGluIHRoZSBiZXN0IHByZWRpY3Rpb24gbW9kZWwsIHBhcnRpY3VsYXJseSBiZWNhdXNlIHRoZSBvcmRlciBvZiB0aGUgUENzIGlzIGdlbmVyYWxseSBub3QgcmVsYXRlZCB0byB0aGUgaW1wb3J0YW5jZSBvZiB0aGUgUENzIGZvciBwcmVkaWN0aW5nIHRoZSBvdXRjb21lLgoKLSBBIHN1cGVydmlzZWQgUEMgd291bGQgYmUgYmV0dGVyLgoKYGBge3J9CnBQQ3JlZyA8LSBkYXRhLmZyYW1lKFBDLnNlcSwgRXJyKSAlPiUKICBnZ3Bsb3QoYWVzKHggPSBQQy5zZXEsIHkgPSBFcnIpKSArCiAgZ2VvbV9saW5lKCkgKwogIGdlb21fcG9pbnQoKSArCiAgZ2VvbV9obGluZSgKICAgIHlpbnRlcmNlcHQgPSBjKAogICAgICBtQ3ZMYXNzbyRjdm1bbUN2TGFzc28kbGFtYmRhPT1tQ3ZMYXNzbyRsYW1iZGEubWluXSwKICAgICAgbUN2TGFzc28kY3ZtW21Ddkxhc3NvJGxhbWJkYT09bUN2TGFzc28kbGFtYmRhLjFzZV0pLAogICAgY29sID0gInJlZCIpICsKICB4bGltKDEsMjYpCgpncmlkLmFycmFuZ2UoCiAgcFBDcmVnLAogIHBQQ3JlZyArIHlsaW0oMCw1KSwKICBuY29sPTIpCmBgYAoKLSBUaGUgZ3JhcGggc2hvd3MgdGhlIENWIGVzdGltYXRlIG9mIHRoZSBvdXRzYW1wbGUgZXJyb3IgYXMgYSBmdW5jdGlvbiBvZiB0aGUgbnVtYmVyIG9mIHNwYXJzZSBQQ3MgaW5jbHVkZWQgaW4gdGhlIG1vZGVsLgoKLSBBIHZlcnkgc21hbGwgZXJyb3IgaXMgb2J0YWluZWQgd2l0aCB0aGUgbW9kZWwgd2l0aCBvbmx5IHRoZSBmaXJzdCBQQy4gVGhlIGJlc3QgbW9kZWwgd2l0aCAzIFBDcy4KCi0gVGhlIHR3byB2ZXJ0aWNhbCByZWZlcmVuY2UgbGluZXMgY29ycmVzcG9uZCB0byB0aGUgZXJyb3IgZXN0aW1hdGVzIG9idGFpbmVkIHdpdGggbGFzc28gKG9wdGltYWwgJFxsYW1iZGEkIGFuZCBsYXJnZXN0ICRcbGFtYmRhJCB3aXRoaW4gb25lIHN0YW5kYXJkIGVycm9yKS4KCi0gVGh1cyBhbHRob3VnaCB0aGVyZSB3YXMgYSBwcmlvcmkgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGZpcnN0IFBDcyBhcmUgdGhlIG1vc3QgcHJlZGljdGl2ZSwgaXQgc2VlbXMgdG8gYmUgdGhlIGNhc2UgaGVyZSAod2Ugd2VyZSBsdWNreSEpLgoKLSBNb3Jlb3ZlciwgdGhlIGZpcnN0IFBDIHJlc3VsdGVkIGluIGEgc21hbGwgb3V0c2FtcGxlIGVycm9yLgoKLSBOb3RlIHRoYXQgdGhlIGdyYXBoIGRvZXMgbm90IGluZGljYXRlIHRoZSB2YXJpYWJpbGl0eSBvZiB0aGUgZXJyb3IgZXN0aW1hdGVzIChubyBlcnJvciBiYXJzKS4KCi0gQWxzbyBub3RlIHRoYXQgdGhlIGdyYXBoIGNsZWFybHkgaWxsdXN0cmF0ZXMgdGhlIGVmZmVjdCBvZiBvdmVyZml0dGluZzogaW5jbHVkaW5nIHRvbyBtYW55IFBDcyBjYXVzZXMgYSBsYXJnZSBvdXRzYW1wbGUgZXJyb3IuCgojIyMgTGlkYXIgRXhhbXBsZTogc3BsaW5lcwoKLSBXZSB1c2UgdGhlIG1nY3YgcGFja2FnZSB0byBmaXQgdGhlIHNwbGluZSBtb2RlbCB0byB0aGUgbGlkYXIgZGF0YS4KLSBBIGJldHRlciBiYXNpcyBpcyB1c2VkIHRoYW4gdGhlIHRydW5jYXRlZCBzcGxpbmUgYmFzaXMKLSBUaGluIHBsYXRlIHNwbGluZXMgYXJlIGFsc28gbGluZWFyIHNtb290aGVycywgaS5lLgokXGhhdHtZfSA9IFxoYXR7bX0oXG1hdGhiZntYfSkgPSBcbWF0aGJme1NZfSQKLSBTbyB0aGVpciB2YXJpYW5jZSBjYW4gYmUgZWFzaWx5IGNhbGN1bGF0ZWQuCi0gVGhlIHJpZGdlL3Ntb290aG5lc3MgcGVuYWx0eSBpcyBjaG9zZW4gYnkgZ2VuZXJhbGl6ZWQgY3Jvc3MgdmFsaWRhdGlvbi4KCmBgYHtyfQpsaWJyYXJ5KG1nY3YpCmdhbWZpdCA8LSBnYW0obG9ncmF0aW8gfiBzKHJhbmdlKSwgZGF0YSA9IGxpZGFyKQpnYW1maXQkc3AKCnBMaWRhciArCiAgZ2VvbV9saW5lKGFlcyh4ID0gbGlkYXIkcmFuZ2UsIHkgPSBnYW1maXQkZml0dGVkKSwgbHdkID0gMikKYGBgCgojIyBNb3JlIGdlbmVyYWwgZXJyb3IgZGVmaW5pdGlvbnMKClNvIGZhciB3ZSBvbmx5IGxvb2tlZCBhdCBjb250aW51b3VzIG91dGNvbWVzICRZJCBhbmQgZXJyb3JzIGRlZmluZWQgaW4gdGVybXMgb2YgdGhlIHNxdWFyZWQgbG9zcyAkKFxoYXR7bX0oXG1hdGhiZnt4fSktWV4qKV4yJC4KCk1vcmUgZ2VuZXJhbGx5LCBhICoqbG9zcyBmdW5jdGlvbioqIG1lYXN1cmVzIGFuIGRpc2NyZXBhbmN5IGJldHdlZW4gdGhlIHByZWRpY3Rpb24gJFxoYXR7bX0oXG1hdGhiZnt4fSkkIGFuZCBhbiBpbmRlcGVuZGVudCBvdXRjb21lICRZXiokIHRoYXQgY29ycmVzcG9uZHMgdG8gJFxtYXRoYmZ7eH0kLgoKClNvbWUgZXhhbXBsZXMgZm9yIGNvbnRpbnVvdXMgJFkkOgpcYmVnaW57ZXFuYXJyYXkqfQogIEwoWV4qLFxoYXR7bX0oXG1hdGhiZnt4fSkpCiAgICAmPSYgKFxoYXR7bX0oXG1hdGhiZnt4fSktWV4qKV4yIFw7XDtcdGV4dHsoc3F1YXJlZCBlcnJvcil9IFxcCiAgTChZXiosXGhhdHttfShcbWF0aGJme3h9KSkKICAgICY9JiBcdmVydFxoYXR7bX0oXG1hdGhiZnt4fSktWV4qXHZlcnQgXDtcO1x0ZXh0eyhhYnNvbHV0ZSBlcnJvcil9IFxcCiAgIEwoWV4qLFxoYXR7bX0oXG1hdGhiZnt4fSkpCiAgICAmPSYgMiBcaW50X3tcbWF0aGNhbHtZfX0gZl95KHkpIFxsb2dcZnJhY3tmX3koeSl9e2Zfe1xoYXR7bX19KHkpfSBkeSBcO1w7XHRleHR7KGRldmlhbmNlKX0uClxlbmR7ZXFuYXJyYXkqfQoKCkluIHRoZSBleHByZXNzaW9uIG9mIHRoZSBkZXZpYW5jZQoKLSAkZl95JCBkZW5vdGVzIHRoZSBkZW5zaXR5IGZ1bmN0aW9uIG9mIGEgZGlzdHJpYnV0aW9uIHdpdGggbWVhbiBzZXQgdG8gJHkkIChjZnIuIHBlcmZlY3QgZml0KSwgYW5kCi0gJGZfe1xoYXR7bX19JCBpcyB0aGUgZGVuc2l0eSBmdW5jdGlvbiBvZiB0aGUgc2FtZSBkaXN0cmlidXRpb24gYnV0IHdpdGggbWVhbiBzZXQgdG8gdGhlIHByZWRpY3RlZCBvdXRjb21lICRcaGF0e219KFxtYXRoYmZ7eH0pJC4KCi0tLQoKV2l0aCBhIGdpdmVuIGxvc3MgZnVuY3Rpb24sIHRoZSBlcnJvcnMgYXJlIGRlZmluZWQgYXMgZm9sbG93czoKLSBUZXN0IG9yIGdlbmVyYWxpc2F0aW9uIG9yIG91dHNhbXBsZSBlcnJvcgogICAgXFsKICAgICAgXHRleHR7RXJyfV97XG1hdGhjYWx7VH19ID0gXHRleHR7RX1fe1leKixYXip9XGxlZnRbTChZXiosXGhhdHttfShcbWF0aGJme1h9XiopKVxyaWdodF0KICAgIFxdCgotIFRyYWluaW5nIGVycm9yCiAgXFsKICAgIFxvdmVybGluZXtcdGV4dHtlcnJ9fSA9IFxmcmFjezF9e259XHN1bV97aT0xfV5uIEwoWV9pLFxoYXR7bX0oXG1hdGhiZnt4fV9pKSkKICBcXQoKLSAkXGxkb3RzJAoKLS0tCgpXaGVuIGFuIGV4cG9uZW50aWFsIGZhbWlseSBkaXN0cmlidXRpb24gaXMgYXNzdW1lZCBmb3IgdGhlIG91dGNvbWUgZGlzdHJpYnV0aW9uLCBhbmQgd2hlbiB0aGUgZGV2aWFuY2UgbG9zcyBpcyB1c2VkLCB0aGUgaW5zYW1wbGUgZXJyb3IgY2FuIGJlIGVzdGltYXRlZCBieSBtZWFucyBvZiB0aGUgQUlDIGFuZCBCSUMuCgojIyMgQWthaWtlJ3MgSW5mb3JtYXRpb24gQ3JpdGVyaW9uIChBSUMpCgpUaGUgQUlDIGZvciBhIG1vZGVsICRtJCBpcyBnaXZlbiBieQpcWwpcdGV4dHtBSUN9ID0gLTIgXGxuIFxoYXR7TH0obSkgKzJwClxdCndoZXJlICRcaGF0e0x9KG0pJCBpcyB0aGUgbWF4aW1pc2VkIGxpa2VsaWhvb2QgZm9yIG1vZGVsICRtJC4KCldoZW4gYXNzdW1pbmcgbm9ybWFsbHkgZGlzdHJpYnV0ZWQgZXJyb3IgdGVybXMgYW5kIGhvbW9zY2VkYXN0aWNpdHksIHRoZSBBSUMgYmVjb21lcwpcWwpcdGV4dHtBSUN9ID0gblxsbiBcdGV4dHtTU0V9KG0pICsycCA9IG5cbG4oblxvdmVybGluZXtcdGV4dHtlcnJ9fShtKSkgKyAycApcXQp3aXRoICRcdGV4dHtTU0V9KG0pJCB0aGUgcmVzaWR1YWwgc3VtIG9mIHNxdWFyZXMgb2YgbW9kZWwgJG0kLgoKSW4gbGluZWFyIG1vZGVscyB3aXRoIG5vcm1hbCBlcnJvciB0ZXJtcywgTWFsbG93J3MgJENfcCQgY3JpdGVyaW9uIChzdGF0aXN0aWMpIGlzIGEgbGluZWFyaXNlZCB2ZXJzaW9uIG9mIEFJQyBhbmQgaXQgaXMgYW4gdW5iaWFzZWQgZXN0aW1hdG9yIG9mIHRoZSBpbi1zYW1wbGUgZXJyb3IuCgotLS0KCiMjIyBCYXllc2lhbiBJbmZvcm1hdGlvbiBDcml0ZXJpb24gKEJJQyl9CgpUaGUgQklDIGZvciBhIG1vZGVsICRtJCBpcyBnaXZlbiBieQpcWwpcdGV4dHtCSUN9ID0gLTIgXGxuIFxoYXR7TH0obSkgK3BcbG4obikKXF0Kd2hlcmUgJFxoYXR7TH0obSkkIGlzIHRoZSBtYXhpbWlzZWQgbGlrZWxpaG9vZCBmb3IgbW9kZWwgJG0kLgoKV2hlbiBhc3N1bWluZyBub3JtYWxseSBkaXN0cmlidXRlZCBlcnJvciB0ZXJtcyBhbmQgaG9tb3NjZWRhc3RpY2l0eSwgdGhlIEJJQyBiZWNvbWVzClxbClx0ZXh0e0JJQ30gPSBuXGxuIFx0ZXh0e1NTRX0obSkgK3BcbG4obikgPSBuXGxuKG5cb3ZlcmxpbmV7XHRleHR7ZXJyfX0obSkpICsgcFxsbihuKQpcXQp3aXRoICRcdGV4dHtTU0V9KG0pJCB0aGUgcmVzaWR1YWwgc3VtIG9mIHNxdWFyZXMgb2YgbW9kZWwgJG0kLgoKV2hlbiBsYXJnZSBkYXRhc2V0cyBhcmUgdXNlZCwgdGhlIEJJQyB3aWxsIGZhdm91ciBzbWFsbGVyIG1vZGVscyB0aGFuIHRoZSBBSUMuCgotLS0KCiMjIFRyYWluaW5nIGFuZCB0ZXN0IHNldHMKClNvbWV0aW1lcywgd2hlbiBhIGxhcmdlICh0cmFpbmluZykgZGF0YXNldCBpcyBhdmFpbGFibGUsIG9uZSBtYXkgZGVjaWRlIHRoZSBzcGxpdCB0aGUgZGF0YXNldCByYW5kb21seSBpbiBhCgotICoqdHJhaW5pbmcgZGF0YXNldCoqOgogICBkYXRhIGFyZSB1c2VkIGZvciBtb2RlbCBmaXR0aW5nIGFuZCBmb3IgbW9kZWwgYnVpbGRpbmcgb3IgZmVhdHVyZSBzZWxlY3Rpb24gKHRoaXMgbWF5IHJlcXVpcmUgZS5nLiBjcm9zcyB2YWxpZGF0aW9uKQoKLSAqKnRlc3QgZGF0YXNldCoqOgogICB0aGlzIGRhdGEgYXJlIHVzZWQgdG8gZXZhbHVhdGUgdGhlIGZpbmFsIG1vZGVsIChyZXN1bHQgb2YgbW9kZWwgYnVpbGRpbmcpLiBBbiB1bmJpYXNlZCBlc3RpbWF0ZSBvZiB0aGUgb3V0c2FtcGxlIGVycm9yIChpLmUuIHRlc3Qgb3IgZ2VuZXJhbGlzYXRpb24gZXJyb3IpIGJhc2VkIG9uIHRoaXMgdGVzdCBkYXRhIGlzCiAgXFsKICAgICBcZnJhY3sxfXttfSBcc3VtX3tpPTF9Xm0gXGxlZnQoXGhhdHttfShcbWF0aGJme3h9X2kpLVlfaVxyaWdodCleMiwKICBcXQogIHdoZXJlCiAgICAtICQoWV8xLFxtYXRoYmZ7eH1fMSksIFxsZG90cywgKFlfbSxcbWF0aGJme3h9X20pJCBkZW5vdGUgdGhlICRtJCBvYnNlcnZhdGlvbnMgaW4gdGhlIHRlc3QgZGF0YXNldAoKICAgIC0gJFxoYXR7bX0kIGlzIGVzdGltYXRlZCBmcm9tIHVzaW5nIHRoZSB0cmFpbmluZyBkYXRhICh0aGlzIG1heSBhbHNvIGJlIHRoZSByZXN1bHQgZnJvbSBtb2RlbCBidWlsZGluZywgdXNpbmcgb25seSB0aGUgdHJhaW5pbmcgZGF0YSkuCgotLS0KCk5vdGUgdGhhdCB0aGUgdHJhaW5pbmcgZGF0YXNldCBpcyB1c2VkIGZvciBtb2RlbCBidWlsZGluZyBvciBmZWF0dXJlIHNlbGVjdGlvbi4gVGhpcyBhbHNvIHJlcXVpcmVzIHRoZSBldmFsdWF0aW9uIG9mIG1vZGVscy4gRm9yIHRoZXNlIGV2YWx1YXRpb25zIHRoZSBtZXRob2RzIGZyb20gdGhlIHByZXZpb3VzIHNsaWRlcyBjYW4gYmUgdXNlZCAoZS5nLiBjcm9zcyB2YWxpZGF0aW9uLCAkayQtZm9sZCBDViwgTWFsbG93J3MgJENfcCQpLiBUaGUgdGVzdCBkYXRhc2V0IGlzIG9ubHkgdXNlZCBmb3IgdGhlICBldmFsdWF0aW9uIG9mIHRoZSBmaW5hbCBtb2RlbCAoZXN0aW1hdGVkIGFuZCBidWlsZCBmcm9tIHVzaW5nIG9ubHkgdGhlIHRyYWluaW5nIGRhdGEpLiBUaGUgZXN0aW1hdGUgb2YgdGhlIG91dHNhbXBsZSBlcnJvciBiYXNlZCBvbiB0aGUgdGVzdCBkYXRhc2V0IGlzIHRoZSBiZXN0IHBvc3NpYmxlIGVzdGltYXRlIGluIHRoZSBzZW5zZSB0aGF0IGl0IGlzIHVuYmlhc2VkLiBUaGUgb2JzZXJ2YXRpb25zIHVzZWQgZm9yIHRoaXMgZXN0aW1hdGlvbiBhcmUgaW5kZXBlbmRlbnQgb2YgdGhlIG9ic2VydmF0aW9ucyBpbiB0aGUgdHJhaW5pbmcgZGF0YS4KSG93ZXZlciwgaWYgdGhlIG51bWJlciBvZiBkYXRhIHBvaW50cyBpbiB0aGUgdGVzdCBkYXRhc2V0ICgkbSQpIGlzIHNtYWxsLCB0aGUgZXN0aW1hdGUgb2YgdGhlIG91dHNhbXBsZSBlcnJvciBtYXkgc2hvdyBsYXJnZSB2YXJpYW5jZSBhbmQgaGVuY2UgaXMgbm90IHJlbGlhYmxlLgoKIyBMb2dpc3RpYyBSZWdyZXNzaW9uIEFuYWx5c2lzIGZvciBIaWdoIERpbWVuc2lvbmFsIERhdGEKCiMjIEJyZWFzdCBDYW5jZXIgRXhhbXBsZQoKLSBTY2htaWR0ICpldCBhbC4qLCAyMDA4LCBDYW5jZXIgUmVzZWFyY2gsICoqNjgqKiwgNTQwNS01NDEzCgotIEdlbmUgZXhwcmVzc2lvbiBwYXR0ZXJucyBpbiAkbj0yMDAkIGJyZWFzdCB0dW1vcnMgd2VyZSBpbnZlc3RpZ2F0ZWQgKCRwPTIyMjgzJCBnZW5lcykKCi0gQWZ0ZXIgc3VyZ2VyeSB0aGUgdHVtb3JzIHdlcmUgZ3JhZGVkIGJ5IGEgcGF0aG9sb2dpc3QgKHN0YWdlIDEsMiwzKQoKLSBIZXJlIHRoZSBvYmplY3RpdmUgaXMgdG8gcHJlZGljdCBzdGFnZSAzIGZyb20gdGhlIGdlbmUgZXhwcmVzc2lvbiBkYXRhIChwcmVkaWN0aW9uIG9mIGJpbmFyeSBvdXRjb21lKQoKLSBJZiB0aGUgcHJlZGljdGlvbiBtb2RlbCB3b3JrcyB3ZWxsLCBpdCBjYW4gYmUgdXNlZCB0byBwcmVkaWN0IHRoZSBzdGFnZSBmcm9tIGEgYmlvcHN5IHNhbXBsZS4KCiMjIERhdGEKCmBgYHtyLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQojQmlvY01hbmFnZXI6Omluc3RhbGwoImdlbmVmdSIpCiNCaW9jTWFuYWdlcjo6aW5zdGFsbCgiYnJlYXN0Q2FuY2VyTUFJTloiKQoKbGlicmFyeShnZW5lZnUpCmxpYnJhcnkoYnJlYXN0Q2FuY2VyTUFJTlopCmRhdGEobWFpbnopCgpYIDwtIHQoZXhwcnMobWFpbnopKSAjIGdlbmUgZXhwcmVzc2lvbnMKbiA8LSBucm93KFgpCkggPC0gZGlhZyhuKS0xL24qbWF0cml4KDEsbmNvbD1uLG5yb3c9bikKWCA8LSBIJSolWApZIDwtIGlmZWxzZShwRGF0YShtYWlueikkZ3JhZGU9PTMsMSwwKQp0YWJsZShZKQoKc3ZkWCA8LSBzdmQoWCkKayA8LSAyClprIDwtIHN2ZFgkdVssMTprXSAlKiUgZGlhZyhzdmRYJGRbMTprXSkKY29sbmFtZXMoWmspIDwtIHBhc3RlMCgiWiIsMTprKQoKWmsgJT4lCiAgYXMuZGF0YS5mcmFtZSAlPiUKICBtdXRhdGUoZ3JhZGUgPSBZICU+JSBhcy5mYWN0b3IpICU+JQogIGdncGxvdChhZXMoeD0gWjEsIHkgPSBaMiwgY29sb3IgPSBncmFkZSkpICsKICBnZW9tX3BvaW50KHNpemUgPSAzKQpgYGAKCi0tLQoKIyMgTG9naXN0aWMgcmVncmVzc2lvbiBtb2RlbHMKCkJpbmFyeSBvdXRjb21lcyBhcmUgb2Z0ZW4gYW5hbHlzZWQgd2l0aCAqKmxvZ2lzdGljIHJlZ3Jlc3Npb24gbW9kZWxzKiouCgpMZXQgJFkkIGRlbm90ZSB0aGUgYmluYXJ5ICgxLzAsIGNhc2UvY29udHJvbCwgcG9zaXRpdmUvbmVnYXRpdmUpIG91dGNvbWUsIGFuZCAkXG1hdGhiZnt4fSQgdGhlICRwJC1kaW1lbnNpb25hbCBwcmVkaWN0b3IuCgpMb2dpc3RpYyByZWdyZXNzaW9uICBhc3N1bWVzClxbCiAgIFkgXG1pZCBcbWF0aGJme3h9IFxzaW0gXHRleHR7QmVybm91bGxpfShccGkoXG1hdGhiZnt4fSkpClxdCndpdGggJFxwaShcbWF0aGJme3h9KSA9IFx0ZXh0e1B9XGxlZnRbWT0xXG1pZCBcbWF0aGJme3h9XHJpZ2h0XSQgYW5kClxbCiAgIFxsbiBcZnJhY3tccGkoXG1hdGhiZnt4fSl9ezEtXHBpKFxtYXRoYmZ7eH0pfT1cYmV0YV8wICsgXGJvbGRzeW1ib2x7XGJldGF9XlRcbWF0aGJme3h9LgpcXQoKVGhlIHBhcmFtZXRlcnMgYXJlIHR5cGljYWxseSBlc3RpbWF0ZWQgYnkgbWF4aW1pc2luZyB0aGUgbG9nLWxpa2VsaWhvb2QsIHdoaWNoIGlzIGRlbm90ZWQgYnkgJGwoXG1hdGhiZnsKXGJldGF9KSQsIGkuZS4KXFsKICAgXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19ID0gXHRleHR7QXJnTWF4fV9cYmV0YSBsKFxib2xkc3ltYm9se1xiZXRhfSkuClxdCgotIE1heGltdW0gbGlrZWxpaG9vZCBpcyBvbmx5IGFwcGxpY2FibGUgd2hlbiAkbj5wJC4KCi0gV2hlbiAkcD5uJCBwZW5hbGlzZWQgbWF4aW11bSBsaWtlbGlob29kIG1ldGhvZHMgYXJlIGFwcGxpY2FibGUuCgotLS0KCiMjIFBlbmFsaXplZCBtYXhpbXVtIGxpa2VsaWhvb2QKClBlbmFsaXNlZCBlc3RpbWF0aW9uIG1ldGhvZHMgKGUuZy4gbGFzc28gYW5kIHJpZGdlKSBjYW4gYWxzIGJlIGFwcGxpZWQgdG8gbWF4aW11bSBsaWtlbGlob29kLCByZXN1bHRpbmcgaW4gdGhlICoqcGVuYWxpc2VkIG1heGltdW0gbGlrZWxpaG9vZCBlc3RpbWF0b3IqKi4KCkxhc3NvOgpcWwogIFxoYXR7XGJvbGRzeW1ib2x7XGJldGF9fSA9IFx0ZXh0e0FyZ01heH1fXGJldGEgbChcYm9sZHN5bWJvbHtcYmV0YX0pIC1cbGFtYmRhIFxWZXJ0IFxib2xkc3ltYm9se1xiZXRhfVxWZXJ0XzEuClxdCgpSaWRnZToKXFsKICBcaGF0e1xib2xkc3ltYm9se1xiZXRhfX0gPSBcdGV4dHtBcmdNYXh9X1xiZXRhIGwoXGJvbGRzeW1ib2x7XGJldGF9KSAtXGxhbWJkYSBcVmVydCBcYm9sZHN5bWJvbHtcYmV0YX1cVmVydF8yXjIuClxdCgpPbmNlIHRoZSBwYXJhbWV0ZXJzIGFyZSBlc3RpbWF0ZWQsIHRoZSBtb2RlbCBtYXkgYmUgdXNlZCB0byBjb21wdXRlClxbCiAgXGhhdHtccGl9KFxtYXRoYmZ7eH0pID0gXGhhdHtcdGV4dHtQfX1cbGVmdFtZPTFcbWlkIFxtYXRoYmZ7eH1ccmlnaHRdLgpcXQpXaXRoIHRoZXNlIGVzdGltYXRlZCBwcm9iYWJpbGl0aWVzIHRoZSBwcmVkaWN0aW9uIHJ1bGUgYmVjb21lcwpcYmVnaW57ZXFuYXJyYXkqfQogIFxoYXR7XHBpfShcbWF0aGJme3h9KSAmXGxlcSBjJiBcdGV4dHtwcmVkaWN0IH0gWT0wIFxcCiAgXGhhdHtccGl9KFxtYXRoYmZ7eH0pICY+YyAmIFx0ZXh0e3ByZWRpY3QgfSBZPTEKXGVuZHtlcW5hcnJheSp9CndpdGggJDA8YzwxJCBhIHRocmVzaG9sZCB0aGF0IGVpdGhlciBpcyBmaXhlZCAoZS5nLiAkYz0xLzIkKSwgZGVwZW5kcyBvbiBwcmlvciBwcm9iYWJpbGl0aWVzLCBvciBpcyBlbXBpcmljYWxseSBkZXRlcm1pbmVkIGJ5IG9wdGltaXNpbmcgZS5nLiB0aGUgQXJlYSBVbmRlciB0aGUgUk9DIEN1cnZlIChBVUMpIG9yIGJ5IGZpbmRpbmcgYSBnb29kIGNvbXByb21pc2UgYmV0d2VlbiBzZW5zaXRpdml0eSBhbmQgc3BlY2lmaWNpdHkuCgpOb3RlIHRoYXQgbG9naXN0aWMgcmVncmVzc2lvbiBkaXJlY3RseSBtb2RlbHMgdGhlICoqUG9zdGVyaW9yIHByb2JhYmlsaXR5KiogdGhhdCBhbiBvYnNlcnZhdGlvbiBiZWxvbmdzIHRvIGNsYXNzICRZPTEkLCBnaXZlbiB0aGUgcHJlZGljdG9yICRcbWF0aGJme3h9JC4KCiMjIE1vZGVsIGV2YWx1YXRpb24KCkNvbW1vbiBtb2RlbCBldmFsdWF0aW9uIGNyaXRlcmlhIGZvciBiaW5hcnkgcHJlZGljdGlvbiBtb2RlbHMgYXJlOgoKLSBzZW5zaXRpdml0eSA9IHRydWUgcG9zaXRpdmUgcmF0ZSAoVFBSKQoKLSBzcGVjaWZpY2l0eSA9IHRydWUgbmVnYXRpdmUgcmF0ZSAoVE5SKQoKLSBtaXNjbGFzc2lmaWNhdGlvbiBlcnJvcgoKLSBhcmVhIHVuZGVyIHRoZSBST0MgY3VydmUgKEFVQykKClRoZXNlIGNyaXRlcmlhIGNhbiBhZ2FpbiBiZSBlc3RpbWF0ZWQgdmlhIGNyb3NzIHZhbGlkYXRpb24gb3IgdmlhIHNwbGl0dGluZyBvZiB0aGUgZGF0YSBpbnRvIHRyYWluaW5nIGFuZCB0ZXN0L3ZhbGlkYXRpb24gZGF0YS4KCiMjIyBTZW5zaXRpdml0eSBvZiBhIG1vZGVsICRccGkkIHdpdGggdGhyZXNob2xkICRjJAoKU2Vuc2l0aXZpdHkgaXMgdGhlIHByb2JhYmlsaXR5IHRvIGNvcnJlY3RseSBwcmVkaWN0IGEgcG9zaXRpdmUgb3V0Y29tZToKXFsKXHRleHR7c2Vuc30oXHBpLGMpPVx0ZXh0e1B9X3tYXip9XGxlZnRbXGhhdFxwaShcbWF0aGJme1h9XiopPmMgXG1pZCBZXio9MSBcbWlkIHtcbWF0aGNhbHtUfX1ccmlnaHRdLgpcXQoKSXQgaXMgYWxzbyBrbm93biBhcyB0aGUgdHJ1ZSBwb3NpdGl2ZSByYXRlIChUUFIpLgoKIyMjIFNwZWNpZmljaXR5IG9mIGEgbW9kZWwgJFxwaSQgd2l0aCB0aHJlc2hvbGQgJGMkCgpTcGVjaWZpY2l0eSBpcyB0aGUgcHJvYmFiaWxpdHkgdG8gY29ycmVjdGx5IHByZWRpY3QgYSBuZWdhdGl2ZSBvdXRjb21lOgpcWwpcdGV4dHtzcGVjfShccGksYyk9XHRleHR7UH1fe1heKn1cbGVmdFtcaGF0XHBpKFxtYXRoYmZ7WH1eKilcbGVxIGMgXG1pZCBZXio9MCBcbWlkIHtcbWF0aGNhbHtUfX1ccmlnaHRdLgpcXQoKSXQgaXMgYWxzbyBrbm93biBhcyB0aGUgdHJ1ZSBuZWdhdGl2ZSByYXRlIChUTlIpLgoKLS0tCgojIyMgTWlzY2xhc3NpZmljYXRpb24gZXJyb3Igb2YgYSBtb2RlbCAkXHBpJCB3aXRoIHRocmVzaG9sZCAkYyQKClRoZSBtaXNjbGFzc2lmaWNhdGlvbiBlcnJvciBpcyB0aGUgcHJvYmFiaWxpdHkgdG8gaW5jb3JyZWN0bHkgcHJlZGljdCBhbiBvdXRjb21lOgpcYmVnaW57ZXFuYXJyYXkqfQpcdGV4dHttY2V9KFxwaSxjKSAmPSZcdGV4dHtQfV97WF4qLFleKn1cbGVmdFtcaGF0XHBpKFxtYXRoYmZ7WH0pXGxlcSBjIFx0ZXh0eyBhbmQgfSBZXio9MSBcbWlkIHtcbWF0aGNhbHtUfX1ccmlnaHRdIFxcCiYgICYgKyBcdGV4dHtQfV97WF4qLFleKn1cbGVmdFtcaGF0XHBpKFxtYXRoYmZ7WH0pPiBjIFx0ZXh0eyBhbmQgfSBZXio9MCBcbWlkIHtcbWF0aGNhbHtUfX1ccmlnaHRdLgpcZW5ke2VxbmFycmF5Kn0KCk5vdGUgdGhhdCBpbiB0aGUgZGVmaW5pdGlvbnMgb2Ygc2Vuc2l0aXZpdHksIHNwZWNpZmljaXR5IGFuZCB0aGUgbWlzY2xhc3NpZmljYXRpb24gZXJyb3IsIHRoZSBwcm9iYWJpbGl0aWVzIHJlZmVyIHRvIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlICAkKFxtYXRoYmZ7WH1eKixZXiopJCwgd2hpY2ggaXMgaW5kZXBlbmRlbnQgb2YgdGhlIHRyYWluaW5nIGRhdGEsIGNvbmRpdGlvbmFsIG9uIHRoZSB0cmFpbmluZyBkYXRhLiBUaGlzIGlzIGluIGxpbmUgd2l0aCB0aGUgdGVzdCBvciBnZW5lcmFsaXNhdGlvbiBlcnJvci4gVGhlIG1pc2NsYXNzaWZpY2F0aW9uIGVycm9yIGlzIGFjdHVhbGx5IHRoZSB0ZXN0IGVycm9yIHdoZW4gYSAwLzEgbG9zcyBmdW5jdGlvbiBpcyB1c2VkLiBKdXN0IGFzIGJlZm9yZSwgdGhlIHNlbnNpdGl2aXR5LCBzcGVjaWZpY2l0eSBhbmQgdGhlIG1pc2NsYXNzaWZpY2F0aW9uIGVycm9yIGNhbiBhbHNvIGJlIGF2ZXJhZ2VkIG92ZXIgdGhlIGRpc3RyaWJ1dGlvbiBvZiB0aGUgdHJhaW5pbmcgZGF0YSBzZXQsIHdoaWNoIGlzIGluIGxpbmUgd2l0aCB0aGUgZXhwZWN0ZWQgdGVzdCBlcnJvciB3aGljaCBoYXMgYmVlbiBkaXNjdXNzZWQgZWFybGllci4KCi0tLQoKIyMjIFJPQyBjdXJ2ZSBvZiBhIG1vZGVsICRccGkkCgpUaGUgUmVjZWl2ZXIgT3BlcmF0aW5nIENoYXJhY3RlcmlzdGljIChST0MpIGN1cnZlIGZvciBtb2RlbCAkXHBpJCBpcyBnaXZlbiBieSB0aGUgZnVuY3Rpb24KClxbClx0ZXh0e1JPQ306IFswLDFdIFxyaWdodGFycm93IFswLDFdXHRpbWVzIFswLDFdOiBjIFxtYXBzdG8gKDEtXHRleHR7c3BlY30oXHBpLGMpLCBcdGV4dHtzZW5zfShccGksYykpLgpcXQoKRm9yIHdoZW4gJGMkIG1vdmVzIGZyb20gMSB0byAwLCB0aGUgUk9DIGZ1bmN0aW9uIGRlZmluZXMgYSBjdXJ2ZSBpbiB0aGUgcGxhbmUgJFswLDFdXHRpbWVzIFswLDFdJCwgbW92aW5nIGZyb20gJCgwLDApJCBmb3IgJGM9MSQgdG8gJCgxLDEpJCBmb3IgJGM9MCQuCgpUaGUgaG9yaXpvbnRhbCBheGlzIG9mIHRoZSBST0MgY3VydmUgc2hvd3MgMS1zcGVjaWZpY2l0eS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIHRoZSBGYWxzZSBQb3NpdGl2ZSBSYXRlIChGUFIpLgoKLS0tCgojIyMgQXJlYSB1bmRlciB0aGUgY3VydmUgKEFVQykgb2YgYSBtb2RlbCAkXHBpJAoKVGhlIGFyZWEgdW5kZXIgdGhlIGN1cnZlIChBVUMpIGZvciBtb2RlbCAkXHBpJCBpcyBhcmVhIHVuZGVyIHRoZSBST0MgY3VydmUgYW5kIGlzIGdpdmVuIGJ5ClxbClxpbnRfMF4xIFx0ZXh0e1JPQ30oYykgZGMuClxdCgpTb21lIG5vdGVzIGFib3V0IHRoZSBBVUM6CgotIEFVQz0wLjUgcmVzdWx0cyB3aGVuIHRoZSBST0MgY3VydmUgaXMgdGhlIGRpYWdvbmFsLiBUaGlzIGNvcnJlc3BvbmRzIHRvIGZsaXBwaW5nIGEgY29pbiwgaS5lLiBhIGNvbXBsZXRlIHJhbmRvbSBwcmVkaWN0aW9uLgoKLSBBVUM9MSByZXN1bHRzIGZyb20gdGhlIHBlcmZlY3QgUk9DIGN1cnZlLCB3aGljaCBpcyB0aGUgUk9DIGN1cnZlIHRocm91Z2ggdGhlIHBvaW50cyAkKDAsMCkkLCAkKDAsMSkkIGFuZCAkKDEsMSkkLiBUaGlzIFJPQyBjdXJ2ZSBpbmNsdWRlcyBhIHRocmVzaG9sZCAkYyQgc3VjaCB0aGF0IHNlbnNpdGl2aXR5IGFuZCBzcGVjaWZpY2l0eSBhcmUgZXF1YWwgdG8gb25lLgoKIyMgQnJlYXN0IGNhbmNlciBleGFtcGxlCgojIyMgRGF0YQoKYGBge3IsIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CmxpYnJhcnkoZ2xtbmV0KQoKI0Jpb2NNYW5hZ2VyOjppbnN0YWxsKCJnZW5lZnUiKQojQmlvY01hbmFnZXI6Omluc3RhbGwoImJyZWFzdENhbmNlck1BSU5aIikKCmxpYnJhcnkoZ2VuZWZ1KQpsaWJyYXJ5KGJyZWFzdENhbmNlck1BSU5aKQpkYXRhKG1haW56KQoKWCA8LSB0KGV4cHJzKG1haW56KSkgIyBnZW5lIGV4cHJlc3Npb25zCm4gPC0gbnJvdyhYKQpIIDwtIGRpYWcobiktMS9uKm1hdHJpeCgxLG5jb2w9bixucm93PW4pClggPC0gSCUqJVgKWSA8LSBpZmVsc2UocERhdGEobWFpbnopJGdyYWRlPT0zLDEsMCkKdGFibGUoWSkKYGBgCgotLS0KCkZyb20gdGhlIHRhYmxlIG9mIHRoZSBvdXRjb21lcyBpbiBZIHdlIHJlYWQgdGhhdAoKLSBgciBzdW0oWT09MSlgIHR1bW9ycyB3ZXJlIGdyYWRlZCBhcyBzdGFnZSAzIGFuZAotIGByIHN1bShZPT0wKWAgdHVtb3JzIHdlcmUgZ3JhZGVkIGFzIHN0YWdlIDEgb3IgMi4KCkluIHRoaXMgdGhlIHN0YWdlIDMgdHVtb3JzIGFyZSByZWZlcnJlZCB0byBhcyBjYXNlcyBvciBwb3N0aXZlcyBhbmQgdGhlIHN0YWdlIDEgYW5kIDIgdHVtb3JzIGFzIGNvbnRyb2xzIG9yIG5lZ2F0aXZlcy4KCi0tLQoKIyMjIFRyYWluaW5nIGFuZCB0ZXN0IGRhdGFzZXQKClRoZSB1c2Ugb2YgdGhlIGxhc3NvIGxvZ2lzdGljIHJlZ3Jlc3Npb24gZm9yIHRoZSBwcmVkaWN0aW9uIG9mIHN0YWdlIDMgYnJlYXN0IGNhbmNlciBpcyBpbGx1c3RyYXRlZCBoZXJlIGJ5CgotIHJhbmRvbWx5IHNwbGl0dGluZyB0aGUgZGF0YXNldCBpbnRvIGEgdHJhaW5pbmcgZGF0YXNldCAoJDgwXCUkIG9mIGRhdGEgPSAxNjAgdHVtb3JzKSBhbmQgYSB0ZXN0IGRhdGFzZXQgKDQwIHR1bW9ycykKCi0gdXNpbmcgdGhlIHRyYWluaW5nIGRhdGEgdG8gc2VsZWN0IGEgZ29vZCAkXGxhbWJkYSQgdmFsdWUgaW4gdGhlIGxhc3NvIGxvZ2lzdGljIHJlZ3Jlc3Npb24gbW9kZWwgKHRocm91Z2ggMTAtZm9sZCBDVikKCi0gZXZhbHVhdGluZyB0aGUgZmluYWwgbW9kZWwgYnkgbWVhbnMgb2YgdGhlIHRlc3QgZGF0YXNldCAoUk9DIEN1cnZlLCBBVUMpLgoKCmBgYHtyfQoKIyMgVXNlZCB0byBwcm92aWRlIHNhbWUgcmVzdWx0cyBhcyBpbiBwcmV2aW91cyBSIHZlcnNpb24KUk5Ha2luZChzYW1wbGUua2luZCA9ICJSb3VuZGluZyIpCnNldC5zZWVkKDY5NzczMjYpCiMjIyMKCm4gPC0gbnJvdyhYKQpuVHJhaW4gPC0gcm91bmQoMC44Km4pCm5UcmFpbgoKaW5kVHJhaW4gPC0gc2FtcGxlKDE6bixuVHJhaW4pClhUcmFpbiA8LSBYW2luZFRyYWluLF0KWVRyYWluIDwtIFlbaW5kVHJhaW5dClhUZXN0IDwtIFhbLWluZFRyYWluLF0KWVRlc3QgPC0gWVstaW5kVHJhaW5dCnRhYmxlKFlUZXN0KQpgYGAKCk5vdGUgdGhhdCB0aGUgcmFuZG9tbHkgc2VsZWN0ZWQgdGVzdCBkYXRhIGhhcyBgciBtZWFuKFlUZXN0PT0xKSoxMDBgJSBjYXNlcyBvZiBzdGFnZSAzIHR1bW9ycy4KVGhpcyBpcyBhIGJpdCBoaWdoZXIgdGhhbiB0aGUgYHIgbWVhbihZPT0xKSoxMDBgJSAgaW4gdGhlIGNvbXBsZXRlIGRhdGEuCgpPbmUgY291bGQgYWxzbyBwZXJmb3JtIHRoZSByYW5kb20gc3BsaXR0aW5nIGFtb25nIHRoZSBwb3NpdGl2ZXMgYW5kIHRoZSBuZWdhdGl2ZXMgc2VwYXJhdGVseSAoc3RyYXRpZmllZCBzcGxpdHRpbmcpLgoKIyMjIE1vZGVsIGZpdHRpbmcgYmFzZWQgb24gdHJhaW5pbmcgZGF0YQoKYGBge3J9Cm1MYXNzbyA8LSBnbG1uZXQoCiAgeCA9IFhUcmFpbiwKICB5ID0gWVRyYWluLAogIGFscGhhID0gMSwKICBmYW1pbHk9ImJpbm9taWFsIikgICMgbGFzc286IGFscGhhID0gMQoKcGxvdChtTGFzc28sIHh2YXIgPSAibGFtYmRhIiwgeGxpbSA9IGMoLTYsLTEuNSkpCmBgYAoKLS0tCgpgYGB7cn0KbUN2TGFzc28gPC0gY3YuZ2xtbmV0KAogIHggPSBYVHJhaW4sCiAgeSA9IFlUcmFpbiwKICBhbHBoYSA9IDEsCiAgdHlwZS5tZWFzdXJlID0gImNsYXNzIiwKCWZhbWlseSA9ICJiaW5vbWlhbCIpICAjIGxhc3NvIGFscGhhID0gMQoKcGxvdChtQ3ZMYXNzbykKbUN2TGFzc28KYGBgCgpUaGUgdG90YWwgbWlzY2xhc3NpZmljYXRpb24gZXJyb3IgaXMgdXNlZCBoZXJlIHRvIHNlbGVjdCBhIGdvb2QgdmFsdWUgZm9yICRcbGFtYmRhJC4KCmBgYHtyfQojIEJpb2NNYW5hZ2VyOjppbnN0YWxsKCJwbG90Uk9DIikKbGlicmFyeShwbG90Uk9DKQoKZGZMYXNzb09wdCA8LSBkYXRhLmZyYW1lKAogIHBpID0gcHJlZGljdChtQ3ZMYXNzbywKICAgIG5ld3ggPSBYVGVzdCwKICAgIHMgPSBtQ3ZMYXNzbyRsYW1iZGEubWluLAogICAgdHlwZSA9ICJyZXNwb25zZSIpICU+JSBjKC4pLAogIGtub3duLnRydXRoID0gWVRlc3QpCgpyb2MgPC0KICBkZkxhc3NvT3B0ICAlPiUKICBnZ3Bsb3QoYWVzKGQgPSBrbm93bi50cnV0aCwgbSA9IHBpKSkgKwogIGdlb21fcm9jKG4uY3V0cyA9IDApICsKICB4bGFiKCIxLXNwZWNpZmljaXR5IChGUFIpIikgKwogIHlsYWIoInNlbnNpdGl2aXR5IChUUFIpIikKCnJvYwoKY2FsY19hdWMocm9jKQpgYGAKCi0gVGhlIFJPQyBjdXJ2ZSBpcyBzaG93biBmb3IgdGhlIG1vZGVsIGJhc2VkIG9uICRcbGFtYmRhJCB3aXRoIHRoZSBzbWFsbGVzdCBtaXNjbGFzc2lmaWNhdGlvbiBlcnJvci4gVGhlIG1vZGVsIGhhcyBhbiBBVUMgb2YgYHIgY2FsY19hdWMocm9jKSAlPiUgcHVsbChBVUMpICU+JSByb3VuZCgyKWAuCgotIEJhc2VkIG9uIHRoaXMgUk9DIGN1cnZlIGFuIGFwcHJvcHJpYXRlIHRocmVzaG9sZCAkYyQgY2FuIGJlIGNob3Nlbi4gRm9yIGV4YW1wbGUsIGZyb20gdGhlIFJPQyBjdXJ2ZSB3ZSBzZWUgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBhdHRhaW4gYSBzcGVjaWZpY2l0eSBhbmQgYSBzZW5zaXRpdml0eSBvZiA3NVwlLgoKLSBUaGUgc2Vuc2l0aXZpdGllcyBhbmQgc3BlY2lmaWNpdGllcyBpbiB0aGUgUk9DIGN1cnZlIGFyZSB1bmJpYXNlZCAoaW5kZXBlbmRlbnQgdGVzdCBkYXRhc2V0KSBmb3IgdGhlIHByZWRpY3Rpb24gbW9kZWwgYnVpbGQgZnJvbSB0aGUgdHJhaW5pbmcgZGF0YS4gVGhlIGVzdGltYXRlcyBvZiBzZW5zaXRpdml0eSBhbmQgc3BlY2lmaWNpdHksIGhvd2V2ZXIsIGFyZSBiYXNlZCBvbiBvbmx5IDQwIG9ic2VydmF0aW9ucy4KCi0tLQoKYGBge3J9Cm1MYW1iZGFPcHQgPC0gZ2xtbmV0KHggPSBYVHJhaW4sCiAgeSA9IFlUcmFpbiwKICBhbHBoYSA9IDEsCiAgbGFtYmRhID0gbUN2TGFzc28kbGFtYmRhLm1pbiwKICBmYW1pbHk9ImJpbm9taWFsIikKCnFwbG90KAogIHN1bW1hcnkoY29lZihtTGFtYmRhT3B0KSlbLTEsMV0sCiAgc3VtbWFyeShjb2VmKG1MYW1iZGFPcHQpKVstMSwzXSkgKwogIHhsYWIoImdlbmUgSUQiKSArCiAgeWxhYigiYmV0YS1oYXQiKSArCiAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gMCwgY29sb3IgPSAicmVkIikKYGBgCgotIFRoZSBtb2RlbCB3aXRoIHRoZSBvcHRpbWFsICRcbGFtYmRhJCBoYXMgb25seSBgciBtTGFtYmRhT3B0ICU+JSBjb2VmICU+JSBzdW1tYXJ5ICU+JSBucm93YCBub24temVybyBwYXJhbWV0ZXIgZXN0aW1hdGVzLgotIFRodXMgb25seSBgciBtTGFtYmRhT3B0ICU+JSBjb2VmICU+JSBzdW1tYXJ5ICU+JSBucm93YCBnZW5lcyBhcmUgaW52b2x2ZWQgaW4gdGhlIHByZWRpY3Rpb24gbW9kZWwuCi0gVGhlc2UgYHIgbUxhbWJkYU9wdCAlPiUgY29lZiAlPiUgc3VtbWFyeSAlPiUgbnJvd2AgcGFyYW1ldGVyIGVzdGltYXRlcyBhcmUgcGxvdHRpbmcgaW4gdGhlIGdyYXBoLgpBIGxpc3Rpbmcgb2YgdGhlIG1vZGVsIG91dHB1dCB3b3VsZCBzaG93IHRoZSBuYW1lcyBvZiB0aGUgZ2VuZXMuCgotLS0KCmBgYHtyfQoKZGZMYXNzbzFzZSA8LSBkYXRhLmZyYW1lKAogIHBpID0gcHJlZGljdChtQ3ZMYXNzbywKICAgIG5ld3ggPSBYVGVzdCwKICAgIHMgPSBtQ3ZMYXNzbyRsYW1iZGEuMXNlLAogICAgdHlwZSA9ICJyZXNwb25zZSIpICU+JSBjKC4pLAogIGtub3duLnRydXRoID0gWVRlc3QpCgpyb2MgPC0KICByYmluZCgKICAgIGRmTGFzc29PcHQgJT4lCiAgICAgIG11dGF0ZShtZXRob2QgPSAibWluIiksCiAgICBkZkxhc3NvMXNlICU+JQogICAgICBtdXRhdGUobWV0aG9kID0gIjFzZSIpCiAgKSAlPiUKICBnZ3Bsb3QoYWVzKGQgPSBrbm93bi50cnV0aCwgbSA9IHBpLCBjb2xvciA9IG1ldGhvZCkpICsKICBnZW9tX3JvYyhuLmN1dHMgPSAwKSArCiAgeGxhYigiMS1zcGVjaWZpY2l0eSAoRlBSKSIpICsKICB5bGFiKCJzZW5zaXRpdml0eSAoVFBSKSIpCgpyb2MKCmNhbGNfYXVjKHJvYykKYGBgCgotIFdoZW4gdXNpbmcgdGhlICRcbGFtYmRhJCBvZiB0aGUgb3B0aW1hbCBtb2RlbCB1cCB0byAxIHN0YW5kYXJkIGRldmlhdGlvbiwgYSBkaWFnb25hbCBST0MgY3VydmUgaXMgb2J0YWluZWQgYW5kIGhlbmNlIEFVQyBpcyAkMC41JC4KCi0gVGhpcyBwcmVkaWN0aW9uIG1vZGVsIGlzIHRodXMgZXF1aXZhbGVudCB0byBmbGlwcGluZyBhIGNvaW4gZm9yIG1ha2luZyB0aGUgcHJlZGljdGlvbi4KCi0gVGhlIHJlYXNvbiBpcyB0aGF0IHdpdGggdGhpcyBjaG9pY2Ugb2YgJFxsYW1iZGEkIChzdHJvbmcgcGVuYWxpc2F0aW9uKSBhbG1vc3QgYWxsIHByZWRpY3RvcnMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbW9kZWwuCgotIFRoZXJlZm9yZSwgZG8gbmV2ZXIgYmxpbmRseSBjaG9vc2UgZm9yIHRoZSBgYG9wdGltYWwnJyAkXGxhbWJkYSQgYXMgZGVmaW5lZCBoZXJlLCBidXQgYXNzZXNzIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgbW9kZWwgZmlyc3QuCgpgYGB7cn0KbUxhbWJkYTFzZSA8LSBnbG1uZXQoeCA9IFhUcmFpbiwKICB5ID0gWVRyYWluLAogIGFscGhhID0gMSwKICBsYW1iZGEgPSBtQ3ZMYXNzbyRsYW1iZGEuMXNlLAogIGZhbWlseT0iYmlub21pYWwiKQoKbUxhbWJkYTFzZSAlPiUKICBjb2VmICU+JQogIHN1bW1hcnkKYGBgCgotLS0KCiMjIFRoZSBFbGFzdGljIE5ldAoKVGhlIGxhc3NvIGFuZCByaWRnZSByZWdyZXNzaW9uIGhhdmUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHByb3BlcnRpZXMuCgotIExhc3NvCgogICAtIHBvc2l0aXZlOiBzcGFyc2Ugc29sdXRpb24KCiAgIC0gbmVnYXRpdmU6IGF0IG1vc3QgJFxtaW4obixwKSQgcHJlZGljdG9ycyBjYW4gYmUgc2VsZWN0ZWQKCiAgIC0gbmVnYXRpdmU6IHRlbmQgdG8gc2VsZWN0IG9uZSBwcmVkaWN0b3IgYW1vbmcgYSBncm91cCBvZiBoaWdobHkgY29ycmVsYXRlZCBwcmVkaWN0b3JzCgoKLSBSaWRnZQoKICAgIC0gbmVnYXRpdmU6IG5vIHNwYXJzZSBzb2x1dGlvbgogICAgLSBwb3NpdGl2ZTogbW9yZSB0aGFuICRcbWluKG4scCkkIHByZWRpY3RvcnMgY2FuIGJlIHNlbGVjdGVkCgpBIGNvbXByb21pc2UgYmV0d2VlbiBsYXNzbyBhbmQgcmlkZ2U6IHRoZSAqKmVsYXN0aWMgbmV0Kio6ClxbCiAgXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19ID0gXHRleHR7QXJnTWF4fV9cYmV0YSBsKFxib2xkc3ltYm9se1xiZXRhfSkgLVxnYW1tYV8xIFxWZXJ0IFxib2xkc3ltYm9sXGJldGFcVmVydF8xIC1cZ2FtbWFfMiBcVmVydCBcYm9sZHN5bWJvbFxiZXRhXFZlcnRfMl4yLgpcXQoKVGhlIGVsYXN0aWMgZ2l2ZXMgYSBzcGFyc2Ugc29sdXRpb24gd2l0aCBwb3RlbnRpYWxseSBtb3JlIHRoYW4gJFxtaW4obixwKSQgcHJlZGljdG9ycy4KCi0tLQoKVGhlIGBnbG1uZXRgIFIgZnVuY3Rpb24gdXNlcyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcmlzYXRpb24sClxbCiAgXGhhdHtcYm9sZHN5bWJvbHtcYmV0YX19ID0gXHRleHR7QXJnTWF4fV9cYmV0YSBsKFxib2xkc3ltYm9se1xiZXRhfSkgLVxsYW1iZGFcYWxwaGEgXFZlcnQgXGJvbGRzeW1ib2xcYmV0YVxWZXJ0XzEgLVxsYW1iZGEoMS1cYWxwaGEpIFxWZXJ0IFxib2xkc3ltYm9sXGJldGFcVmVydF8yXjIuClxdCgotICRcYWxwaGEkIHBhcmFtZXRlciBnaXZlcyB3ZWlnaHQgdG8gJExfMSQgcGVuYWx0eSB0ZXJtIChoZW5jZSAkXGFscGhhPTEkIGdpdmVzIHRoZSBsYXNzbywgYW5kICRcYWxwaGE9MCQgZ2l2ZXMgcmlkZ2UpLgoKLSBhICRcbGFtYmRhJCBwYXJhbWV0ZXIgdG8gZ2l2ZSB3ZWlnaHQgdG8gdGhlIHBlbmFsaXNhdGlvbgoKLSBOb3RlIHRoYXQgdGhlIGNvbWJpbmF0aW9uIG9mICRcbGFtYmRhJCBhbmQgJFxhbHBoYSQgZ2l2ZXMgdGhlIHNhbWUgZmxleGliaWxpdHkgYXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBwYXJhbWV0ZXJzICRcbGFtYmRhXzEkIGFuZCAkXGxhbWJkYV8yJC4KCi0tLQoKIyMjIEJyZWFzdCBjYW5jZXIgZXhhbXBsZQoKYGBge3J9Cm1FbGFzdGljIDwtIGdsbW5ldCgKICB4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAwLjUsCiAgZmFtaWx5PSJiaW5vbWlhbCIpICAjIGVsYXN0aWMgbmV0CgpwbG90KG1FbGFzdGljLCB4dmFyID0gImxhbWJkYSIseGxpbT1jKC01LjUsLTEpKQpgYGAKCmBgYHtyfQptQ3ZFbGFzdGljIDwtIGN2LmdsbW5ldCh4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAwLjUsCiAgZmFtaWx5ID0gImJpbm9taWFsIiwKCXR5cGUubWVhc3VyZSA9ICJjbGFzcyIpICAjIGVsYXN0aWMgbmV0CgpwbG90KG1DdkVsYXN0aWMpCm1DdkVsYXN0aWMKYGBgCgpgYGB7cn0KZGZFbGFzdCA8LSBkYXRhLmZyYW1lKAogIHBpID0gcHJlZGljdChtRWxhc3RpYywKICAgIG5ld3ggPSBYVGVzdCwKICAgIHMgPSBtQ3ZFbGFzdGljJGxhbWJkYS5taW4sCiAgICB0eXBlID0gInJlc3BvbnNlIikgJT4lIGMoLiksCiAga25vd24udHJ1dGggPSBZVGVzdCkKCnJvYyA8LSByYmluZCgKICBkZkxhc3NvT3B0ICU+JSBtdXRhdGUobWV0aG9kID0gImxhc3NvIiksCiAgZGZFbGFzdCAlPiUgbXV0YXRlKG1ldGhvZCA9ICJlbGFzdC4gbmV0IikpICU+JQogIGdncGxvdChhZXMoZCA9IGtub3duLnRydXRoLCBtID0gcGksIGNvbG9yID0gbWV0aG9kKSkgKwogIGdlb21fcm9jKG4uY3V0cyA9IDApICsKICB4bGFiKCIxLXNwZWNpZmljaXR5IChGUFIpIikgKwogIHlsYWIoInNlbnNpdGl2aXR5IChUUFIpIikKCnJvYwoKY2FsY19hdWMocm9jKQpgYGAKCi0gTW9yZSBwYXJhbWV0ZXJzIGFyZSB1c2VkIHRoYW4gZm9yIHRoZSBsYXNzbywgYnV0IHRoZSBwZXJmb3JtYW5jZSBkb2VzIG5vdCBpbXByb3ZlLgoKYGBge3J9Cm1FbGFzdGljT3B0IDwtIGdsbW5ldCh4ID0gWFRyYWluLAogIHkgPSBZVHJhaW4sCiAgYWxwaGEgPSAwLjUsCiAgbGFtYmRhID0gbUN2RWxhc3RpYyRsYW1iZGEubWluLAogIGZhbWlseT0iYmlub21pYWwiKQoKcXBsb3QoCiAgc3VtbWFyeShjb2VmKG1FbGFzdGljT3B0KSlbLTEsMV0sCiAgc3VtbWFyeShjb2VmKG1FbGFzdGljT3B0KSlbLTEsM10pICsKICB4bGFiKCJnZW5lIElEIikgKwogIHlsYWIoImJldGEtaGF0IikgKwogIGdlb21faGxpbmUoeWludGVyY2VwdCA9IDAsIGNvbG9yID0gInJlZCIpCmBgYAoKIyBBY2tub3dsZWRnZW1lbnQgey19CgotIE9saXZpZXIgVGhhcyBmb3Igc2hhcmluZyBoaXMgbWF0ZXJpYWxzIG9mIEFuYWx5c2lzIG9mIEhpZ2ggRGltZW5zaW9uYWwgRGF0YSAyMDE5LTIwMjAsIHdoaWNoIEkgdXNlZCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoaXMgY2hhcHRlci4KCmBgYHtyLCBjaGlsZD0iX3Nlc3Npb24taW5mby5SbWQifQpgYGAK</div>
<div class="footer">
    <hr>
    This work is licensed under the <a href= "https://creativecommons.org/licenses/by-nc-sa/4.0">
    CC BY-NC-SA 4.0</a> licence.
</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("prediction.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>


</body>
</html>
